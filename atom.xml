<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>title</title>
  
  <subtitle>subtitle</subtitle>
  <link href="https://dongmaxiang.vercel.app/atom.xml" rel="self"/>
  
  <link href="https://dongmaxiang.vercel.app/"/>
  <updated>2022-03-26T03:07:16.000Z</updated>
  <id>https://dongmaxiang.vercel.app/</id>
  
  <author>
    <name>author</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习nodeJs</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E5%AD%A6%E4%B9%A0nodejs/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E5%AD%A6%E4%B9%A0nodejs/</id>
    <published>2022-03-26T03:07:16.000Z</published>
    <updated>2022-03-26T03:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="/posts/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0js%E5%88%B0nodejs">从浏览器到js到nodejs</a>  </p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;/posts/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0js%E5%88%B0nodejs&quot;&gt;从浏览器到js到nodejs&lt;/a&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h</summary>
      
    
    
    
    <category term="脚本语言" scheme="https://dongmaxiang.vercel.app/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"/>
    
    <category term="js" scheme="https://dongmaxiang.vercel.app/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/js/"/>
    
    
    <category term="js" scheme="https://dongmaxiang.vercel.app/tags/js/"/>
    
    <category term="脚本语言" scheme="https://dongmaxiang.vercel.app/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>你真的知道js的语法吗</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93js%E7%9A%84%E8%AF%AD%E6%B3%95%E5%90%97/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93js%E7%9A%84%E8%AF%AD%E6%B3%95%E5%90%97/</id>
    <published>2022-03-25T12:10:14.000Z</published>
    <updated>2022-03-25T12:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>先看这段代码   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 输出：2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出：1</span></span><br></pre></td></tr></table></figure><p>是不是很不解？？？常规思路都是输出2啊。<br>没关系，在了解了JS块级作用域之后你就懂了  </p><h3 id="全局作用域和function"><a href="#全局作用域和function" class="headerlink" title="全局作用域和function"></a>全局作用域和function</h3><p>在<a href="/posts/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0js%E5%88%B0nodejs#js">Ecma5</a>之前只有函数和全局作用域，也就是全局<code>window</code>或者<code>function()&#123;...&#125;</code>函数之内，而且var和function，在未声明之前可以访问，原因是js有内部变量提前的特性<br><strong>在同一作用域下<code>function</code>函数和<code>var</code>声明的变量都会被提至当前作用域的顶层，var优先声明，function其次，其中function提升的同时，函数体的实现也定义了出来</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    b();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是函数&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是内嵌函数b,num:&#x27;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 输出：1.我是内嵌函数b,num:undefined  2.我是函数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器解释代码之后会变成如下这个样子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// function提升的同时，方法实现也定义了出来</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是内嵌函数b,num:&#x27;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是函数&#x27;</span>);</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>Ecma6新增了块级作用域，增加了两个变量修饰符：<code>let</code>(值可变，不可二次声明)和<code>const</code>(常量、值不可变，可二次声明)，未声明之前访问会报错，而且<code>var</code>和<code>let</code>以及<code>const</code>声明的变量不能互换<br>理解了函数和变量提升之后，那么问题来了，如果块级作用域和块外作用域共有一个同名的变量，而function函数写在块中，该函数引用到同名变量，那么该函数到底是用块内还是块外变量呢？如下  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 按照上面的函数和变量的提升思路，那么这就是解释器解释后的代码样子</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>很明显，按照变量和函数提升至顶层之后的思路，解释之后会输出1，可我们实际想要的是2呀。输出为1就违背了块级作用域的概念，那么该如何解决呢？毕竟变量和函数的提升是老的特性，新设计的特性肯定要兼容旧的。没办法，js制定者只能在做一些取舍了<br>取舍如下：  </p><ol><li>函数如果在块中，那么<code>funtion</code>和<code>var</code>照样提升至前，只不过function的实现不允许提前定义，这样可以避免块中的内容溢出到块外，即块的内容只在块里面  </li><li>解释器在解释到块级作用域时，如果块中有函数，那么会在块中的最初位置用<code>let</code>以及新的变量名，重新定义一下这个函数，因为<code>funtion</code>被<code>let</code>定义在块中了，那么该function肯定可以访问到块中的变量<ul><li>为什么会在块中用新的变量从新定义呢，因为一个变量不能从<code>var</code>和<code>let</code>以及<code>const</code>相互转换  </li></ul></li><li>因为块内的函数的名称变了，所以块内涉及到的老的函数名称时，也要随着变。不然用<code>let</code>修饰的新变量名称也没有任何意义啊~  </li><li>然后又因为函数的作用域不仅仅在块内，块外也可以访问（要兼容之前的特性），所以在执行到函数原有声明的位置时，他会用<code>var</code>以及原有的变量名再次声明一下<br>这样就解决了块外和块内的变量名一样的问题了。代码如下<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 解释器解释后的代码的样子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>; <span class="comment">// 变量提升</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="literal">undefined</span>; <span class="comment">// 块内的函数提升，舍弃方法体的定义</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> new_test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 块内的函数，用let以及新的变量名定义，并在此定义出函数实现体</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> test = new_test; <span class="comment">// 用var把原有的变量名声明一下，执行完该代码块时，函数也可以在外部访问</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><blockquote><p>但是也有问题，比如在块中定义的函数，必须执行完块时，函数才可以访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test();   //执行会报错，找不到方法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//执行完块时才可访问</span></span><br></pre></td></tr></table></figure><p>世界上没有任何东西是十全十美的，在一件大事件上要尽量争取最好的度，做出最大的兼容(成本最小，接受面最广)</p></blockquote></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>回到最初的问题，我们以新解释器的角度重新审视一下代码，就能彻底的理解作用域的概念啦</p><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 输出：2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器解释之后的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>; <span class="comment">// 函数和变量提升至前，不给其函数实现的定义，以免块内污染块外  </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> new_a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;; <span class="comment">// 新变量名称用let进行修饰，并给出原有函数体的定义，使其函数在块内生效，在这个块中，涉及到原有变量名的都用新的变量名&#x27;new_a&#x27;</span></span><br><span class="line">    new_a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> a = new_a; <span class="comment">// 执行到原有代码时，需要把函数用原有的名称用&#x27;var&#x27;重新修饰一下，使其块外能访问到</span></span><br><span class="line">    new_a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(new_a); <span class="comment">// 输出：2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出：1</span></span><br></pre></td></tr></table></figure><h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 输出：2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出：function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器解释之后的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;  <span class="comment">// 变量提升</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> new_a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;; <span class="comment">// 块内的方法用&#x27;let&#x27;以及新的变量名修饰， 在这个块中，涉及到原有变量名的都用新的变量名&#x27;new_a&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> a = new_a; <span class="comment">// 执行到原有代码时，用var把原有的函数重新修饰，使其块外能访问到</span></span><br><span class="line">    new_a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(new_a); <span class="comment">// 输出：2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出：function</span></span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在块级作用域出现之前，只有函数作用域和全局作用域，为了解决变量的污染，就有了闭包，何为闭包？我理解的就是立即调用一个没有名字的函数，使其变量都在该函数中  </p><p><code>(function(arg)&#123;console.log(&#39;我是闭包,arg:&#39;, arg)&#125;)(123/*把外部变量从这里传进去*/);</code>这样就把变量锁死在大括号中了，可以理解为对一个匿名方法的调用  </p><p>也还有其他的写法如:<br><code>!function(arg)&#123;console.log(&#39;我是闭包,arg:&#39;, arg)&#125;(123/*把外部变量从这里传进去*/);</code>  </p><blockquote><p>为什么前面必须有运算符呢？可以理解为一元运算符对后面匿名变量的运算，如果把感叹号<code>!</code>去掉的话，执行器就不知道后面到底是什么语法了  </p></blockquote><p>可以理解为只要是一元运算符后面都可以接匿名变量，<code>+</code>或者<code>-</code>运算符都可以都可以</p><blockquote><p>为什么大多数都用!感叹号呢，因为运算时占用的cpu和空间比较少，他就是一个取反的运算：非真即假，其次因为编写也方便  </p></blockquote><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>谈到对象，最熟悉的莫过于<code>this</code>，this为当前对象，咱们都知道对象都是<code>new</code>出来的，那么js中的<code>this</code>到底该怎么用呢？<br><code>window</code>为全局对象，在任何一个地方，如果一个变量<code>a = 1</code>(没有任何修饰，如var、let、const)，那么也可以理解为<code>window.a = 1</code><br><code>var</code>声明的变量的作用域在<code>funtion</code>中，否则在上层的function，若上层没有function，那么就会延伸到<code>window</code>中  </p><h3 id="设计对象的结构"><a href="#设计对象的结构" class="headerlink" title="设计对象的结构"></a>设计对象的结构</h3><p>Ecma6之前，对象同方法，只需要new即可，至于对象的结构(包含的字段)，在函数中用this，指定即可  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.arg1 = arg1;</span><br><span class="line">   <span class="built_in">this</span>.arg2 = arg2;</span><br><span class="line">   arg3 = <span class="built_in">arguments</span>;</span><br><span class="line">   <span class="comment">// 本方法名称</span></span><br><span class="line">   <span class="built_in">this</span>.functionName = <span class="built_in">arguments</span>.callee.name;</span><br><span class="line">   <span class="comment">// 本方法的调用者，为空为window</span></span><br><span class="line">   <span class="built_in">this</span>.caller = <span class="built_in">arguments</span>.callee.caller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> test(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 对象创建</span></span><br><span class="line"><span class="built_in">console</span>.log(o.arg1); <span class="comment">// 输出：1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.arg1); <span class="comment">// 输出：undefined</span></span><br><span class="line"></span><br><span class="line">test(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 方法调用</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.arg2); <span class="comment">// 输出：4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.arg3); <span class="comment">// 输出：[3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一句话描述this，谁调用的我，这个this就是谁的</span></span><br></pre></td></tr></table></figure><blockquote><p>每个方法都有隐含的参数<code>arguments</code>类型为数组，该属性包含了该方法的所有参数，这个特性也就确定了js方法是没有重载的<br>JS方法中的this是可以改变的</p><ul><li><code>test.apply(this, arguments)</code>;</li><li><code>test.call(this, ...arguments)</code>;  </li></ul><p>apply和call都可以改变方法中的this，区别就是apply的参数必须传递数组，call只能把参数拆开，而<code>...</code>语法就是用来拆参数的(就是用来脱衣服的)</p></blockquote><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p</summary>
      
    
    
    
    <category term="脚本语言" scheme="https://dongmaxiang.vercel.app/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"/>
    
    <category term="js" scheme="https://dongmaxiang.vercel.app/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/js/"/>
    
    
    <category term="js" scheme="https://dongmaxiang.vercel.app/tags/js/"/>
    
    <category term="脚本语言" scheme="https://dongmaxiang.vercel.app/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器到js到nodejs</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0js%E5%88%B0nodejs/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0js%E5%88%B0nodejs/</id>
    <published>2022-03-22T05:03:08.000Z</published>
    <updated>2022-03-22T05:03:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器背景"><a href="#浏览器背景" class="headerlink" title="浏览器背景"></a>浏览器背景</h1><p>浏览器的历程<img src="/img/posts/2022/browserHistory.svg" alt="浏览器历史"></p><hr><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><p><a href="https://cn.history.js.org/">js二十年的历程</a></p><p>javaScript大家最熟悉不过啦，他是通用的浏览器脚本语言，简称js，不过还有一个名词叫EcmaScript，他们之间是什么关系呢？<br>原来EcmaScript是制定规范，javaScript是实现，ecma全称为 europe computer manufactures association即欧洲电脑制造商协会<br>自从浏览器诞生到现在,浏览器脚本语言一直是Js的天下-如上图的js诞生历程,从诞生之日起就确定了他是前端开发的唯一标准，这一切都得归功于<strong>布兰登·艾奇</strong>，js发明时吸收了以下几个语言的特点  </p><ul><li>基本语法、数据结构<ul><li>java、C</li></ul></li><li>函数的用法<ul><li>scheme</li></ul></li><li>原型链继承<ul><li>self语言</li></ul></li></ul><p>而且js是单线程模型，在任何时刻js的代码只有一处在执行，这也为后面的异步通信服务端的语言nodeJs奠定了语法的基础</p><blockquote><p>js = ecma规范 + webApi(dom + bom)<br>DOM（document object model）：文档对象模型，提供操作页面元素的方法和属性，如新增文字、图片，编辑文字，图片等<br>BOM（browser object model）；浏览器对象模型，提供一些属性和方法可以操作浏览器，如关闭页面、刷新页面、前进后退等  </p></blockquote><p><a href="/posts/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93js%E7%9A%84%E8%AF%AD%E6%B3%95%E5%90%97">js语法</a></p><hr><h1 id="js包管理-模块化"><a href="#js包管理-模块化" class="headerlink" title="js包管理---模块化"></a>js包管理---模块化</h1><blockquote><p>因为js没有模块的功能，更没有一个广泛能应用的标准库，所以诞生了诸多的js模块管理工具<br>由于js是前端语言，运行在客户端，不像服务端语言一样，服务端的模块化都在本地计算机缓存、文件系统中，而浏览器客户端都是在网络中，所以前端js的模块化比起后端模块的设计要考虑的更多  </p></blockquote><p>commonjs、requireJS(AMD)、seaJS(CMD)、webpack、ES6(Module)等，他们之前的关系是什么呢？哪种才是大众主流的呢？  </p><span id="commonjs"></span><h2 id="commonJs"><a href="#commonJs" class="headerlink" title="commonJs"></a>commonJs</h2><p>比较著名的实现者：nodeJs  </p><blockquote><p>最早的模块规范定制者，这个规范已经有很多版本和具体实现<br>commonJs前身叫serverJs，初衷是为了打破js只能在浏览器中运行的局面，构建JavaScript能在桌面环境、服务端运行的生态系统<br>这个项目最开始是由 Mozilla 的工程师 Kevin Dangoor 在2009年1月创建的，当时的名字是 ServerJS<br>2009年8月，这个项目改名为 CommonJS，以显示其 API 的更广泛实用性  </p></blockquote><p>该规范的主要内容是，模块必须通过<code>module.exports</code>导出对外的变量或接口，使用者通过<code>require(&#39;模块名&#39;)</code>来导入其他模块的输出到当前模块作用域中  </p><p>规范例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">var</span> multiplyBy2 = <span class="built_in">require</span>(<span class="string">&#x27;./moduleA&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> result = multiplyBy2(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>由于commonJs的规范在服务端大方光彩，但是到了客户端浏览器的表现就很一般了，因为commonJs是同步加载，对于服务端加载的资源都是在缓存或者本地文件中，耗时基本可忽略<br>但是在浏览器端可能会造成阻塞(取决于网络的好坏)白屏时间过长，用户体验不好，所以产生了AMD和CMD  </p><span id="amd-requirejs"></span><h2 id="AMD-requireJS"><a href="#AMD-requireJS" class="headerlink" title="AMD-requireJS"></a>AMD-requireJS</h2><p>客户端-浏览器专用的包管理<br>异步模块定义Asynchronous Module Definition，使浏览器避免假死长时间白屏的出现<br>比较著名的实现着： requireJS  ，其他如curl 、Dojo 、Nodules等。。。  </p><p>使用方式如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个参数，第一个为模块名(可选，不指定默认为文件名称)，</span></span><br><span class="line"><span class="comment">// 第二个参数为当前模块依赖的模块(可选，不指定默认为[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;])</span></span><br><span class="line"><span class="comment">// 第三个参数为当前模块的定义，参数为依赖的模块(如有有依赖其他模块的话)  </span></span><br><span class="line"><span class="comment">// define(id?, dependencies?, factory);  </span></span><br><span class="line">define(<span class="string">&#x27;myModule&#x27;</span>, [<span class="string">&#x27;jquery&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $ 是 jquery 模块的输出</span></span><br><span class="line">  $(<span class="string">&#x27;body&#x27;</span>).text(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用，等模块加载完时，会进行回调</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;myModule&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myModule</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>AMD的规范中，如果要依赖其他模块则必须先等待其他模块加载完，才会进行回调</p><span id="cmd-seajs"></span><h2 id="CMD-seaJS"><a href="#CMD-seaJS" class="headerlink" title="CMD-seaJS"></a>CMD-seaJS</h2><p>客户端-浏览器专用的包管理CMD为通用模块定义Common Module Definition，是国内阿里团队发展出来的，区别于AMD不同之处就是尽可能的懒加载其他模块比较著名的实现着： seaJS</p><p>使用方式如下  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块  myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>); <span class="comment">// 同步</span></span><br><span class="line">  $(<span class="string">&#x27;div&#x27;</span>).addClass(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 也可以写成异步加载</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&#x27;jquery.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;div&#x27;</span>).addClass(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&#x27;myModule.js&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>CMD兼容AMD的语法所以大体使用上大差不大，只不过CMD推崇的是as lazy as possible</p><span id="es6-module"></span><h2 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6-Module"></a>ES6-Module</h2><p>在ES6之前，JavaScript中并没有在语言标准中提供模块定义规范，而在非语言层面，开源社区制定了模块定义规范，主要有CommonJS和AMD以及CMD，而这些模块的引入还不能做到静态化的引入，什么意思呢？比如需要引入某个模块当中的其中一个方法，那么就得需要加载完该模块后才能引入其中的方法， 而且模块越来越多的情况下，ecma规范也应该统一这种局面了  </p><p>在ES6中，定义了import和export两个关键字语法  </p><ul><li>export<br>关键字定义导出对象，这个关键字可以无限次使用</li><li>import<br>关键字引入导入对象，这个关键字可导入任意数量的模块</li></ul><p>模块结构可以做静态分析。这使得在编译时就能确定模块的依赖关系，以及输入和输出的变量每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取import 是静态执行，所以无关写在哪个位置，为了可读性，规范写在文件开头  </p><p>具体使用如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;My name is&quot;</span> + myName + <span class="string">&quot;! I&#x27;m &#x27;&quot;</span> + myAge + <span class="string">&quot;years old.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">&quot;yeah!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// import use.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> mmmyName, myfn, myClass &#125; <span class="keyword">from</span> <span class="string">&quot;./test.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myfn());<span class="comment">// 输出： My name is Tom! I&#x27;m 20 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(mmmyName);<span class="comment">// 自定义导入的别名</span></span><br><span class="line"><span class="built_in">console</span>.log(myClass.a );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure><p>export default 命令该命令只能在一个文件(模块)中，使用一次  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxx.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 仅有一个</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span>; <span class="comment">// 使用任意变量接收</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 123</span></span><br></pre></td></tr></table></figure><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>由于es6语法的横空出世，有些浏览器还没有普及，为了广泛的兼容做适配，webpack又出现了  </p><blockquote><p>德国人Tobias，一个写java不写web页面的程序员，2013年3月10号，发明了当代 web 开发的基石<br>灵感来自于Google当时的项目GWT(Google Web Toolkit)把java转换成javascript的项目，GWT里面有个feature叫 code splitting(就是webpack的主要特性)</p><blockquote><p>Code Splitting 是什么以及为什么<br>在以前，为了减少 HTTP 请求，通常地，我们都会把所有的代码都打包成一个单独的 JS 文件。但是，如果这个 JS 文件体积很大的话，那就得不偿失了<br>这时，我们不妨把所有代码分成一块一块，需要某块代码的时候再去加载它；还可以利用浏览器的缓存，下次用到它的话，直接从缓存中读取。很显然，这种做法可以加快我们网页的加载速度，美滋滋！<br>所以说，Code Splitting 其实就是把代码分成很多很多块（ chunk ）咯  </p></blockquote><p>于是，他给当时用nodeJs做前端的项目库modules-webmake(同commonjs的规范)提了一个<a href="https://github.com/medikoo/modules-webmake/issues/7">issue</a><br>但是由于没有采用，于是他自己fork了一份modules-webmake代码，起名叫webpack，便开始了新框架的研发<br>具体诞生细节可看<a href="https://zhuanlan.zhihu.com/p/71640308">知乎文章</a>  </p></blockquote><p>webpack做的事情很多，不仅仅适配代码，还可以节省资源压缩代码，解析项目中的扩展语言如less,sass，输出浏览器可以识别的语言以及压缩图片文字等。。。<br>总计webpack就是一系列的前端代码构建工具，webpack基于nodeJs  </p><hr><h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><p>作为服务端语言，主要的要求是性能高，延迟低，尤其是io方面的，因为服务端主要面向的是提供服务，避免不了流量的冲击，而面向高性能服务端的开发，需要对内核、io、多路复用、select、pull、epoll等技术肯定要了如指掌</p><p>在2009年，Ryan Dahl(<strong>瑞安·达尔</strong>)用C++工作时，发现这些技术组合搞起来简直麻烦的要死，于是在想办法提高工作效率的驱动下，开发出了nodeJs，但是为什么nodeJs和javaScript语法那么的像呢？  </p><p>因为本身就不是一个从0到1的过程，本身就是想解决io高性能方面的问题，如果要设计一门语言，不仅有投入成本、学习成本、就连推广成本也无法估量，所以Ryan Dahl想，有没有是单线程的、用的比较广的、学习成本低的语言呢，改造起来又不是特别大，扩展性比较高的语言呢？  </p><p>JavaScript是单线程模型，浏览器发起的ajax又是非阻塞的，这就导致了js的io只能是异步，而其他语言有同步io，大家写同步io习惯了改异步io又懒得改，所以<strong>瑞安·达尔</strong>这时候和javaScript就不谋而合了，打算把他改造为一个异步非阻塞的io的服务端语言  </p><p>这样会前端js的程序员稍微加以学习NodeJs，就是名副其实的全栈程序员了  </p><blockquote><p>NPM（node package manage）实践了CommonJS的包规范---全球最大的模块仓库<br>因为nodeJs的npm包管理的出现，开源的、第三方的、框架等都聚集到了一块，规范了代码的生产<br>前端框架形形色色、琳琅满目，因为node和js语法大差不差，所以前端开发者都会用到npm包管理，使其前端大规模协作开发成为可能<br>你也可以去npm官方注册一个账号并发布自己的代码，供大家使用  </p></blockquote><hr><p>nodeJs主要帮助开发着在无需关系io、内核等方面的技术问题时，能简单的开发出一套高性能io的代码。减少开发者工作量的同时，大大提高服务端的性能  </p><p>他的原理主要就是用回调+函数式的编程(事件驱动)构成便捷的异步的io，提供便捷的同时也带来了回调地狱的痛点(debug时很头疼)  </p><blockquote><p>nodejs = io.js，io是2014年由于内部分叉，所独立出来的项目，后期内部和解又合并到一起了</p></blockquote><p><a href="/posts/%E5%AD%A6%E4%B9%A0nodejs">具体可参考nodeJs学习</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浏览器背景&quot;&gt;&lt;a href=&quot;#浏览器背景&quot; class=&quot;headerlink&quot; title=&quot;浏览器背景&quot;&gt;&lt;/a&gt;浏览器背景&lt;/h1&gt;&lt;p&gt;浏览器的历程
&lt;img src=&quot;/img/posts/2022/browserHistory.svg&quot; alt=&quot;</summary>
      
    
    
    
    <category term="脚本语言" scheme="https://dongmaxiang.vercel.app/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="nodejs" scheme="https://dongmaxiang.vercel.app/tags/nodejs/"/>
    
    <category term="js" scheme="https://dongmaxiang.vercel.app/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客原理与实战</title>
    <link href="https://dongmaxiang.vercel.app/posts/hexo%E5%8D%9A%E5%AE%A2%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>https://dongmaxiang.vercel.app/posts/hexo%E5%8D%9A%E5%AE%A2%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/</id>
    <published>2022-03-17T10:43:21.000Z</published>
    <updated>2022-03-17T10:43:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>hexo 是基于<a href="/posts/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0js%E5%88%B0nodejs#nodejs">nodejs</a></p><p>通过执行<code>node hexo s</code>就会生成可访问的静态文件，那么他的原理是什么呢？</p><blockquote><p>本博客是基于hexo框架，主题<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a>构建完成的</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;hexo 是基于&lt;a href=&quot;/posts/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0j</summary>
      
    
    
    
    <category term="博客" scheme="https://dongmaxiang.vercel.app/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://dongmaxiang.vercel.app/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>java安全点safePoint以及JIT</title>
    <link href="https://dongmaxiang.vercel.app/posts/java%E5%AE%89%E5%85%A8%E7%82%B9safepoint%E4%BB%A5%E5%8F%8Ajit/"/>
    <id>https://dongmaxiang.vercel.app/posts/java%E5%AE%89%E5%85%A8%E7%82%B9safepoint%E4%BB%A5%E5%8F%8Ajit/</id>
    <published>2021-10-20T05:05:46.000Z</published>
    <updated>2021-10-20T05:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<span id="什么是jit"></span><h1 id="什么是JIT"><a href="#什么是JIT" class="headerlink" title="什么是JIT"></a>什么是JIT</h1><p>Just In Time(即时编译)<br>一般程序遵循90-10原则，即运行时的90%时间里计算机是在处理其中10%的代码,java也是，jvm频繁的解释字节码也挺累的，因为还要翻译成机器码，所以JIT的宗旨就是在运行过程当中找出热点代码并编译成二进制的机器语言(深度优化)，这样就能很好的提高java的执行效率  </p><blockquote><p>假如Java的某个方法有1M次调用，通过jit优化此方法之后前后差100个指令，那么1M次调用，你就节省了0.1G个指令(1GHZ=10^3MHZ=10^6KHZ=10^9HZ)<br>假设cpu处理频率为2.5GHz,优化后变为2.6GHz，相当于提升了4%的性能。如果优化的更多或者调用次数更多则性能提升的空间越大</p></blockquote><h2 id="一般都会优化哪些内容？"><a href="#一般都会优化哪些内容？" class="headerlink" title="一般都会优化哪些内容？"></a>一般都会优化哪些内容？</h2><ol><li><p>死代码删除<br>如下代码，变量i是无任何意义的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法内联<br>jit中非常重要的一环将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段<br>大白话就是a调用b，为了减少入栈、出栈，直接把b的代码编译在a中</p></li><li><p>逃逸分析<br>在栈中new的对象是否出栈之后就再无引用，那么就可以在栈上分配，出栈即刻销毁<br>锁消除--编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除，比上面栈上分配的技术难度更大一些(基于逃逸分析的锁消除实际上并不多见)</p></li><li><p>循环展开<br>循环展开通过减少或消除控制程序循环的指令，争取在一次循环就把所有任务做完  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">     System.out.println(i);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     System.out.println(<span class="number">1</span>);</span><br><span class="line">     System.out.println(<span class="number">2</span>);</span><br><span class="line">     System.out.println(<span class="number">3</span>);</span><br><span class="line">     System.out.println(<span class="number">4</span>);</span><br><span class="line">     System.out.println(<span class="number">5</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>窥孔优化与寄存器分配<br><code>y1=x1*3</code>  经过优化后得到  <code>y1=(x1&lt;&lt;1)+x1</code><br>寄存器分配指的是把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度</p></li></ol><h2 id="优化引擎"><a href="#优化引擎" class="headerlink" title="优化引擎"></a>优化引擎</h2><p>hotspot jvm 内置了两个jit编译器，分别是client compiler（C1编译器）和server compiler（C2编译器）  </p><ul><li>c1=-client<br>方法内联、死代码删除</li><li>c2=-server<br>几乎会执行所有经典的优化工作，如：无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序、Java语言紧密相关的优化技术(范围检查消除、空值检查消除)、分支频率预测等  </li></ul><p>Graal VM比c2编译优化的还更高级，具体可以参考其他资料 </p><hr><span id="safepoint"></span><h1 id="safePoint"><a href="#safePoint" class="headerlink" title="safePoint"></a>safePoint</h1><p>GC的时候会暂停JVM所有的线程，此时jvm状态为STW(stop the world)。那么和安全点有什么关系呢？<br>安全点的主要作用就是代表当前的线程可以安全的暂停，恢复之后还可以正常执行<br>如果没有在安全点暂停的话，GC回收垃圾时，对象的实际地址会有变动，如果不在安全点暂停，那么持有的对象的地址可能因此而错乱，所以必须要在安全点暂停<br>安全点是由各个线程主动中断的(自己说了算)，主动中断是设置一个中断标志，各个线程运行到SafePoint的时候主动轮询这个标志，一旦发现中断标志为 True，就会在自己最近的“安全点”上主动中断挂起  </p><hr><h2 id="安全点都有哪些呢？"><a href="#安全点都有哪些呢？" class="headerlink" title="安全点都有哪些呢？"></a>安全点都有哪些呢？</h2><p>不同JVM安全点的位置也不同，安全点放置过多也会性能，JIT编译的代码里会在所有方法的</p><ol><li>临返回之前  </li><li>所有非counted loop的循环的回跳之前放置安全点  <blockquote><p>counted loop意思是for循环数字且有明确的数量(边界)，使用启动参数-XX:+UseCountedLoopSafepoints，可以在CountedLoop回跳之前放置安全点  </p></blockquote></li></ol><p>安全点位置的选取基本上是以“超长时间执行的特征”为标准进行选定的“长时间执行”的最明显特征就是指令序列的复用(包含一系列的指令)，例如<br>3. 方法调用<br>4. 循环跳转<br>5. 异常跳转  </p><p>所有能够修改JVM执行状态的JNI函数在入口处都有安全点检查，如果中断标志为 True，则会进入安全点并阻塞等待<br>其余正在执行的JNI函数可以在安全点上运行，因为它们只使用句柄，但在返回之前会主动检查安全点状态，如果中断标志为 True，则会进入安全点并阻塞等待    </p><blockquote><p>在SafePoint上不代表被阻塞（比如：JNI方法就可以在SafePoint上运行），但是被阻塞一定发生在SafePoint上</p></blockquote><hr><h2 id="什么时候会用到安全点？"><a href="#什么时候会用到安全点？" class="headerlink" title="什么时候会用到安全点？"></a>什么时候会用到安全点？</h2><ol><li>GC时需要全局安全点，需要注意，如果有一个线程没有进入到安全点时(安全区的线程除外)，GC无法展开工作，导致停顿时间延长  <blockquote><p>能够确保在某一段代码片段之中，引用关系不会发生变化称之为安全区<br>在执行到安全区域里面的代码时，首先会标识自己在安全区(比如Sleep或Blocked的线程)，GC时会忽略此线程，离开安全区之前必须要接收到JVM可以离开的信号，比如GC未完成则不允许离开安全区  </p></blockquote></li><li>jit逆优化(<a href="/posts/java-agent#agent%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0">重新修改方法体redefineClass</a>)  </li><li><a href="/posts/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Cgc%E4%BB%A5%E5%8F%8A%E9%94%81#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">偏向锁升级为轻量级锁时</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;什么是jit&quot;&gt;&lt;/span&gt;&lt;h1 id=&quot;什么是JIT&quot;&gt;&lt;a href=&quot;#什么是JIT&quot; class=&quot;headerlink&quot; title=&quot;什么是JIT&quot;&gt;&lt;/a&gt;什么是JIT&lt;/h1&gt;&lt;p&gt;Just In Time(即时编译)&lt;br&gt;一般程序遵循9</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="jvm" scheme="https://dongmaxiang.vercel.app/categories/java/jvm/"/>
    
    
    <category term="jvm" scheme="https://dongmaxiang.vercel.app/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java内存模型和GC以及锁</title>
    <link href="https://dongmaxiang.vercel.app/posts/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Cgc%E4%BB%A5%E5%8F%8A%E9%94%81/"/>
    <id>https://dongmaxiang.vercel.app/posts/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Cgc%E4%BB%A5%E5%8F%8A%E9%94%81/</id>
    <published>2021-10-13T01:43:40.000Z</published>
    <updated>2021-10-13T01:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>让我们带着问题一探究竟<br>一个Object对象占用几个字节，里面内容都是什么(对象占用大小)？在哪里分布呢(内存模型)？什么时候会销毁(GC)？  </p><blockquote><p>klass是java中，类的元信息在jvm中的表现形式，就是在c++中，类的元信息是通过klass来表示的</p></blockquote><h1 id="对象占用大小"><a href="#对象占用大小" class="headerlink" title="对象占用大小"></a>对象占用大小</h1><p><code>new Object();</code>会占用多少内存呢？答案是16字节=128比特位=128bits  </p><h2 id="为什么是16字节呢？而不是17或者15？"><a href="#为什么是16字节呢？而不是17或者15？" class="headerlink" title="为什么是16字节呢？而不是17或者15？"></a>为什么是16字节呢？而不是17或者15？</h2><p>  这是因为8个字节=1byte,所以只能是8的倍数，那么是8，要么是16、24、32<br>  那为什么是16，而不是24、32？因为这得取决于里面的内容是什么  </p><h2 id="里面内容是什么呢？"><a href="#里面内容是什么呢？" class="headerlink" title="里面内容是什么呢？"></a>里面内容是什么呢？</h2><p>对象头和数据体两大部分  </p><h3 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1. 对象头"></a>1. 对象头</h3><ol><li>前面8个字节为markword，记录对象被上锁的各种状态或者垃圾回收和hashcode相关的信息<br>默认无锁的情况如下，有锁的情况参考<a href="#synchronized">java锁</a>  </li></ol><ul><li>64位系统中(64bit)<br>未使用：25位<br>hashcode:  31位存储对象的System.identityHashCode()，采用延迟加载技术<br>未使用：1位<br>gc分带年龄: 4位<br>偏向锁的标记：1位<br>当前对象的锁的状态：2位<br>25+31+1+4+1+2=64  </li><li>32位系统中(也是有64bit,只不过java只用32bit)<br>hashcode:  25位存储对象的System.identityHashCode()，采用延迟加载技术<br>gc分带年龄: 4位<br>偏向锁的标记：1位<br>当前对象的锁的状态：2位<br>25+4+1+2 = 32  </li></ul><ol start="2"><li><p>接下来4个字节(也有可能是8个字节)是Klass Point(类型指针)<br>为什么有可能是4有可能是8呢，取决于是否开启了<a href="/posts/jvm%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3#4--xxusecompressedclasspointers">classPointer指针压缩</a><br>虚拟机通过这个指针来确定这个对象是哪个类的实例 一个对象里面的数据都是紧挨着的，因为是紧挨着，无法区分数据断点在哪里，所以必须有class对象的指针，通过对象起始地址和字段的偏移地址(从class获取)读取字段的数据  </p></li><li><p>如果是数组类型的话对象头还得再加4个或8个字节(<a href="/posts/jvm%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3#3--xxusecompressedoops">取决于是否开启压缩指针</a>)表示数组的长度<br>只有当本对象是一个数组对象时才会有这个部分</p></li></ol><h3 id="2-对象数据体"><a href="#2-对象数据体" class="headerlink" title="2. 对象数据体"></a>2. 对象数据体</h3><p>对象的里面的数据<br>如果是基本类型则是对应的值占用的空间，如果是引用类型那么大小有可能是8bit或者4bit<a href="/posts/jvm%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3#3--xxusecompressedoops">取决于是否开启压缩指针</a>  </p><h3 id="3-对齐填充数据-可选"><a href="#3-对齐填充数据-可选" class="headerlink" title="3. 对齐填充数据(可选)"></a>3. 对齐填充数据(可选)</h3><p><a href="/posts/jvm%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3#5--xxobjectalignmentinbytes8">根据对象对齐空间进行对齐，默认为8bit</a><br>因为必须是8的倍数，不是8的倍数剩下的将要补齐  </p><p>所以一个<code>new Object()</code>为16字节，8字节为对象头，后面8字节为class对象的指针和数据填充<br>1G内存大约可以存1024 * 1024 * 1024 / 16 = 67108864(约等于6千7百万多个对象)  </p><hr><h1 id="java锁"><a href="#java锁" class="headerlink" title="java锁"></a>java锁</h1><ul><li><p>java都有哪些锁呢？  </p><ol><li><p>是否阻塞<br>悲观(阻塞其他线程-synchronized)、乐观(不阻塞其他线程-ReentrantLock和ReentrantReadWriteLock)</p></li><li><p>是否公平<br>非公平(synchronized)、公平(ReentrantLock和ReentrantReadWriteLock)</p></li><li><p>二次是否能获取<br>不可重入锁(jdk没有自带的)、可重入锁(jdk自带的锁都可以重入)  </p></li><li><p>是否共享<br>共享锁(ReentrantReadWriteLock)、排他锁</p></li></ol></li><li><p>大体分为synchronized、ReentrantLock和ReentrantReadWriteLock3个阵营  </p></li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul><li>特性：阻塞、非公平、可重入、排他锁  </li><li>原理<br>jdk1.6引入了偏向锁和轻量级锁，1.6之前都是重量级锁，意思就是互斥等待都需要内核态完成（操作系统），开销非常的大，所以优化之后的synchronized可以进行锁升级<br>每一个Java对象就有一把看不见的锁，存放在对象头中叫markword，占用8个字节(动态的内容)<br>当创建一个对象时，会通过Klass的prototype_header来初始化该对象的markword，prototype_header包含了lock(锁标识-适用于所有的实例)、epoch(偏向时间戳-用来控制锁是否失效的版本号)<br><a href="#1-%E5%AF%B9%E8%B1%A1%E5%A4%B4">无锁的情况下里面存放默认的数据</a><br>偏向锁、轻量级锁、重量级锁都是根据markword里面的数据来标识当前锁的状态(所以markword里面的内容都是动态的)，一个对象锁升级之后不可回退<br>在32位jvm中占用空间如下所示(4*8=32bit)<br><img src="/img/posts/2021/markword.png" alt="如图"><br>在64位中占用(8*8=64bit)如下所示  <pre><code>|------------------------------------------------------------------------------|--------------------|  |                                  Mark Word (64 bits)                         |       State        |  |------------------------------------------------------------------------------|--------------------|  | unused:25 |  identity_hashcode:31  |unused:1|  age:4  |biased_lock:1| lock:2 |       Normal       |  |------------------------------------------------------------------------------|--------------------|  |       threadId:54      |  epoch:2  |unused:1|  age:4  |biased_lock:1| lock:2 |       Biased       |  |------------------------------------------------------------------------------|--------------------|  |                       ptr_to_lock_record:62                         | lock:2 | Lightweight Locked |  |------------------------------------------------------------------------------|--------------------|  |                     ptr_to_heavyweight_monitor:62                   | lock:2 | Heavyweight Locked |  |------------------------------------------------------------------------------|--------------------|  |                                                                     | lock:2 |    Marked for GC   |  |------------------------------------------------------------------------------|--------------------|  </code></pre>无锁、偏向锁、轻量级锁、重量级锁、gc标记，这5种状态都是通过锁标志位(lock)来判断的，但是2bit只能表示4种状态，如上图<br>所以无锁和偏向锁的锁标志位都为01，然后在通过额外的1bit(biased_lock)用来区分当前对象是否为偏向锁<br>只有匿名偏向时(lock=01,biased_lock=1,threadId=null)才可以使用偏向锁,否则从轻量级锁开始  <h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3>  锁标志位为lock=01，偏向锁标识为biased_lock=0<br>  对于无锁状态的锁对象，如果有竞争，会直接进入到轻量级锁，所以如果没有关闭偏向锁那么JVM在启动4秒之后(<a href="/posts/jvm%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3#-xxbiasedlockingstartupdelay4000">-XX:BiasedLockingStartupDelay=4000</a>)，会将所有加载的Klass的prototype_header修改为匿名偏向锁  <blockquote><p>为什么要延迟之后修改呢？<br>JVM启动时必不可免会有大量sync的操作，而偏向锁竞争时会STW并升级为轻量级锁，锁升级不可回退。如果开启了偏向锁，会发生大量锁撤销和锁升级操作，大大降低JVM启动效率  </p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3>  因为偏向锁会占用hashcode空间，如果该对象已被产生hashcode则不能使用偏向锁，如果在偏向时产生hashcode,那么会升级为轻量级锁   <blockquote><p>JVM默认的计算identity hash code的方式得到的是一个随机数，<a href="/posts/jvm%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%9A%84hashcode">如果不想为随机数可参考</a>, 因而我们必须要保证一个对象的identity hash code只能被底层JVM计算一次<br>Identity hash code是未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值  </p></blockquote>  只有匿名偏向时才可以使用偏向锁<br>  匿名偏向：锁标志位为lock=01，偏向锁标识为biased_lock=1, 且threadId为空(未偏向任何线程)，代表当前为匿名偏向<br>  markword里面有54(64位jvm)或者23(32位jvm)bit表示偏向锁偏向的线程id，未偏向时此值为空，上锁时依赖一次CAS原子指令，设置对应的线程的id，默认情况下已上锁的threadId不会自动释放(减少CAS指令的调用)，如果上锁失败或已偏向其他线程，则会进行重偏或竞争升级为轻量级锁<br>  epoch的作用是记录偏向锁的版本号，用来判断偏向锁是否失效(实例的epoch != klass的epoch)，epoch默认是有效的，如果失效可以重偏，什么时候会失效呢？参考<a href="/posts/jvm%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3#-xxbiasedlockingbulkrebiasthreshold20">-XX:BiasedLockingBulkRebiasThreshold=20</a>  <blockquote><p>偏向锁上锁大致过程为：<br>在匿名偏向状态才可以上锁，CAS设置threadId成功代表上锁成功，失败则会进行锁升级为轻量级锁<br>如果epoch失效，则会重偏(非重偏的逻辑只要有竞争就会升级为轻量级锁)，CAS设置threadId和epoch最新值，失败则会进行锁升级<br>每次上锁或者重入时只需要检查epoch和threadId是否有效即可，并且会在当前的栈侦添加一条锁记录LockRecord(记录被锁对象的地址和被锁对象的markword)，用来计算重入的次数(偏向锁LockRecord的MarkWord为空,称之为Displaced MarkWord)，执行完同步代码块之后会销毁LockRecord   </p><blockquote><p>偏向锁锁升级为轻量级锁的大致流程为:<br>其他线程请求锁,以被锁对象和新线程作为参数构造一个VM_Operation vo，新线程被挂起，在<a href="/posts/java%E5%AE%89%E5%85%A8%E7%82%B9safepoint%E4%BB%A5%E5%8F%8Ajit#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%A8%E5%88%B0%E5%AE%89%E5%85%A8%E7%82%B9">全局安全点(STW)时</a>，VM_Thread去执行vo<br>vo内部逻辑是去检查持有偏向锁的线程状态，如果对应线程已经销毁则或者对应线程执行的代码在同步块之外(通过遍历持有锁的线程的栈，判断是否有指向被锁对象的lockRecord)，则设置对象为无锁状态(无锁上锁会升级为轻量级锁)，如果还在同步块之内则把当前偏向锁升级为轻量级锁，然后让新线程以轻量级锁的状态去竞争<br>至此偏向锁流程解析完毕</p></blockquote></blockquote><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3>  锁标志位为lock=00<br>  偏向锁失效(超过-XX:BiasedLockingBulkRevokeThreshold=40默认的次数)或偏向锁竞争时，就会使用轻量级锁</li></ul><hr><span id="reentrantlock"></span><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>特性：非阻塞和阻塞、非公平和公平、可重入、排他锁</p><span id="reentrantreadwritelock"></span><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>特性：非阻塞和阻塞、非公平和公平、可重入、共享锁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;让我们带着问题一探究竟&lt;br&gt;一个Object对象占用几个字节，里面内容都是什么(对象占用大小)？在哪里分布呢(内存模型)？什么时候会销毁(GC)？  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;klass是java中，类的元信息在jvm中的表现形式，就是在c++中，类的元信</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="jvm" scheme="https://dongmaxiang.vercel.app/categories/java/jvm/"/>
    
    
    <category term="jvm" scheme="https://dongmaxiang.vercel.app/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvmClassLoader过程及原理</title>
    <link href="https://dongmaxiang.vercel.app/posts/jvmclassloader%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <id>https://dongmaxiang.vercel.app/posts/jvmclassloader%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-12T04:52:31.000Z</published>
    <updated>2021-10-12T04:52:31.000Z</updated>
    
    <content type="html"><![CDATA[<span id="classloader加载class过程"></span><h1 id="classLoader加载class过程"><a href="#classLoader加载class过程" class="headerlink" title="classLoader加载class过程"></a>classLoader加载class过程</h1><p>都是通过classLoader加载的class，如果已经加载过则不可以再次加载，但是可以通过不同的classLoader加载同一个class</p><h2 id="都有哪些类加载器呢"><a href="#都有哪些类加载器呢" class="headerlink" title="都有哪些类加载器呢"></a>都有哪些类加载器呢</h2><ol><li>引导类加载器=BootstrapClassloader<br>是使用C++语言实现的，负责加载JVM虚拟机运行时所需的基本系统级别的类，如java.lang.String, java.lang.Object等等<br>由于是C++实现的所以通过Object.class.getClassLoader() == null,无法访问</li><li>扩展类加载器=ExtClassLoader<br>是由Bootstrap加载的此类<br>此类加载器默认加载JAVA_HOME/jre/lib/ext/目录下的所有jar包，当然也可以加载由java.ext.dirs系统属性指定的jar包,用来加载java的扩展库，用户也可以直接使用此类加载器</li><li>应用类加载器=AppClassLoader<br>是由AppClassLoader加载的此类<br>此类加载器默认加载用户编写的class</li></ol><h2 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2><p>意思是多个亲戚，将加载class的任务委任给多个亲戚。以上三个类加载是都是有对应的加载关系的。如果加载某个class时，他会把任务交给上层处理，上层处理不了在交给上层处理，直到上层加载不了，然后在自己加载。<br>为什么这样设计呢？比如说String.class，在运行时就已经加载了，我们能重新覆盖吗？并不能，双亲委派机制就是要保证class正常只加载一次<br><font color='red'>上层加载的class不能引用下层加载的class</font></p><span id="urlclassloader"></span><h2 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h2><p>扩展类加载器ExtClassLoader和应用类加载器AppClassLoader，都继承<code>URLClassLoader</code>，在加载class时根据所在的路径读取class内容加载的。<br>如果我们从新写一个String.class，包名和jdk的String一模一样，是加载不了的。因为上层的classLoader已经加载过了。<br>如果自己写一个没有加载过的class，同时依赖的第三方包中也有这个class，那么可以加载自己写的吗，答案是：和启动时的classPath参数有关</p><p>AppClassLoader初始化的代码  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">   ... </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// 获取classPath</span></span><br><span class="line">      <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">      <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">      <span class="keyword">return</span> (ClassLoader) AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">         <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">            <span class="comment">// 转换成URL数组，注意当加载class的时候会从此URL寻找，是通过遍历的方式，如果classPath参数中的class靠前，那么就能加载咱们自己写的。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="class加载过程"><a href="#class加载过程" class="headerlink" title="class加载过程"></a>class加载过程</h1><h2 id="1-加载class"><a href="#1-加载class" class="headerlink" title="1 加载class"></a>1 加载class</h2><p>读取class的二进制字节流,默认通过<code>URLClassLoader#findClass</code>读取内容  </p><h2 id="2-连接class"><a href="#2-连接class" class="headerlink" title="2 连接class"></a>2 连接class</h2><p>此步骤由C++实现</p><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>   验证JVM是否支持对应的字节码语法  </p><h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>静态变量分配内存空间，并将其赋予默认值（0，false，null等）<br>如：<code>static int num = 50;</code>则此步骤为变量num分配空间，并赋值为0<br>如：<code>static Object obj = 1;</code>则此步骤为变量obj分配空间，并赋值为null<br>分配内存空间，到底要分配多少呢？详情请看<a href="/posts/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Cgc%E4%BB%A5%E5%8F%8A%E9%94%81">java内存模型和GC</a><br>如下代码，你猜会输出几？答案是0(默认值)，为什么呢？  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> Test t = <span class="keyword">new</span> Test();</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> eight = <span class="number">8</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> num = eight;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(Test.t.num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么输出是0，而不是8？看完初始化你就明白了</p><h3 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h3><p>将类中的符号引用转换为直接引用<br>编译的class字节码都是符号引用，符号的意思就是占位符，因为在实际运行当中要知道明确的地址才能调用<br>所以在这个解析的阶段，如果有引用其他的class就会加载其他的class到内存中，然后才能得到对应的内存地址<br>知道内存地址意味着可以直接调用（也就是直接引用）  </p><h2 id="3-初始化class"><a href="#3-初始化class" class="headerlink" title="3 初始化class"></a>3 初始化class</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;class A initialize &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        A() &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A constructor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A static after new B(), f_o_12:&quot;</span> + B.f_o_12);</span><br><span class="line">            System.out.println(<span class="string">&quot;A static after new B(), b.num:&quot;</span> + b.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;class B initialize &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> psf_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> f_2 = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// ---------------------------</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object f_o_12 = <span class="number">12</span>;</span><br><span class="line">        <span class="comment">// ---------------------------</span></span><br><span class="line">        <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> num_constant = <span class="number">999999999</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> num = num_constant;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B  static after new B(), f_o_12:&quot;</span> + B.f_o_12);</span><br><span class="line">        &#125;</span><br><span class="line">        B() &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B constructor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(B.psf_1);</span><br><span class="line">        System.out.println(B.f_2);</span><br><span class="line">        System.out.println(B.f_o_12);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行main方法，如果不看答案的话你能准确的说出他的输出内容及顺序吗？<br>即使你看过网上一大堆的初始化文章之后，98%的人都答不对,先透露一下总共输出12个，最后几个输出的是<br>第11个输出: B  static after new B(), f_o_12:12<br>第12输出: 12</p><select><option>点我查看答案</option><option>1. 1 </option><option>2. 2 </option><option>3. class A initialize </option><option>4. A constructor </option><option>5. B constructor </option><option>6. A static after new B(), f_o_12:null </option><option>7. A static after new B(), b.num:0 </option><option>8. class B initialize </option><option>9. A constructor </option><option>10. B constructor </option><option>11. B  static after new B(), f_o_12:12 </option><option>12. 12 </option></select><h3 id="总结初始化顺序"><a href="#总结初始化顺序" class="headerlink" title="总结初始化顺序"></a>总结初始化顺序</h3><ol><li>优先级最高的：如果是<font color='red'>static final 修饰的Java 基本类型</font>则不会初始化class，可以直接访问，称之为常量  </li><li>如果是访问static的变量或者是new对象，优先初始化顶级父类的 static 修饰的静态字段或静态块，按照声明的顺序初始化，然后是子类，依次到当前的class<br>如果static声明的字段或者方法块引用到其他的class，则会初始化其对应的class，如果已经或正在初始化，可以直接使用<br>注意：<a href="#22-%E5%87%86%E5%A4%87"><font color='red'>如果正在初始化，则class的内容只做了准备的阶段，所以class里面的属性都是null或者都是默认值</font></a>  </li><li>如果是创建对象的实例，则上面的静态块初始化完毕之后，在初始化代码块（从顶级的父类开始，按照声明的顺序，然后是子类，依次到当前的class），最后是构造方法初始化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;classloader加载class过程&quot;&gt;&lt;/span&gt;&lt;h1 id=&quot;classLoader加载class过程&quot;&gt;&lt;a href=&quot;#classLoader加载class过程&quot; class=&quot;headerlink&quot; title=&quot;classLoader加载</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="jvm" scheme="https://dongmaxiang.vercel.app/categories/java/jvm/"/>
    
    
    <category term="jvm" scheme="https://dongmaxiang.vercel.app/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>定义swagger通用接口文档</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E5%AE%9A%E4%B9%89swagger%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E5%AE%9A%E4%B9%89swagger%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</id>
    <published>2021-10-10T22:34:54.000Z</published>
    <updated>2021-10-10T22:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们用的swagger版本为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spring4all<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.swagger<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-models<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>由于swagger的分组在配置文件中不支持中文，所以我们给他改成中文<br>yml配置swagger文档的分组不支持中文作为key，所以我给该他改成中文，这样对前端提示友好些 </li><li>由于我们<a href="/posts/mvc%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E5%8C%85%E8%A3%85">统一了http最外层的响应包装</a>，swagger是检测不出来的，所以我们要给他加上最外层的响应包装<br>Result为http外层的响应包装</li><li>由于我们<a href="/posts/mvc%E6%9E%9A%E4%B8%BE%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%85%8D%E7%BD%AE">统一了枚举</a>，swagger也是检测不出来的，所以我们要给他加上枚举的注释以及对应的value</li></ol><p>代码如下  </p><p><code>@ConditionalOnExpression(&quot;#&#123;!T(com.wuyi.mkt.common.emnus.ENV).isProd()&#125;&quot;)</code><a href="/posts/%E8%8E%B7%E5%8F%96spring%E5%90%AF%E5%8A%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB">非正式环境下才生效</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableSwagger2Doc</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@MyConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@EnableSwaggerBootstrapUI</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression(&quot;#&#123;!T(com.wuyi.mkt.common.emnus.ENV).isProd()&#125;&quot;)</span><span class="comment">// 非正式环境下才生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfiguration</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationReadyEvent</span>&gt;, <span class="title">BeanPostProcessor</span>, <span class="title">ExpandedParameterBuilderPlugin</span>, <span class="title">ParameterBuilderPlugin</span>, <span class="title">ModelPropertyBuilderPlugin</span>, <span class="title">OperationBuilderPlugin</span>, <span class="title">OperationModelsProviderPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServerProperties serverProperties;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TypeNameExtractor typeNameExtractor;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TypeResolver resolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> </span>&#123;</span><br><span class="line">        String ipAddress = IpUtils.getLocalHostInfo().getIpAddress();</span><br><span class="line">        Integer port = serverProperties.getPort();</span><br><span class="line">        String contextPath = serverProperties.getServlet().getContextPath();</span><br><span class="line">        log.info(<span class="string">&quot;接口文档地址:&#123;&#125;&quot;</span>, String.format(<span class="string">&quot;http://%s:%s%s/doc.html&quot;</span>, ipAddress, port, ObjectUtils.defaultIfNull(contextPath, <span class="string">&quot;&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// docket分组名使用中文的title</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> SwaggerProperties) &#123;</span><br><span class="line">            Map&lt;String, SwaggerProperties.DocketInfo&gt; newDocket = Maps.newHashMap();</span><br><span class="line">            ((SwaggerProperties) bean).getDocket().forEach((k, v) -&gt; newDocket.put(v.getTitle(), v));</span><br><span class="line">            ((SwaggerProperties) bean).setDocket(newDocket);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(DocumentationType delimiter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非Model的参数</span></span><br><span class="line"><span class="comment">     * 实体里面的字段如果是枚举则增加文档</span></span><br><span class="line"><span class="comment">     * 比如枚举作为实体中的成员，而实体则直接写在方法上作为参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ParameterExpansionContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ParameterBuilder parameterBuilder = context.getParameterBuilder();</span><br><span class="line">            parameterBuilder.required(<span class="keyword">false</span>);</span><br><span class="line">            Class&lt;?&gt; erasedType = context.getFieldType().getErasedType();</span><br><span class="line">            addDocForEnum(parameterBuilder, erasedType, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (erasedType.isArray()) &#123;</span><br><span class="line">                addDocForEnum(parameterBuilder, erasedType.getComponentType(), <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (List.class.isAssignableFrom(erasedType)) &#123;</span><br><span class="line">                TypeBindings typeBindings = context.getFieldType().getTypeBindings();</span><br><span class="line">                erasedType = typeBindings.getTypeParameters().get(<span class="number">0</span>).getErasedType();</span><br><span class="line">                addDocForEnum(parameterBuilder, erasedType, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;ParameterExpansionContext apply&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非Model的参数如果是枚举则增加文档</span></span><br><span class="line"><span class="comment">     * 比如枚举作为参数直接写在方法上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ParameterContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ParameterBuilder parameterBuilder = context.parameterBuilder();</span><br><span class="line">            parameterBuilder.required(<span class="keyword">false</span>);</span><br><span class="line">            Class&lt;?&gt; erasedType = context.resolvedMethodParameter().getParameterType().getErasedType();</span><br><span class="line">            addDocForEnum(parameterBuilder, erasedType, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (erasedType.isArray()) &#123;</span><br><span class="line">                addDocForEnum(parameterBuilder, erasedType.getComponentType(), <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (List.class.isAssignableFrom(erasedType)) &#123;</span><br><span class="line">                TypeBindings typeBindings = context.resolvedMethodParameter().getParameterType().getTypeBindings();</span><br><span class="line">                erasedType = typeBindings.getTypeParameters().get(<span class="number">0</span>).getErasedType();</span><br><span class="line">                addDocForEnum(parameterBuilder, erasedType, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;ParameterContext apply&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给一个model内的EnumProperty增加文档</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ModelPropertyContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ModelPropertyBuilder builder = context.getBuilder();</span><br><span class="line">            builder.required(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; fieldType = context.getBeanPropertyDefinition()</span><br><span class="line">                    .transform(BeanPropertyDefinition::getRawPrimaryType)</span><br><span class="line">                    .orNull();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fieldType == <span class="keyword">null</span> || !fieldType.isEnum()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了复用代码先这样搞，毕竟就是个文档</span></span><br><span class="line">            addDocForEnum(<span class="keyword">new</span> ParameterBuilder() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">final</span> String description = (String) FieldUtils.readDeclaredField(builder, <span class="string">&quot;description&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">final</span> String name = (String) FieldUtils.readDeclaredField(builder, <span class="string">&quot;name&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ParameterBuilder <span class="title">description</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">                    builder.description(description);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ParameterBuilder <span class="title">allowableValues</span><span class="params">(AllowableValues allowableValues)</span> </span>&#123;</span><br><span class="line">                    builder.allowableValues(allowableValues);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, fieldType, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;ModelPropertyContext apply&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给当前的param增加文档，如果是枚举的话</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> DeserializableEnum</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDocForEnum</span><span class="params">(ParameterBuilder parameterBuilder, Class&lt;?&gt; erasedType, <span class="keyword">boolean</span> coverageModel)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        DeserializableEnum deserializableEnum = DeserializableEnum.getDeserializableEnumAndIdentityClass(erasedType)</span><br><span class="line">                .map(Map.Entry::getKey)</span><br><span class="line">                .orElse(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (deserializableEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举</span></span><br><span class="line">        Object[] enumConstants = erasedType.getEnumConstants();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有枚举的可用值</span></span><br><span class="line">        List&lt;String&gt; values = Arrays.stream(enumConstants)</span><br><span class="line">                .map(Enum.class::cast)</span><br><span class="line">                .map(deserializableEnum::getIdentity)</span><br><span class="line">                .flatMap(identity -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (identity <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Stream.of((Object[]) identity);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> Stream.of(identity);</span><br><span class="line">                &#125;).map(String::valueOf)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 默认值：</span></span><br><span class="line"><span class="comment">         * 让前端在调试的时候可以不选，或者选择一个错误的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        values.add(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        values.add(<span class="string">&quot;这是个错误的值&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 可用值描述：</span></span><br><span class="line"><span class="comment">         * 枚举的doc和identity，拼成字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String description = Arrays.stream(enumConstants)</span><br><span class="line">                .map(Enum.class::cast)</span><br><span class="line">                .map(t -&gt; &#123;</span><br><span class="line">                    Object identity = deserializableEnum.getIdentity(t);</span><br><span class="line">                    <span class="keyword">if</span> (!(identity <span class="keyword">instanceof</span> Object[])) &#123;</span><br><span class="line">                        identity = ObjectUtils.array(identity);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> Arrays.toString((Object[]) identity) + <span class="string">&quot;=&quot;</span> + deserializableEnum.getDocFunction.apply(t);</span><br><span class="line">                &#125;).collect(Collectors.joining(<span class="string">&quot;;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果没有description，则取ApiModel的注解</span></span><br><span class="line"><span class="comment">         * 当做前缀，拼接可用值描述</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String oldDescription = (String) FieldUtils.readDeclaredField(parameterBuilder, <span class="string">&quot;description&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        String name = (String) FieldUtils.readDeclaredField(parameterBuilder, <span class="string">&quot;name&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(oldDescription) &amp;&amp; !oldDescription.equals(name)) &#123;</span><br><span class="line">            oldDescription += <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oldDescription = Optional.ofNullable(AnnotationUtils.findAnnotation(erasedType, ApiModel.class))</span><br><span class="line">                    .map(ApiModel::value)</span><br><span class="line">                    .map(t -&gt; t + <span class="string">&quot;:&quot;</span>)</span><br><span class="line">                    .orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parameterBuilder.description(oldDescription + description)</span><br><span class="line">                .allowableValues(<span class="keyword">new</span> AllowableListValues(values, <span class="string">&quot;LIST&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (coverageModel) &#123;</span><br><span class="line">            parameterBuilder.modelRef(<span class="keyword">new</span> ModelRef(<span class="string">&quot;List&quot;</span>, <span class="keyword">new</span> AllowableListValues(values, <span class="string">&quot;LIST&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加响应包装的model，为了能够和responseMessages映射</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> SwaggerConfiguration#apply(springfox.documentation.spi.service.contexts.OperationContext)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestMappingContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Result.class.equals(context.getReturnType().getErasedType())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ResolvedType returnType = resolver.resolve(Result.class, context.alternateFor(context.getReturnType()));</span><br><span class="line">        context.operationModelsBuilder().addReturn(returnType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于配置了spring的bodyAdvice，swagger是检测不出来最外层的包装。</span></span><br><span class="line"><span class="comment">     * 所以此配置增加最外层响应的包装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(OperationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Result.class.equals(context.getReturnType().getErasedType())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ResolvedType returnType = resolver.resolve(Result.class, context.alternateFor(context.getReturnType()));</span><br><span class="line"></span><br><span class="line">        ModelContext modelContext = ModelContext.returnValue(</span><br><span class="line">                context.getGroupName(),</span><br><span class="line">                returnType,</span><br><span class="line">                context.getDocumentationType(),</span><br><span class="line">                context.getAlternateTypeProvider(),</span><br><span class="line">                context.getGenericsNamingStrategy(),</span><br><span class="line">                context.getIgnorableParameterTypes());</span><br><span class="line"></span><br><span class="line">        ResponseMessage built = <span class="keyword">new</span> ResponseMessageBuilder()</span><br><span class="line">                .code(ResponseMessagesReader.httpStatusCode(context))</span><br><span class="line">                .message(ResponseMessagesReader.message(context))</span><br><span class="line">                .responseModel(modelRefFactory(modelContext, typeNameExtractor).apply(returnType))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        context.operationBuilder().responseMessages(newHashSet(built));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们用的swagger版本为&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="swagger" scheme="https://dongmaxiang.vercel.app/categories/java/swagger/"/>
    
    
    <category term="swagger" scheme="https://dongmaxiang.vercel.app/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>java-agent</title>
    <link href="https://dongmaxiang.vercel.app/posts/java-agent/"/>
    <id>https://dongmaxiang.vercel.app/posts/java-agent/</id>
    <published>2021-10-10T01:43:40.000Z</published>
    <updated>2021-10-10T01:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>什么是java-agent、作用是什么、怎么用、原理是什么?<br>java-agent可以理解为是一个代理程序，非主程序，代理程序可以做的事情就很多了，取决于你想写什么逻辑<br>比如说<a href="https://arthas.aliyun.com/doc/">Alibaba开源的Java诊断工具</a><br>也可以动态的替换字节码，实现代码热更新的效果  </li></ul><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过java-agent程序我们可以获取到<code>Instrumentation</code>实例，得到此实例之后可以干的事情就很多了，比如说aop字节码增强，或者重新定义class等  </p><blockquote><p>具体原理可参考<br>1：<a href="https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html">美团的技术分享-agent原理</a><br>2：<a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团的技术分享-字节码增强原理</a></p></blockquote><ol><li><p>agent程序可以在主程序启动之前启动，做你想做的操作,需要编写逻辑代码并封装成Jar包，并在jvm 启动命令添加 -[javaagent|agentlib]:agentJar包的路径，jdk1.5之后才可以<br>jar包中的class方法signature必须为 <code>public static void premain(String agentArgs, Instrumentation inst)</code></p></li><li><p>也可以在主程序运行过程中启动，通过jdk自带的方法<code>VirtualMachine#attach.loadAgent(&quot;你封装的agentJar包路径&quot;)</code>，jdk1.6之后才可以<br>jar包中的class方法signature必须为 <code>public static void agentmain(String agentArgs, Instrumentation inst)</code></p></li></ol><p>Instrumentation简称JVMTI（JVM Tool Interface）  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加class转换器，在class加载的时候可以修改class字节码</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="keyword">boolean</span> canRetransform)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRetransformClassesSupported</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRedefineClassesSupported</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新定义class</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span> <span class="keyword">throws</span>  ClassNotFoundException, UnmodifiableClassException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span></span>;</span><br><span class="line"></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">    Class[] getInitiatedClasses(ClassLoader loader);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getObjectSize</span><span class="params">(Object objectToSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendToSystemClassLoaderSearch</span><span class="params">(JarFile jarfile)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNativeMethodPrefixSupported</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNativeMethodPrefix</span><span class="params">(ClassFileTransformer transformer, String prefix)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><ul><li><p>java代码  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicInstrumentationAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DynamicInstrumentationAgent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(<span class="keyword">final</span> String args, <span class="keyword">final</span> Instrumentation inst)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 拿着inst可以干很多事情，比如说替换字节码等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(<span class="keyword">final</span> String args, <span class="keyword">final</span> Instrumentation inst)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        premain(args, inst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MANIFEST.MF  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: DynamicInstrumentationAgent</span><br><span class="line">Agent-Class: DynamicInstrumentationAgent</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>打成jar包<br>把java代码和MANIFEST.MF打成jar包，并把MANIFEST.MF放在META-INF目录下即可</p></li></ul><hr><h1 id="agent实现热更新"><a href="#agent实现热更新" class="headerlink" title="agent实现热更新"></a>agent实现热更新</h1><ul><li>获取到<code>Instrumentation</code>实例之后调用<code>redefineClasses(ClassDefinition definition)</code>重新定义class字节码实现热更新<br>如果新的class转换错误，则此方法将引发异常，且不会重新转换任何类<br>redefineClasses只能修改方法体，并且替换时会等待safePoint，STW，JIT逆优化等如果修改的方法有活动的堆栈帧，那么这些活动的帧将继续运行原方法的字节码。修改后的方法将用于新的调用<br>热更新底层原理可<a href="https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html">参考其他文章-美团的技术分享-agent原理</a>  <blockquote><p>ClassDefinition包含了老的class和新的class字节码</p></blockquote></li></ul><p>不是说class一旦加载之后就不能修改吗？为什么agent却可以啊<br>原来是部分不能修改，不能增删改字段成员和方法的signature，只能修改方法体的内容<br>如果觉得只能修改方法体太局限  </p><ol><li><a href="/posts/%E8%A7%A3%E5%86%B3springremoterestart%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8#%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8">可以参考快速集成springRemoteRestart</a>  </li><li><a href="https://www.cnblogs.com/zyl2016/p/13666945.html">其他热部署利器</a>  </li></ol><blockquote><p>为什么只能修改方法体呢？<br>比如说如果对Class增加/修改/删除field，由于class加载后，对象实例化后，就会在heap上占据一片（连续）区域<br>动态修改区域，不可避免会遇到冲突（比如下一片区域已经被分配了）<br>所以这种方法目前只能支持修改方法体</p></blockquote><span id="在运行时获取到instrumentation实例"></span><h1 id="在运行时获取到Instrumentation实例"><a href="#在运行时获取到Instrumentation实例" class="headerlink" title="在运行时获取到Instrumentation实例"></a>在运行时获取到<code>Instrumentation</code>实例</h1><p>配置第三方jar包<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.invesdwin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>invesdwin-instrument<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>de.invesdwin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://invesdwin.de/repo/invesdwin-oss-remote/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用方式如下<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DynamicInstrumentationLoader.waitForInitialized();</span><br><span class="line">Instrumentation instrumentation = InstrumentationSavingAgent.getInstrumentation();</span><br></pre></td></tr></table></figure></p><p>原理就是通过<code>VirtualMachine#attach</code>方法attach自己，然后把instrumentation变为自己的静态变量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是java-agent、作用是什么、怎么用、原理是什么?&lt;br&gt;java-agent可以理解为是一个代理程序，非主程序，代理</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="jvm" scheme="https://dongmaxiang.vercel.app/categories/java/jvm/"/>
    
    
    <category term="jvm" scheme="https://dongmaxiang.vercel.app/tags/jvm/"/>
    
    <category term="热部署" scheme="https://dongmaxiang.vercel.app/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>解决springRemoteRestart不起作用</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E8%A7%A3%E5%86%B3springremoterestart%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E8%A7%A3%E5%86%B3springremoterestart%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</id>
    <published>2021-10-10T01:43:40.000Z</published>
    <updated>2021-10-10T01:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>springDevTools提供了热部署的工具，按照网上的教程本地可以完美的支持热部署，但是一用到remoteRestart远程热部署就失效，热部署失败，抛ClassCastException异常<br>为了解决这个问题，咱们今天分析一下他的原理，为什么本地修改的可以热部署，远程remoteRestart就会失效(热部署时为什么会报异常)<br>技术栈：springBoot + MVC + DUBBO + NACOS + maven打包插件spring-boot-maven-plugin  </p><h1 id="热部署原理分析"><a href="#热部署原理分析" class="headerlink" title="热部署原理分析"></a>热部署原理分析</h1><p>当我们修改class时，springDevTools利用了不同的classLoader重新加载class，并重新启动spring，使其生效<br>优点就是已经加载过的class并不会重新加载以便节省性能，只针对动态修改的class重新加载即可</p><blockquote><p>已加载的class无法在线卸载，只能用新的classLoader去加载，这样就起到了热部署的效果<br>旧的classLoader以及对应加载过的class会被GC回收  </p></blockquote><ol><li>在<a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">springBoot启动的时候，监听启动时的事件</a>，然后用自己的热部署classLoader去重新启动spring（通过反射再次调用main）  </li><li><a href="/posts/jvmclassloader%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86">自己classLoader并没有遵循双亲委派机制</a>，而且优先用最新的class  </li><li>最新的class是由spring实时监听class文件的变化，如果有修改则会上传到最新的class中，并让devTools重新启动spring<br>如果要达到热部署的目的，必须能把老的class卸载，所以必须是老的classLoader加载的这些类才行，这样当老的classLoader回收时所对应老的class也会一并销毁<br>如果采用双亲委派机制由JDK加载的话那就无法卸载</li><li>在重新启动的过程中如果有最新的class就用，没有就遵循双亲委派去加载class，以此达到热部署的目的  </li></ol><h2 id="分析本地热部署"><a href="#分析本地热部署" class="headerlink" title="分析本地热部署"></a>分析本地热部署</h2><p>引入devTools的jar包，直接启动即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy(false)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// 如果没有配置，只要引入了jar包，默认就是开启的状态</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.devtools.restart&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RestartConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restart配置文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DevToolsProperties properties;</span><br><span class="line"></span><br><span class="line">    RestartConfiguration(DevToolsProperties properties) &#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听文件变动的工厂</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">FileSystemWatcherFactory <span class="title">fileSystemWatcherFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>::newFileSystemWatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> FileSystemWatcher <span class="title">newFileSystemWatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 监听文件变动的实现</span></span><br><span class="line">        Restart restartProperties = <span class="keyword">this</span>.properties.getRestart();</span><br><span class="line">        FileSystemWatcher watcher = <span class="keyword">new</span> FileSystemWatcher(<span class="keyword">true</span>, restartProperties.getPollInterval(), restartProperties.getQuietPeriod());</span><br><span class="line">        String triggerFile = restartProperties.getTriggerFile();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(triggerFile)) &#123;</span><br><span class="line">            watcher.setTriggerFilter(<span class="keyword">new</span> TriggerFileFilter(triggerFile));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;File&gt; additionalPaths = restartProperties.getAdditionalPaths();</span><br><span class="line">        <span class="keyword">for</span> (File path : additionalPaths) &#123;</span><br><span class="line">            watcher.addSourceDirectory(path.getAbsoluteFile());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> watcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此实例可以监听到文件变动的事件，当事件来临时重启服务，达到热部署的效果</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ApplicationListener&lt;ClassPathChangedEvent&gt; <span class="title">restartingClassPathChangedEventListener</span><span class="params">(FileSystemWatcherFactory fileSystemWatcherFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (event) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.isRestartRequired()) &#123;</span><br><span class="line">                <span class="comment">//Restarter实例，在spring启动的时候已经初始化了</span></span><br><span class="line">                Restarter.getInstance().restart(<span class="keyword">new</span> FileWatchingFailureHandler(fileSystemWatcherFactory));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取监听文件变动的工厂，从工厂获取监听文件变化的实例，注册到beanFactory之后，监听文件的实例开始工作，文件有变化，则以事件的方式广播出去，不关心具体实现</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function">ClassPathFileSystemWatcher <span class="title">classPathFileSystemWatcher</span><span class="params">(FileSystemWatcherFactory fileSystemWatcherFactory, ClassPathRestartStrategy classPathRestartStrategy)</span> </span>&#123;</span><br><span class="line">        URL[] urls = Restarter.getInstance().getInitialUrls();</span><br><span class="line">        ClassPathFileSystemWatcher watcher = <span class="keyword">new</span> ClassPathFileSystemWatcher(fileSystemWatcherFactory, classPathRestartStrategy, urls);</span><br><span class="line">        watcher.setStopWatcherOnRestart(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> watcher;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析远程热部署"><a href="#分析远程热部署" class="headerlink" title="分析远程热部署"></a>分析远程热部署</h2><ol><li><p>用springBoot打包需要maven打包时包含devTools  </p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件中必须要配置secret<br>spring.devtools.remote.secret=mysecret</p></li><li><p>启动远端服务器</p></li><li><p>启动本地代码，并把远端服务器的地址配置即可使用<br>指定Main Class为org.springframework.boot.devtools.RemoteSpringApplication<br>指定Program arguments为<a href="http://127.0.0.1:8081/">http://127.0.0.1:8081</a> 即远端服务的地址</p></li></ol><ul><li><p>server端(remote)代码原理解析  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// 如果没有配置，只要引入了jar包，默认就是开启的状态</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.devtools.remote.restart&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteRestartConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 筛选需要用restartClassLoader加载的class</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function">SourceDirectoryUrlFilter <span class="title">remoteRestartSourceDirectoryUrlFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSourceDirectoryUrlFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理http的请求，接收参数，调用Restarter重启服务</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function">HttpRestartServer <span class="title">remoteRestartHttpRestartServer</span><span class="params">(SourceDirectoryUrlFilter sourceDirectoryUrlFilter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpRestartServer(sourceDirectoryUrlFilter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置http地址的映射，相当于配置一个servlet,暴露一个接口，这样client通过此接口和server进行交互</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;remoteRestartHandlerMapper&quot;)</span></span><br><span class="line">    <span class="function">UrlHandlerMapper <span class="title">remoteRestartHandlerMapper</span><span class="params">(HttpRestartServer server, ServerProperties serverProperties, DevToolsProperties properties)</span> </span>&#123;</span><br><span class="line">        Servlet servlet = serverProperties.getServlet();</span><br><span class="line">        String servletContextPath = (servlet.getContextPath() != <span class="keyword">null</span>) ? servlet.getContextPath() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        String url = servletContextPath + properties.getRemote().getContextPath() + <span class="string">&quot;/restart&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UrlHandlerMapper(url, <span class="keyword">new</span> HttpRestartServerHandler(server));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>client端代码原理解析<br>client负责监听文件的变化，然后上传到服务端，服务端接收到文件之后会用新的classLoader重新加载class达到热部署的目的<br>同<a href="#%E5%88%86%E6%9E%90%E6%9C%AC%E5%9C%B0%E7%83%AD%E9%83%A8%E7%BD%B2">分析本地热部署</a>原理一样，因为文件变化会有事件通知，只不过此监听器是用来和remoteServer的http接口打交道的，会把修改后的class字节码上传到服务端  </p></li></ul><span id="restartclassloader只加载部分class的源码"></span><h2 id="restartClassLoader只加载部分class的源码"><a href="#restartClassLoader只加载部分class的源码" class="headerlink" title="restartClassLoader只加载部分class的源码"></a>restartClassLoader只加载部分class的源码</h2><p>devTools的热部署classLoader只会加载部分的class，其余的class归JDK加载，JDK加载的class无法实现热部署，那么他是如何只加载部分的class呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeableUrls</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">URL</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该参数是JDK的classLoader对应的URLS(也就是所有的class路径)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ChangeableUrls</span><span class="params">(URL... urls)</span> </span>&#123;</span><br><span class="line">        DevToolsSettings settings = DevToolsSettings.get();</span><br><span class="line">        List&lt;URL&gt; reloadableUrls = <span class="keyword">new</span> ArrayList&lt;&gt;(urls.length);</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((settings.isRestartInclude(url) || isDirectoryUrl(url.toString())) &amp;&amp; !settings.isRestartExclude(url)) &#123;</span><br><span class="line">                reloadableUrls.add(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.urls = Collections.unmodifiableList(reloadableUrls);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也就是说restart本地启动的时候(非remoteRestart)，只会加载自己项目的class，因为自己项目的class在Idea中就是以文件的方式存在</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDirectoryUrl</span><span class="params">(String urlString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> urlString.startsWith(<span class="string">&quot;file:&quot;</span>) &amp;&amp; urlString.endsWith(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;URL&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.urls.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="解决远程热部署不生效的问题"><a href="#解决远程热部署不生效的问题" class="headerlink" title="解决远程热部署不生效的问题"></a>解决远程热部署不生效的问题</h1><p>我们已经知道了他的原理是用不同的classLoader去加载最新的class，只有老的classLoader加载的class才能卸载，这样新的class才会重新加载热部署才会生效<br>根据网上的教程配置好remote远程热部署之后发现修改class上传部署启动时就会报ClassNotFondException或者会报ClassCastException</p><ul><li><p>ClassNotFondException<br>配置热部署检测文件改动的时间间隔就行<br>因为class编译后会重新覆盖，覆盖过程中会先把老的文件给删除，因为有时间差，所以spring误以为是删除而不是更新，这样导致重新启动的时候spring就找不到class了。  </p><blockquote><p>那为什么本地的就不会有这个问题，或者有这个问题之后不一会就好了呢？<br>因为remote是通过http协议传输新class的。在重新启动的过程中http会停止服务，一旦启动不起来就无法和cline交互了，也就永远起不来了<br>而本地没有通过http，它是在本地内存中直接执行热部署的代码逻辑，所以即使启动失败了也没关系，不一会他能检测到新文件的到来并且会触发事件重新启动，这样就不会报ClassNotFondException异常了  </p></blockquote><p>但是因为时间差的原因，还会有几率出现这样的问题，那么只能从源码中下手改代码了，或者用triggerFile触发更新也可以</p></li><li><p>ClassCastException<br>  原来是maven打包插件spring-boot-maven-plugin惹的祸，通过此插件会把我们的项目打包成jar包。<a href="#restartclassloader%E5%8F%AA%E5%8A%A0%E8%BD%BD%E9%83%A8%E5%88%86class%E7%9A%84%E6%BA%90%E7%A0%81">这样spring无法识别是file文件</a>，class就被JDK的classLoader加载了<br>  当新的classLoader加载修改过的class时，由于没有采用双亲委派机制，导致父子classLoader都会加载这个class，但是会优先用子classLoader加载的class，导致class在连接的时候出现了ClassCastException异常  </p><blockquote><p>解决办法是在devTools的classLoader加载class的时候，把我们的jar包给指定上就可以了  </p></blockquote></li></ul><span id="remoterestart-classcastexception异常解决"></span><h2 id="remoteRestart-ClassCastException异常解决"><a href="#remoteRestart-ClassCastException异常解决" class="headerlink" title="remoteRestart-ClassCastException异常解决"></a>remoteRestart-ClassCastException异常解决</h2><ol><li>项目编译时设置特定的标识<br>maven配置如下插件，在打包后的MANIFEST.MF中添加自定义的属性    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">reload</span>&gt;</span>true<span class="tag">&lt;/<span class="name">reload</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>编写代码，覆盖spring的<code>getInitialUrls</code>，指定返回要热加载的jar包  </li></ol><p>注意通过编写一模一样的包名，放在自己的项目中，当启动的时候会优先用自己编写的，为什么会优先用自己编写的呢？<a href="/posts/jvmclassloader%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86">这个和classPath有关</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.devtools.restart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.devtools.logger.DevToolsLogFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.devtools.system.DevToolsEnablementDeducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.JarURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写获取URL的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> anyOne</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/8/15 1:49 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRestartInitializer</span> <span class="keyword">implements</span> <span class="title">RestartInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> URL[] getInitialUrls(Thread thread) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!thread.getName().equals(<span class="string">&quot;main&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!DevToolsEnablementDeducer.shouldEnable(thread)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Collection&lt;URL&gt; urls = getUrls(thread);</span><br><span class="line">        DevToolsLogFactory.getLog(DefaultRestartInitializer.class).info(<span class="string">&quot;reload urls:&quot;</span> + urls);</span><br><span class="line">        <span class="keyword">return</span> urls.toArray(<span class="keyword">new</span> URL[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;URL&gt; <span class="title">getUrls</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;URL&gt; urls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        urls.addAll(ChangeableUrls.fromClassLoader(thread.getContextClassLoader()).toList());</span><br><span class="line">        <span class="comment">// dubbo 销毁后无法重新注册，所以有关dubbo的class也一并加载</span></span><br><span class="line">        <span class="comment">// nacos也一样，存有静态变量影响会重新启动 &#123;@see com.alibaba.nacos.spring.core.env.NacosPropertySourcePostProcessor.beanFactory&#125;</span></span><br><span class="line">        urls.addAll(Arrays.stream(((URLClassLoader) thread.getContextClassLoader()).getURLs())</span><br><span class="line">                .filter(t -&gt;</span><br><span class="line">                        t.getPath().contains(<span class="string">&quot;dubbo&quot;</span>)</span><br><span class="line">                                || t.getPath().contains(<span class="string">&quot;nacos-spring-context&quot;</span>)</span><br><span class="line">                                || t.getPath().contains(<span class="string">&quot;nacos-config-spring-boot-autoconfigure&quot;</span>)</span><br><span class="line">                ).collect(Collectors.toSet()));</span><br><span class="line"></span><br><span class="line">        urls.addAll(Arrays.stream(((URLClassLoader) thread.getContextClassLoader()).getURLs())</span><br><span class="line">                .filter(t -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        JarURLConnection urlConnection = (JarURLConnection) t.openConnection();</span><br><span class="line">                        <span class="comment">// 判断是自己的项目则返回</span></span><br><span class="line">                        <span class="keyword">return</span> Boolean.parseBoolean(urlConnection.getMainAttributes().getValue(<span class="string">&quot;reload&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).collect(Collectors.toSet()));</span><br><span class="line">        <span class="keyword">return</span> urls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置好之后，restartClassLoader会加载这些class，不然父的classLoader加载的class无法卸载。也就无法实现热部署的效果了</p><hr><h1 id="优化热部署-减少部署时间"><a href="#优化热部署-减少部署时间" class="headerlink" title="优化热部署-减少部署时间"></a>优化热部署-减少部署时间</h1><p>优先用<a href="/posts/java-agent#agent%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0">agent替换字节码的方式实现热部署</a>，秒级生效（如果不违反规范，且可以生效的话）<br>如果失败，则还跟之前是有的方式一模一样，需要注意的是，需要修改restart文件才会重启（类似triggerFile触发重启，可以避免ClassNotFondException）  </p><blockquote><p>使用方式不变，跟springDevToolsRestart一模一样，修改后文件后编译即可，不一样的是服务端做了手脚，增加一层优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(HttpRestartServer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevToolsReloadConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpRestartServer <span class="title">remoteRestartHttpRestartServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpRestartServer(getRestartServer(<span class="keyword">new</span> DefaultSourceDirectoryUrlFilter()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写restartServer</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RestartServer <span class="title">getRestartServer</span><span class="params">(SourceDirectoryUrlFilter sourceDirectoryUrlFilter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestartServer(sourceDirectoryUrlFilter) &#123;</span><br><span class="line">            <span class="keyword">final</span> ClassLoaderFiles newFile = <span class="keyword">new</span> ClassLoaderFiles();</span><br><span class="line">            Set&lt;String&gt; waitingRestartFileNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 重载方法，接收新的class，优先用agent方式热更新，速度非常快</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">restart</span><span class="params">(Set&lt;URL&gt; urls, ClassLoaderFiles newFiles)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (ClassLoaderFiles.SourceDirectory sourceDirectory : newFiles.getSourceDirectories()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;String, ClassLoaderFile&gt; fileEntry : sourceDirectory.getFilesEntrySet()) &#123;</span><br><span class="line">                        newFile.addFile(sourceDirectory.getName(), fileEntry.getKey(), fileEntry.getValue());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (fileEntry.getKey().endsWith(<span class="string">&quot;.class&quot;</span>) &amp;&amp; fileEntry.getValue().getKind() != ClassLoaderFile.Kind.DELETED) &#123;</span><br><span class="line">                                <span class="comment">// 第三方开源的jar包，使当前的jvm能够获取到 JVMTI Instrumentation 实例</span></span><br><span class="line">                                DynamicInstrumentationLoader.waitForInitialized();</span><br><span class="line"></span><br><span class="line">                                String className = fileEntry.getKey()</span><br><span class="line">                                        .replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">                                        .replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                                Class&lt;?&gt; oldClass = ClassUtils.forName(className, resourceLoader.getClassLoader());</span><br><span class="line"></span><br><span class="line">                                ClassDefinition classDefinition = <span class="keyword">new</span> ClassDefinition(oldClass, fileEntry.getValue().getContents());</span><br><span class="line">                                <span class="comment">// 重新定义</span></span><br><span class="line">                                InstrumentationSavingAgent.getInstrumentation().redefineClasses(classDefinition);</span><br><span class="line">                                <span class="comment">// 替换成功则移除，</span></span><br><span class="line">                                waitingRestartFileNames.remove(fileEntry.getKey());</span><br><span class="line">                                log.info(<span class="string">&quot;class reload:&#123;&#125;&quot;</span>, fileEntry.getKey());</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                            <span class="comment">// 替换失败，只能通过热部署重启的方式啦。</span></span><br><span class="line">                            log.info(fileEntry.getKey() + <span class="string">&quot;reload failure，Modify the restart file for the restart to take effect:&quot;</span> + e.getClass().getName() + <span class="string">&quot;:&quot;</span> + e.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                        waitingRestartFileNames.add(fileEntry.getKey());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 指定的restart文件有变动则重启，相当于restart中的triggerFile。</span></span><br><span class="line">                <span class="keyword">if</span> (waitingRestartFileNames.isEmpty() || !waitingRestartFileNames.contains(<span class="string">&quot;restart&quot;</span>)) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;waitingRestartFileNames is empty or no restart file，waitingRestartFileNames:&#123;&#125;&quot;</span>, waitingRestartFileNames);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Restarter restarter = Restarter.getInstance();</span><br><span class="line">                <span class="comment">// 指定urls后restart类加载器会生效</span></span><br><span class="line">                restarter.addUrls(urls);</span><br><span class="line">                <span class="comment">// 新的文件</span></span><br><span class="line">                restarter.addClassLoaderFiles(newFile);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录本次更新的文件，如果启动失败，说明本次的更新文件有问题，用来删除并重新启动</span></span><br><span class="line">                Set&lt;String&gt; persistentUpdatedFileNames = <span class="keyword">new</span> HashSet&lt;&gt;(waitingRestartFileNames);</span><br><span class="line">                </span><br><span class="line">                waitingRestartFileNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                log.warn(<span class="string">&quot;spring restart new files:&#123;&#125;&quot;</span>, persistentUpdatedFileNames);</span><br><span class="line">                restarter.restart(failure -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (persistentUpdatedFileNames.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// 本次修改的文件为空，说明跟修改的文件没有关系，属于正常的启动失败</span></span><br><span class="line">                        <span class="keyword">return</span> FailureHandler.Outcome.ABORT;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果启动失败，则删除本次更新的文件，保证能正常启动，不然服务挂了，别让你这个热部署的插件 造成不好的影响</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 由于是final只能通过反射来移除新增的class文件了</span></span><br><span class="line">                        ClassLoaderFiles classLoaderFiles = (ClassLoaderFiles) FieldUtils.readDeclaredField(restarter, <span class="string">&quot;classLoaderFiles&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Map&lt;String, ClassLoaderFiles.SourceDirectory&gt; sourceDirectories = (Map&lt;String, ClassLoaderFiles.SourceDirectory&gt;) FieldUtils.readDeclaredField(classLoaderFiles, <span class="string">&quot;sourceDirectories&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;String, ClassLoaderFiles.SourceDirectory&gt; directoryEntry : sourceDirectories.entrySet()) &#123;</span><br><span class="line">                            </span><br><span class="line">                            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                            Map&lt;String, ClassLoaderFile&gt; files = (Map&lt;String, ClassLoaderFile&gt;) FieldUtils.readDeclaredField(directoryEntry.getValue(), <span class="string">&quot;files&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">                            </span><br><span class="line">                            <span class="keyword">for</span> (String name : persistentUpdatedFileNames) &#123;</span><br><span class="line">                                files.remove(name);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        log.warn(<span class="string">&quot;retry failure，Try to delete the new file and restart:&#123;&#125;&quot;</span>, persistentUpdatedFileNames);</span><br><span class="line">                        <span class="comment">// 清空</span></span><br><span class="line">                        persistentUpdatedFileNames.clear();</span><br><span class="line">                        <span class="comment">// 重新启动</span></span><br><span class="line">                        <span class="keyword">return</span> FailureHandler.Outcome.RETRY;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;springDevTools提供了热部署的工具，按照网上的教程本地可以完美的支持热部署，但是一用到remoteRestart远程热部署就失效，热部署失败，抛ClassCastException异常&lt;br&gt;为了解决这个问题，咱们今天分析一下他的原理，为什么本地修改的可以热部署</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
    <category term="热部署" scheme="https://dongmaxiang.vercel.app/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>spring事务和aop的原理</title>
    <link href="https://dongmaxiang.vercel.app/posts/spring%E4%BA%8B%E5%8A%A1%E5%92%8Caop%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://dongmaxiang.vercel.app/posts/spring%E4%BA%8B%E5%8A%A1%E5%92%8Caop%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-07T23:41:10.000Z</published>
    <updated>2021-10-07T23:41:10.000Z</updated>
    
    <content type="html"><![CDATA[<span id="aop"></span><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>springAop大体分为两种技术方式，一种是基于动态代理的，一种是基于字节码增强的  </p><ul><li>动态代理的有基于<ol><li>jdk的</li><li>基于CGLIB的</li></ol></li></ul><ul><li>字节码增强的有<ol><li>在编译时做增强的</li><li>class加载的时候做增强的</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AdviceMode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK proxy-based advice.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROXY,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AspectJ weaving-based advice.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ASPECTJ</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="基于动态代理-proxy"></span><h2 id="基于动态代理-PROXY"><a href="#基于动态代理-PROXY" class="headerlink" title="基于动态代理-PROXY"></a>基于动态代理-PROXY</h2><p><code>AbstractAutoProxyCreator</code>它是个抽象类，并且是<a href="/posts/beanpostprocessor%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0#7-postprocessafterinitialization">bean的后置处理器，在bean创建的时候拦截，并寻找合适的切入点返回对应的proxy</a><br>其中有3个实现类  </p><ol><li>InfrastructureAdvisorAutoProxyCreator<br>如果只是开启事务则会用到此实现<br>AOP生效规则：bean必须是<code>Advisor</code>类型，且role为<code>BeanDefinition.ROLE_INFRASTRUCTURE</code>才会生效  </li><li>AspectJAwareAdvisorAutoProxyCreator<br>基于xml配置方式<code>&lt;aop:config&gt;...&lt;/aop:config&gt;</code><br>AOP生效规则：只要是<code>Advisor</code>类型的bean就会生效，不关心role</li><li>AnnotationAwareAspectJAutoProxyCreator<br>继承上面那个类<br>AOP生效规则：同上且支持注解表达式<code>@Aspect</code></li></ol><blockquote><p>优先级从上到下，只要注册了优先级比较高的class，低优先级的会自动失效</p></blockquote><p>不论是事务<code>@EnableTransactionManagement</code>，还是缓存<code>@EnableCaching</code>，或者自定义的AOP<code>@EnableAspectJAutoProxy</code>，只会往beanFactory注册一个<code>AbstractAutoProxyCreator</code>类型的bean<br>beanName为<code>org.springframework.aop.config.internalAutoProxyCreator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfigUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The bean name of the internally managed auto-proxy creator.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTO_PROXY_CREATOR_BEAN_NAME =</span><br><span class="line">          <span class="string">&quot;org.springframework.aop.config.internalAutoProxyCreator&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Stores the auto proxy creator classes in escalation order.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// Set up the escalation list...</span></span><br><span class="line">    APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">    APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">    APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代理class</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceAutoProxyCreatorToUseClassProxying</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">      BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;proxyTargetClass&quot;</span>, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露proxy</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceAutoProxyCreatorToExposeProxy</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">      BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;exposeProxy&quot;</span>, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往beanFactory注册拦截bean初始化的beanPostProcessor</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经注册过则不会重新注册</span></span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">      BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">      <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">        <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">        <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">        <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">          apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">    beanDefinition.setSource(source);</span><br><span class="line">    beanDefinition.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">    <span class="keyword">return</span> beanDefinition;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注册完之后会在bean实例化的拦截，寻找能够切入的点，返回对应的proxy  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="comment">// 如果没有提供过早期的引用(循环引用)，则可以进行proxy（早期的引用已经proxy了）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  过滤掉不必代理的类，</span></span><br><span class="line">        <span class="comment">//  如果是这些接口的实现Advice、Pointcut、Advisor、AopInfrastructureBean，则不会代理</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前的class寻找对应的AOP</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="comment">// 创建代理</span></span><br><span class="line">Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">            AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">                proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找可以匹配的切入器</span></span><br><span class="line">        Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">        proxyFactory.addAdvisors(advisors);</span><br><span class="line">        proxyFactory.setTargetSource(targetSource);</span><br><span class="line">        customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">        proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">        <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">            proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理，动态判断是用cglib还是jdk</span></span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="基于字节码增强"><a href="#基于字节码增强" class="headerlink" title="基于字节码增强"></a>基于字节码增强</h2><p>不同于proxy，字节码增强运行效率是比较快的，因为相当于我们手写的代码，且没有这么复杂的动态代理逻辑。更不会出现内嵌方法调用时aop不生效的情况  </p><blockquote><p>但这种技术为什么没有流行起来呢？原因有两个<br>1是需要通过运维支持在jvm 启动的时候添加 -javaagent:&#39;jarPath&#39; 命令，比较复杂(也可以通过技术手段在运行中获取到<code>Instrumentation</code>实例，不用运维配置)<br>2是配置起来复杂，需要在代码层面提前配置好切入的表达式和对应的逻辑，且要保证切入的class没有提前加载才行  </p></blockquote><ol><li><p>基于agent在class加载的时候进行动态的替换字节码<br><a href="/posts/java-agent">字节码增强</a>技术-ASPECTJ     </p></li><li><p>基于编译阶段做切入操作<br><a href="https://leon-wtf.github.io/springboot/2019/12/30/spring-aop-vs-aspectj/">具体可google搜索class编译时做字节码切入</a></p></li></ol><hr><h1 id="事务的原理"><a href="#事务的原理" class="headerlink" title="事务的原理"></a>事务的原理</h1><p>springBoot: <code>@EnableTransactionManagement</code><br>spring.xml: <code>&lt;tx:annotation-driven/&gt;</code><br>以上配置表明<code>@Transactional</code>注解即可生效，那么他的原理是什么呢？  </p><span id="基于proxy"></span><h2 id="基于PROXY"><a href="#基于PROXY" class="headerlink" title="基于PROXY"></a>基于PROXY</h2><p>  注册一个aop实例，类型为<code>Advisor</code>，判断有@Transaction注解的就会自动动态代理  </p><blockquote><p>在方法调用的时候，aop拦截方法并执行<code>TransactionAspectSupport#invokeWithinTransaction</code>，根据<code>@Transaction</code>的配置进行开始事务、隔离配置、回滚等操作</p></blockquote><ul><li><p>xml注册的代码<br><code>AnnotationDrivenBeanDefinitionParser#parse</code></p></li><li><p>注解注册的代码<br><code>TransactionManagementConfigurationSelector#selectImports</code></p></li></ul><h2 id="基于字节码增强-1"><a href="#基于字节码增强-1" class="headerlink" title="基于字节码增强"></a>基于<a href="/posts/java-agent">字节码增强</a></h2><p>字节码增强，spring兼容的不太好。因为字节码需要agent，并且需要class字节器转换器。<br>基于字节码的切入，即使不用配置事务的注解<code>@EnableTransactionManagement</code>，也会生效。<br>只要保证要切入的类在加载之前agent能正常运行且有class转换器<code>org.springframework.transaction.aspectj.AnnotationTransactionAspect</code>即可  </p><hr><h1 id="设置事务对所有的异常进行回滚"><a href="#设置事务对所有的异常进行回滚" class="headerlink" title="设置事务对所有的异常进行回滚"></a>设置事务对所有的异常进行回滚</h1><p>默认为RuntimeException和Error的类型才会事务回滚  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTransactionAttribute</span> <span class="keyword">extends</span> <span class="title">DefaultTransactionDefinition</span> <span class="keyword">implements</span> <span class="title">TransactionAttribute</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rollbackOn</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析事务的核心代码<code>TransactionAspectSupport#invokeWithinTransaction</code>(开启、回退、隔离级别等)，我们发现注解的配置由<code>TransactionAttributeSource</code>提供<br>我们只需要重写<code>TransactionAttributeSource</code>，并应用即可</p><p><font color='red'>但是要注意这种方式只支持Proxy方式的事务，如果是基于字节码那么修改源码了（字节码的切入不受spring管控）</font></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionRollbackSupport</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AbstractBeanDefinition transactionAttributeSource = (AbstractBeanDefinition) beanFactory.getBeanDefinition(<span class="string">&quot;transactionAttributeSource&quot;</span>);</span><br><span class="line">        transactionAttributeSource.setInstanceSupplier(AllRollback::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ProxyTransactionManagementConfiguration#transactionAttributeSource()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AllRollback</span> <span class="keyword">extends</span> <span class="title">AnnotationTransactionAttributeSource</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">            TransactionAttribute transactionAttribute = <span class="keyword">super</span>.computeTransactionAttribute(method, targetClass);</span><br><span class="line">            <span class="keyword">if</span> (!(transactionAttribute <span class="keyword">instanceof</span> RuleBasedTransactionAttribute)) &#123;</span><br><span class="line">                <span class="keyword">return</span> transactionAttribute;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> hasRollbackRule = ((RuleBasedTransactionAttribute) transactionAttribute).getRollbackRules()</span><br><span class="line">                    .stream()</span><br><span class="line">                    .filter(t -&gt; !(t <span class="keyword">instanceof</span> NoRollbackRuleAttribute))</span><br><span class="line">                    .anyMatch(Objects::nonNull);</span><br><span class="line">            <span class="comment">// 事务attributeRollback默认为Throwable,如果没有指定的话</span></span><br><span class="line">            <span class="keyword">if</span> (hasRollbackRule) &#123;</span><br><span class="line">                <span class="keyword">return</span> transactionAttribute;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;set Default transaction rollback exception as Throwable,class:&#123;&#125;,method:&#123;&#125;&quot;</span>, targetClass.getSimpleName(), method.getName());</span><br><span class="line">            ((RuleBasedTransactionAttribute) transactionAttribute).getRollbackRules()</span><br><span class="line">                    .add(<span class="number">0</span>, <span class="keyword">new</span> RollbackRuleAttribute(Throwable.class));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> transactionAttribute;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理，<a href="/posts/%E8%A7%A3%E6%9E%90spring%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%91beanfactory%E6%B3%A8%E5%86%8Cbean%E7%9A%84">在spring注册完所有的beanDefinition之后</a>，获取&quot;transactionAttributeSource&quot;的definition，并setInstanceSupplier，<a href="/posts/spring%E5%AF%B9bean%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%B5%81%E7%A8%8B#%E5%88%9B%E5%BB%BAbeanwrapper">这样在实例化的时候就会用自己的了</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;aop&quot;&gt;&lt;/span&gt;&lt;h1 id=&quot;AOP&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP&quot;&gt;&lt;/a&gt;AOP&lt;/h1&gt;&lt;p&gt;springAop大体分为两种技术方式，一种是基于动态代理的，一种是基于字节码增强的  </summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
    <category term="动态代理" scheme="https://dongmaxiang.vercel.app/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>java实例化的几种方式</title>
    <link href="https://dongmaxiang.vercel.app/posts/java%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://dongmaxiang.vercel.app/posts/java%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2021-10-07T18:29:55.000Z</published>
    <updated>2021-10-07T18:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>直接new<br>调用了构造</li><li>通过反射<br>调用了构造</li><li>clone<br>没有调用构造,但必须实现<code>Cloneable</code>接口，java通过native方法实现</li><li>反序列化<br>没有调用构造，通过调用<code>MethodAccessorGenerator#generateSerializationConstructor</code>生成一个新的构造对象，该构造对象不会调用构造方法  </li><li>通过Unsafe类的allocateInstance()方法<br>没有调用构造，只分配内存空间</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;直接new&lt;br&gt;调用了构造&lt;/li&gt;
&lt;li&gt;通过反射&lt;br&gt;调用了构造&lt;/li&gt;
&lt;li&gt;clone&lt;br&gt;没有调用构造,但必须实现&lt;code&gt;Cloneable&lt;/code&gt;接口，java通过native方法实现&lt;/li&gt;
&lt;li&gt;反序列化&lt;br&gt;没有调用</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="基础" scheme="https://dongmaxiang.vercel.app/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>beanPostProcessor的调用流程及各种实现</title>
    <link href="https://dongmaxiang.vercel.app/posts/beanpostprocessor%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>https://dongmaxiang.vercel.app/posts/beanpostprocessor%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-29T05:04:05.000Z</published>
    <updated>2021-09-29T05:04:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90#5-%E6%B3%A8%E5%86%8C%E6%8B%A6%E6%88%AAbean%E5%88%9B%E5%BB%BA%E7%9A%84bean%E5%A4%84%E7%90%86%E5%99%A8-beanpostprocessor">beanFactory初始化阶段会注册beanPostProcessor</a>，它的作用就是在<a href="/posts/spring%E5%AF%B9bean%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%B5%81%E7%A8%8B#%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0bean%E5%88%99%E5%88%9B%E5%BB%BA">bean实例化前、后，初始化前、后进行拦截操作</a></p><span id="beanpostprocessor为最顶层的接口"></span><h1 id="BeanPostProcessor为最顶层的接口"><a href="#BeanPostProcessor为最顶层的接口" class="headerlink" title="BeanPostProcessor为最顶层的接口"></a>BeanPostProcessor为最顶层的接口</h1><p>共有5种类型不同作用的间接接口（包含自己）如图<img src="/img/posts/2021/beanPostProcessor.png" alt="beanPostProcessor"></p><hr><span id="instantiationawarebeanpostprocessor"></span><h2 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a><strong>InstantiationAwareBeanPostProcessor</strong></h2><ul><li><p>postProcessBeforeInstantiation<br>可以拦截bean实例化之前（<code>不包含factoryBean#getObject</code>），如果返回不为空，则直接调用<code>BeanPostProcessor</code>的后置方法并直接返回，此时bean已创建完毕（很少用）</p></li><li><p>postProcessAfterInstantiation<br>返回值为Boolean类型，如果返回为false则不允许自动装配（很少用）</p></li><li><p>postProcessProperties<br>自动装配，<font color='red'>最重要的实现AutowiredAnnotationBeanPostProcessor实现自动装配</font></p></li><li><p>postProcessPropertyValues<br>如果<code>postProcessProperties</code>返回值为null，则会调用此方法  <br/>  自动装配，<font color='red'>dubbo注解方式的自动装配：ReferenceAnnotationBeanPostProcessor</font></p></li></ul><hr><span id="mergedbeandefinitionpostprocessor"></span><h2 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h2><ul><li>postProcessMergedBeanDefinition<br>在<code>postProcessBeforeInstantiation</code>之后，如果没有拦截实例化、则会通过<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90#4-beandefinitionregistry">beanDefinition</a>准备实例化<br>实例化之前可以拦截beanDefinition做一些修改，或提取一些信息<br>比如说自动装配<code>@Autowired、@Resource</code>在这个阶段提取对应的字段或方法并缓存，然后再<code>postProcessProperties</code>阶段进行自动装配操作</li></ul><hr><span id="beanpostprocessor"></span><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a><strong>BeanPostProcessor</strong></h2><ul><li><p>postProcessBeforeInitialization<br>可以替换或set对应的bean，<font color='red'>最重要的实现ApplicationContextAwareProcessor，各种Aware的处理</font></p></li><li><p>postProcessAfterInitialization<br>可以替换或set对应的bean  <br/><font color='red'>最重要的实现AbstractAutoProxyCreator实现aop拦截</font></p></li></ul><hr><span id="smartinstantiationawarebeanpostprocessor"></span><h2 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a><strong>SmartInstantiationAwareBeanPostProcessor</strong></h2><ul><li><p>getEarlyBeanReference<br/><br><font color='red'>提供早期的引用：如果是单例，并且是循环引用的情况下，最重要的实现InfrastructureAdvisorAutoProxyCreator实现事务aop拦截，且可以循环引用</font></p></li><li><p>predictBeanType<br>通过beanName获取class的时候会调用此方法，可以重写此方法，返回bean的类型（返回可以为null）</p></li><li><p>determineCandidateConstructors<br>Determine the candidate constructors to use for the given bean.(返回可以为null)</p></li></ul><hr><span id="destructionawarebeanpostprocessor"></span><h2 id="DestructionAwareBeanPostProcessor"><a href="#DestructionAwareBeanPostProcessor" class="headerlink" title="DestructionAwareBeanPostProcessor"></a>DestructionAwareBeanPostProcessor</h2><ul><li>postProcessBeforeDestruction<br>bean在销毁时会调用</li></ul><hr><h1 id="鸟瞰各个方法的调用顺序"><a href="#鸟瞰各个方法的调用顺序" class="headerlink" title="鸟瞰各个方法的调用顺序"></a>鸟瞰各个方法的调用顺序</h1><span id="1-postprocessbeforeinstantiation"></span><h2 id="1-postProcessBeforeInstantiation"><a href="#1-postProcessBeforeInstantiation" class="headerlink" title="1. postProcessBeforeInstantiation"></a>1. postProcessBeforeInstantiation</h2><blockquote><p>InstantiationAwareBeanPostProcessor  </p></blockquote><p>在bean实例化的时候调用此方法，如果返回不为空则会调用<code>postProcessAfterInitialization</code>并返回，至此后面的流程不在调用</p><span id="2-mergedbeandefinitionpostprocessor"></span><h2 id="2-MergedBeanDefinitionPostProcessor"><a href="#2-MergedBeanDefinitionPostProcessor" class="headerlink" title="2. MergedBeanDefinitionPostProcessor"></a>2. MergedBeanDefinitionPostProcessor</h2><blockquote><p>InstantiationAwareBeanPostProcessor</p></blockquote><p>如果在<code>postProcessBeforeInstantiation</code>期间没有被提前实例化，则会调用此方法</p><span id="3-getearlybeanreference"></span><h2 id="3-getEarlyBeanReference"><a href="#3-getEarlyBeanReference" class="headerlink" title="3. getEarlyBeanReference"></a>3. getEarlyBeanReference</h2><blockquote><p>SmartInstantiationAwareBeanPostProcessor</p></blockquote><p>这个方法是在单例bean创建的时候通过调用此方法，包装成回调并<a href="/posts/spring%E5%AF%B9bean%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%B5%81%E7%A8%8B#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98">放入循环引用中的三级缓存中</a>，默认实现AOP:<code>AbstractAutoProxyCreator</code></p><span id="4-postprocessafterinstantiation"></span><h2 id="4-postProcessAfterInstantiation"><a href="#4-postProcessAfterInstantiation" class="headerlink" title="4. postProcessAfterInstantiation"></a>4. postProcessAfterInstantiation</h2><blockquote><p>InstantiationAwareBeanPostProcessor</p></blockquote><p>如果此方法如果返回false，则不允许自动装配了，换句话说就不会执行第5步了如果返回true，则要自动装配<br>通过<code>beanDefinition#getResolvedAutowireMode</code>返回值，可选择的执行spring内置的<code>autowireByType</code>或者<code>autowireByName</code>  </p><blockquote><p>装配的属性必须有set方法，并且只装配在beanFactory中存在的bean，不存在的并不会报错  </p></blockquote><span id="5-postprocessproperties或postprocesspropertyvalues"></span><h2 id="5-postProcessProperties或postProcessPropertyValues"><a href="#5-postProcessProperties或postProcessPropertyValues" class="headerlink" title="5. postProcessProperties或postProcessPropertyValues"></a>5. postProcessProperties或postProcessPropertyValues</h2><blockquote><p>InstantiationAwareBeanPostProcessor</p></blockquote><p>spring实例化完bean之后调用<code>populateBean</code>进行自动装配<br>如果<code>postProcessProperties</code>返回为空，则会执行<code>postProcessPropertyValues</code><br>默认实现IOC：<code>AutowiredAnnotationBeanPostProcessor</code></p><span id="6-postprocessbeforeinitialization"></span><h2 id="6-postProcessBeforeInitialization"><a href="#6-postProcessBeforeInitialization" class="headerlink" title="6. postProcessBeforeInitialization"></a>6. postProcessBeforeInitialization</h2><blockquote><p>BeanPostProcessor</p></blockquote><p>调用此方法之前会优先调用<code>BeanNameAware,BeanClassLoaderAware,BeanFactoryAware</code>接口的bean<code>set...</code>  </p><p>此方法可以替换或set对应的bean，如各种Aware的处理进行set<code>ApplicationContextAwareProcessor</code></p><span id="7-postprocessafterinitialization"></span><h2 id="7-postProcessAfterInitialization"><a href="#7-postProcessAfterInitialization" class="headerlink" title="7. postProcessAfterInitialization"></a>7. postProcessAfterInitialization</h2><blockquote><p>BeanPostProcessor</p></blockquote><p>调用此方法前优先会调用<code>InitializingBean</code>接口的bean<code>afterPropertiesSet</code><br>可以替换或set对应的bean，如aop拦截返回代理的bean<a href="/posts/spring%E4%BA%8B%E5%8A%A1%E5%92%8Caop%E7%9A%84%E5%8E%9F%E7%90%86"><code>AbstractAutoProxyCreator</code></a></p><hr><p>postProcessBeforeDestructionbean在销毁的时候会调用，比如说当<code>spring#close</code>或者手动destroy时</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BeanPostProcessor为bean的后置处理器，共有5种不同的后置处理类型，每种后置类型有n多个方法<br>IOC<code>AutowiredAnnotationBeanPostProcessor</code>和AOP<code>AbstractAutoProxyCreator</code>都是通过后置处理完成的实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90#5-%E6%B3%A8%E5%86%8C%E6%8B%A6%E6%88%AAbean%E5%88%9B%E5%BB%BA%E7%9A</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring对bean实例化-初始化-流程</title>
    <link href="https://dongmaxiang.vercel.app/posts/spring%E5%AF%B9bean%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%B5%81%E7%A8%8B/"/>
    <id>https://dongmaxiang.vercel.app/posts/spring%E5%AF%B9bean%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%B5%81%E7%A8%8B/</id>
    <published>2021-09-21T21:57:47.000Z</published>
    <updated>2021-09-21T21:57:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>获取一个bean时<code>AbstractBeanFactory#doGetBean</code>，除非bean已经存在，否则会通过beanDefinition自动创建  </p><p>创建时，<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90#4-beandefinitionregistry">如果没有beanDefinition就会报错，所以beanDefinition是一个很重要的存在</a></p><p><strong>创建流程很复杂，必须要先了解bean的各种后置处理器<a href="/posts/beanpostprocessor%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0"><code>BeanPostProcessor</code></a></strong>  </p><p>spring获取bean时,底层是通过beanName获取的，如果是根据类型，那么他会先根据类型先获取name，然后根据name在获取bean  </p><blockquote><p>beanName可以自定义，如果非自定义默认则是classSimpleName，且第一个字母小写<br>FactoryBean类型的beanName也是同上,如果要获取FactoryBean类型的实例话，则beanName要以&quot;&amp;&quot;为前缀。否则获取的就是factoryBean对应的实际bean</p></blockquote><p>以下为获取(创建)bean的大体流程</p><hr><span id="通过class类型或注解类型获取beanname"></span><h2 id="通过class类型或注解类型获取beanName"><a href="#通过class类型或注解类型获取beanName" class="headerlink" title="通过class类型或注解类型获取beanName"></a>通过class类型或注解类型获取beanName</h2><p><strong>不管怎样，spring底层是<a href="#%E6%A0%B9%E6%8D%AEbeanname%E4%BC%98%E5%85%88%E8%8E%B7%E5%8F%96%E5%8D%95%E5%88%97%E7%9A%84bean">通过name获取对应的bean</a></strong><br>如果是根据注解获取bean，底层则会遍历所有的beanNames，通过beanNames获取到对应的class，然后然后判断class上是否有相对应的注解<br>那么咱们只需要关注如何根据beanName获取到对应class，以及如何根据class获取到对应的beanNames就行  </p><hr><span id="通过beanname获取class流程"></span><h3 id="通过beanName获取class流程"><a href="#通过beanName获取class流程" class="headerlink" title="通过beanName获取class流程"></a>通过beanName获取class流程</h3><ol><li><p>从已初始化的单例bean<code>singletonObjects</code>中获取(不允许早期初始化-非循环依赖的方式获取)，没有就返回null，有就用返回实例对应的class  </p><blockquote><p>如果是<code>FactoryBean</code>则使用<code>Factory#getObjectType</code>，否则用<code>obj.getClass()</code>直接返回</p></blockquote></li><li><p>如果上一步未满足，并且本地不包含beanDefinition，则尝试从<a href="#%E9%80%9A%E8%BF%87beanname%E8%8E%B7%E5%8F%96class%E6%B5%81%E7%A8%8B">parentBeanFactory中获取</a>，否则执行下一步  </p></li><li><p>获取beanDefinition<br>如果不包含beanDefinition则就直接报错<br>通过definition优先获取被包装的definition<code>getDecoratedDefinition</code>  </p><blockquote><p> 因为有可能目标类将要被代理，在创建beanDefinition的时候就做了手脚,比如说<code>ScopedProxyUtils#createScopedProxy</code>：bean的作用域通过代理实现  </p></blockquote></li><li><p><a href="#%E9%80%9A%E8%BF%87rootbeandefinition%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E7%9A%84class">获取beanDefinition对应的class</a><br>最后通过<a href="/posts/beanpostprocessor%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0#smartinstantiationawarebeanpostprocessor"><code>SmartInstantiationAwareBeanPostProcessor#predictBeanType</code></a>返回对应的beanType</p></li><li><p>执行factoryBean的转换<br>如果参数beanName是以&quot;&amp;&quot;为前缀，代表要获取FactoryBean类型的class，如果上一步获取到的class不是FactoryBean类型，则返回null<br>如果参数beanName不是以&quot;&amp;&quot;为前缀，代表要获取真实bean的类型，如果上一步获取到的不是FactoryBean类型，则直接返回，如果是FactoryBean类型，优先根据泛型获取对应的type，如果获取失败则要进行初始化FactoryBean,因为一会要调用<code>Factory#getObjectType</code>来返回真实的类型<br>创建流程请参考<a href="#%E5%88%9B%E5%BB%BAbeanwrapper"><code>AbstractAutowireCapableBeanFactory#createBeanInstance</code></a>(包含构造注入流程)，完事会返回一个BeanWrapper，如果factoryBean本身是单例的话则会放入缓存中<code>factoryBeanInstanceCache</code>，<a href="#%E7%BC%93%E5%AD%98%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84beanWrapper">在获取bean的时候，保证不能有二次初始化</a></p></li></ol><hr><span id="通过class获取对应的beannames流程"></span><h3 id="通过class获取对应的beanNames流程"><a href="#通过class获取对应的beanNames流程" class="headerlink" title="通过class获取对应的beanNames流程"></a>通过class获取对应的beanNames流程</h3><ol><li><p>获取所有已注册的beanDefinitionNames和手动注册的单例beanNames(手动注册的已初始化)<br>条件包含：非alias、非abstract、且是否包含非单例、是否允许早期初始化两个动态条件</p></li><li><p>依次遍历beanName</p></li><li><p>通过<a href="#%E9%80%9A%E8%BF%87beanname%E8%8E%B7%E5%8F%96class%E6%B5%81%E7%A8%8B">beanName获取class</a><br>与&#39;通过beanName获取class流程&#39;大体流程一致，但是有些许的不同，比如没有beanDefinition不会报错，如果是FactoryBean则尽量不初始化的情况下获取到对应的targetType，否则只能初始化并调用<code>getTargetType</code></p></li><li><p>判断获取到的class  </p><ul><li>如果没有获取到class则为false,代表不匹配  </li><li>获取到class之后调用<code>isInstance</code><br>  如果返回true则会把当前的beanName添加到list里面，最后一并返回<br>  如果为false，并且当前的beanName的类型为FactoryBean类型则会拼接&#39;&amp;&#39;前缀作为beanName从新判断  </li></ul></li></ol><hr><span id="根据beanname优先获取单列的bean"></span><h2 id="根据beanName优先获取单列的bean"><a href="#根据beanName优先获取单列的bean" class="headerlink" title="根据beanName优先获取单列的bean"></a>根据beanName优先获取单列的bean</h2><hr><span id="把beanname转换为为标准的beanname"></span><h3 id="把beanName转换为为标准的beanName"><a href="#把beanName转换为为标准的beanName" class="headerlink" title="把beanName转换为为标准的beanName"></a>把beanName转换为为标准的beanName</h3><ol><li>去除&quot;&amp;&quot;的前缀<br>FactoryBean他就是一个普通的bean，在注册beanDefinition时和普通的bean别无二致，只有在<a href="#factorybean%E7%9A%84%E8%BD%AC%E6%8D%A2">获取的时候会有不同</a></li><li>通过alias获取真实的Name<br>alisa其底层实现其实就是一个map，key为alias，value为实际的beanName</li></ol><p>优先获取单列，如果非单例的bean压根就获取不到，所以优先获取单列  </p><blockquote><p>也可以手动注册单例，但是一样的beanName不允许二次注册(there is already)<br>手动注册的和spring扫描的且已初始化的单列bean都是存放在同一个地方中：<code>singletonObjects</code>  </p></blockquote><hr><h3 id="单例bean的获取流程"><a href="#单例bean的获取流程" class="headerlink" title="单例bean的获取流程"></a>单例bean的获取流程</h3><ol><li><p>从<code>singletonObjects</code>优先获取单例bean(手动注册的和spring已初始化的都在同一个地方)，有则直接返回  </p></li><li><p>没有则判断当前的beanName是否为正在创建的单例bean，因为正在创建的bean可能会依赖其他的bean，而其他的bean依赖于正在创建的bean，就变成了一个循环依赖  </p><blockquote><p>spring在每创建一个单例bean之前把当前beanName存放在一个set中，标志正在创建中，创建完之后会从Set删除，并把创建的实例放入到<code>singletonObjects</code>中  </p></blockquote></li><li><p>如果当前获取的bean正在创建(循环依赖)，则会从<code>earlySingletonObjects</code>中获取  </p><blockquote><p><code>earlySingletonObjects</code>是map类型，作用是暂时存放正在创建的bean，key为beanName,value为bean的实例且是由<code>singletonFactories</code>提供的  </p></blockquote></li><li><p>如果<code>earlySingletonObjects</code>获取为空，且允许早期的引用(循环依赖)则从<a href="#%E5%8D%95%E4%BE%8B%E7%9A%84bean%E6%94%BE%E5%85%A5%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%AD"><code>singletonFactories</code></a>中获取<br><code>singletonFactories</code>由<code>SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference</code>提供早期的引用，如aop返回代理对象的引用  </p><blockquote><p>等实例创建完之后会放入到<code>singletonObjects</code>中，并从<code>earlySingletonObjects</code>和<code>singletonFactories</code>移除  </p></blockquote></li><li><p>执行factoryBean的转换</p></li></ol><p><span id='三级缓存'></span></p><blockquote><p>其实单例bean获取的时候就已经解决了循环依赖，以上的各个变量就是网上说的三级缓存，如果还不太理解可以直观的看下代码  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);<span class="comment">// 一级缓存，所有已初始化完的单例bean都在这里</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<span class="comment">// 当前bean正在创建中</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);<span class="comment">// 二级缓存，第一次访问肯定是空的，二级缓存的值由三级缓存提供</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123; <span class="comment">// 上锁</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName); <span class="comment">// 再次查看一级缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName); <span class="comment">// 再次查看二级缓存</span></span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 调用三级缓存，三级缓存是在bean创建的时候放进去的，并且value为ObjectFactory，只有在需要的时候才会初始化</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName); </span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);<span class="comment">// 放入二级缓存中</span></span><br><span class="line">                                <span class="keyword">this</span>.singletonFactories.remove(beanName); <span class="comment">// 最后要移除三级缓存</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><span id="factorybean的转换"></span><h3 id="factoryBean的转换"><a href="#factoryBean的转换" class="headerlink" title="factoryBean的转换"></a>factoryBean的转换</h3><p>如果第一步beanName参数是以&quot;&amp;&quot;为前缀，则必须要返回FactoryBean，获取的不是FactoryBean类型的话直接报错<br>如果不是&quot;&amp;&quot;前缀，并且获取到的实例为FactoryBean的类型的话，则标记<code>beanDefinition.isFactoryBean=true</code>，并调用<code>FactoryBean#getObject</code>方法返回真正的对象  </p><hr><span id="工厂bean调用方法factorybean-getobject流程"></span><h3 id="工厂bean调用方法factoryBean-getObject流程"><a href="#工厂bean调用方法factoryBean-getObject流程" class="headerlink" title="工厂bean调用方法factoryBean#getObject流程"></a>工厂bean调用方法<code>factoryBean#getObject</code>流程</h3><ol><li>首先判断是不是<code>isSingleton</code>，如果不是则直接调用<code>getObject</code>方法并调用<code>BeanPostProcessor#postProcessAfterInitialization</code>此时bean已创建完成（并不会自动装配）  </li><li>如果是singleton<code>FactoryBean#isSingleton</code>,则会放入缓存，每次优先取缓存，有则直接返回  </li><li>没有缓存则调用<code>getObject</code>，把当前beanName存放在一个set中，标志正在创建中,然后调用<code>BeanPostProcessor#postProcessAfterInitialization</code>此时bean已创建完成（并不会自动装配）,完事放入缓存中，并从set中移除  <blockquote><p>如果在<code>postProcessAfterInitialization</code>期间又引用了当前的bean的话，则会重新调用<code>getObject</code>返回一个新的对象</p></blockquote></li></ol><hr><h2 id="获取不到bean则创建"><a href="#获取不到bean则创建" class="headerlink" title="获取不到bean则创建"></a>获取不到bean则创建</h2><p>spring对非单例的循环引用会直接报错<code>throw new BeanCurrentlyInCreationException(beanName)</code>  </p><blockquote><p>非单例的bean创建之前都会把beanName放入<code>prototypesCurrentlyInCreation</code>中，创建过程中如果存在一样的bean名称，视为循环引用，直接报错，没有循环引用最后创建完则从中移除</p></blockquote><p>创建bean，必须需要beanDefinition，没有则<code>throw new NoSuchBeanDefinitionException</code>  </p><blockquote><p>beanDefinition的注册<br>在<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90#4-beandefinitionregistry">beanFactory初始化时</a>，通过调用<a href="/posts/%E8%A7%A3%E6%9E%90spring%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%91beanfactory%E6%B3%A8%E5%86%8Cbean%E7%9A%84">ConfigurationClassPostProcessor</a>向beanFactory中注册符合条件的beanDefinition  </p></blockquote><hr><h3 id="创建bean时的前期流程"><a href="#创建bean时的前期流程" class="headerlink" title="创建bean时的前期流程"></a>创建bean时的前期流程</h3><ol><li><p>如果parentBeanFactory不为空，且当前的beanFactory不包含beanDefinition则交由parentBeanFactory处理，<a href="#%E6%8A%8Abeanname%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%BA%E6%A0%87%E5%87%86%E7%9A%84beanname">从头开始</a>  </p></li><li><p>把当前的bean标记为已创建，存放在<code>alreadyCreated</code>中，如果<code>alreadyCreated</code>不为空，代表beanFactory已开始创建bean  </p></li><li><p>把当前的beanDefinition转换成<code>RootBeanDefinition</code>，root是spring创建bean时的视图，包含了父类的信息，算是一个标准，没有他可不行  </p><blockquote><p>获取rootBeanDefinition逻辑时，如果包含内嵌的类，并且内嵌的类非singleton，则外围类的scope同内嵌的类  </p></blockquote></li><li><p>确保<code>dependsOn</code>的beanName优先<a href="#%E6%8A%8Abeanname%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%BA%E6%A0%87%E5%87%86%E7%9A%84beanname">初始化</a>  </p><blockquote><p><code>@DependsOn</code>注解或其他配置等</p></blockquote></li><li><p>判断bean的作用域<br>首先判断作用域，非单例的其他作用域则在创建前会把beanName放入<code>prototypesCurrentlyInCreation</code>中<br>如果有循环引用直接报错(通过<code>prototypesCurrentlyInCreation</code>判断是否包含bean的名称)，单例的循环引用不报错，最后创建完则从中移除  </p><blockquote><p>自定义的作用域(非单例，非<code>prototype</code>)，都会从<code>scopes</code>中取对应的scope实现，比如servlet实现的session、request  </p></blockquote></li></ol><hr><span id="通过rootbeandefinition获取真实的class"></span><h3 id="通过RootBeanDefinition获取真实的class"><a href="#通过RootBeanDefinition获取真实的class" class="headerlink" title="通过RootBeanDefinition获取真实的class"></a>通过RootBeanDefinition获取真实的class</h3><p>如果是FactoryMethod则会通过反射获取方法上返回的类型<br>如果存在tempClassLoader，则用tempClassLoader加载class，不管用什么，都不会初始化class，除非已经初始化过</p><hr><span id="通过instantiationawarebeanpostprocessor提前实例化"></span><h3 id="通过InstantiationAwareBeanPostProcessor提前实例化"><a href="#通过InstantiationAwareBeanPostProcessor提前实例化" class="headerlink" title="通过InstantiationAwareBeanPostProcessor提前实例化"></a>通过<code>InstantiationAwareBeanPostProcessor</code>提前实例化</h3><p>此类为<a href="/posts/beanpostprocessor%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0#instantiationawarebeanpostprocessor"><code>BeanPostProcessor</code></a>的子类<br>可以拦截bean实例化之前（<code>不包含factoryBean#getObject</code>），如果返回不为空，则直接调用<code>BeanPostProcessor</code>的后置方法并直接返回，此时bean已创建完毕（很少用）  </p><hr><span id="创建beanwrapper"></span><h3 id="创建beanWrapper"><a href="#创建beanWrapper" class="headerlink" title="创建beanWrapper"></a>创建beanWrapper</h3><blockquote><p><code>beanDefinition</code>为class定义的各种信息，<code>beanWrapper</code>为实例化的包装，包含一个实例的各种信息  </p></blockquote><p>通过<code>beanDefinition</code>创建<code>BeanWrapper</code><br>要考虑到factoryBean有可能已经初始化过<a href="#%E9%80%9A%E8%BF%87beanname%E8%8E%B7%E5%8F%96class%E6%B5%81%E7%A8%8B">在根据beanName获取class的过程中</a>）,所以优先从缓存<span id='缓存取对应的beanWrapper'/><code>factoryBeanInstanceCache</code>获取factoryBean对应的beanWrapper，没有则会创建  </p><p>创建beanWrapper其实就是创建bean的实例，创建流程如下  </p><ol><li><p>在beanDefinition中如果提供<code>instanceSupplier</code>则直接调用并返回<br>如我们常用的注解<code>@EnableConfigurationProperties</code>,instanceSupplier就是由他提供实现<code>ConfigurationPropertiesValueObjectBeanDefinition</code>  </p></li><li><p>在beanDefinition中如果提供<code>FactoryMethodName</code>则需要调用此方法获取实例<br>如常用的注解<code>@Bean</code>，该方法如果有参数，则会从从beanDefinition和beanFactory中获取，找不到就报错，最终调用factoryMethod并返回  </p></li><li><p>在beanDefinition中如果有缓存则直接用缓存实例化-非单例的bean可能会多次实例化<br>缓存的是构造方法，有其他步骤给给缓存赋值，如果缓存不为空则直接使用，如果有参数，则会从从beanDefinition和beanFactory中获取  </p></li><li><p>以上步骤都没有实例化则获取所有的构造方法寻找能够实例化的constructor<br>优先使用有@Autowire注解的构造，如果required=true，参数不满足则直接报错，否则尝试用其他的</p></li></ol><blockquote><p>@Lookup注解的原理就是在此实例化bean的时候创建动态代理，具体可参考<code>CglibSubclassingInstantiationStrategy#instantiateWithMethodInjection</code></p></blockquote><hr><h3 id="单例的bean放入三级缓存中"><a href="#单例的bean放入三级缓存中" class="headerlink" title="单例的bean放入三级缓存中"></a>单例的bean放入三级缓存中</h3><p>如果是单例，则通过<a href="/posts/beanpostprocessor%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0#3-getearlybeanreference"><code>SmartInstantiationAwareBeanPostProcessor</code></a>提供早期的引用,并放入三级缓存<code>singletonFactories</code>中<br>等bean初始化完之后如果三级缓存中的bean也初始化了，说明当前bean有循环引用，则用三级缓存中的bean  </p><hr><h3 id="自动装配和初始化方法调用-aop和ioc"><a href="#自动装配和初始化方法调用-aop和ioc" class="headerlink" title="自动装配和初始化方法调用-aop和ioc"></a>自动装配和初始化方法调用-aop和ioc</h3><p>自动装配、初始化方法调用等都是通过beanPostProcessor来实现的<br>执行<a href="/posts/beanpostprocessor%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0#4-postprocessafterinstantiation">beanPostProcessor</a>第四步后面的流程<br>至此bean实例化、初始化完毕。如果是单例的bean则会放到<code>singletonObjects</code>中，缓存起来</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>spring在获取bean的时候如果没有就会自动创建，如果是单例的bean就会缓存起来，非单例的每次根据scope作用域创建<br>spring最著名的莫非IOC和AOP了，在创建bean的时候通过<a href="/posts/beanpostprocessor%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0">beanPostProcessor</a>完成IOC和AOP等逻辑  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;获取一个bean时&lt;code&gt;AbstractBeanFactory#doGetBean&lt;/code&gt;，除非bean已经存在，否则会通过be</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>解析spring是如何向beanFactory注册bean的</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E8%A7%A3%E6%9E%90spring%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%91beanfactory%E6%B3%A8%E5%86%8Cbean%E7%9A%84/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E8%A7%A3%E6%9E%90spring%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%91beanfactory%E6%B3%A8%E5%86%8Cbean%E7%9A%84/</id>
    <published>2021-09-19T03:47:56.000Z</published>
    <updated>2021-09-19T03:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><big><strong>ConfigurationClassPostProcessor</strong></big><br>该类是一个BeanFactoryPostProcessor后置处理程序，其主要功能就是扫描beanFactory已注册的bean上的注解进而处理注解对应的职责<br>在<a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">spring的refresh阶段</a>调用<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90#4-%E8%B0%83%E7%94%A8beanfactorypostprocessors">beanFactoryPostProcessors</a>时该类才开始工作  </p><blockquote><p>在springContext初始化的时候通过<code>AnnotationConfigUtils#registerAnnotationConfigProcessors</code>向beanFactory注册该类  </p></blockquote><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><span id="1-挨个挨个扫描beanfactory中的未扫描的bean"></span><h2 id="1-挨个挨个扫描beanFactory中的未扫描的bean"><a href="#1-挨个挨个扫描beanFactory中的未扫描的bean" class="headerlink" title="1. 挨个挨个扫描beanFactory中的未扫描的bean"></a>1. 挨个挨个扫描beanFactory中的未扫描的bean</h2><p>该类开始工作时，<a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B#3-contextprepared--applicationcontextinitializedevent">main方法所在的类已注册到beanFactory中</a><br>先开始扫描main方法所在的类，并执行以下步骤2、3、4、5、6、7、8...等全部步骤，执行过程中会有新的bean注册到beanFactory中<br>然后再从beanFactory获取所有beanNames<code>getBeanDefinitionNames</code>,过滤未扫描的bean继续扫描，直到扫完为止  </p><p>每扫一个bean执行完全部步骤之后都会</p><blockquote><ul><li>执行在扫描期间扫描到的注解<a href="#deferredimportselector">@Import需延后执行的-DeferredImportSelector</a>现在立马执行  </li><li>遍历<a href="#3-%E9%80%9A%E8%BF%87conditionevaluator%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6"><code>configurationClasses</code></a>，过滤已经解析过的，然后执行以下步骤  </li></ul><ol><li>通过<code>ConditionEvaluator</code>判断是否满足注册条件(<small>在<code>ConfigurationPhase.REGISTER_BEAN</code>执行期间</small>)，不满足则return;</li><li>如果是内嵌类、或者是<code>@Import</code>的类，则会被作为一个<code>@Configuration</code>注解的类，注册到beanFactory中(内嵌的类有其他注解则以其他注解优先，参考步骤2的注解)  </li><li>注册扫描期间扫描到的@Bean注解的方法，会通过<code>ConditionEvaluator</code>判断是否满足条件(<small>在<code>ConfigurationPhase.REGISTER_BEAN</code>执行期间</small>)  </li><li>执行扫描期间扫描到的<a href="#8-%E9%81%87%E5%88%B0importresource%E6%B3%A8%E8%A7%A3%E6%97%B6">@ImportResource对应的资源</a>现在进行资源的解析  </li><li>执行在扫描期间扫描到的注解<a href="#importbeandefinitionregistrar">@Import需延后执行的-ImportBeanDefinitionRegistrar</a>现在立马执行 </li></ol></blockquote><h2 id="2-如果class没有配置注解的话直接跳过"><a href="#2-如果class没有配置注解的话直接跳过" class="headerlink" title="2. 如果class没有配置注解的话直接跳过"></a>2. 如果class没有配置注解的话直接跳过</h2><p>必须有@Configuration<br>或@Component、@PropertySources、@ComponentScan、@Import、@ImportResource<br>或方法上有@Bean注解的<br>注解上包含以上注解的也可以---称之为复合注解（组合注解）  </p><blockquote><p>遇到class：BeanFactoryPostProcessor、BeanPostProcessor、AopInfrastructureBean、EventListenerFactory直接跳过</p></blockquote><span id="3-通过conditionevaluator判断是否满足条件"></span><h2 id="3-通过ConditionEvaluator判断是否满足条件"><a href="#3-通过ConditionEvaluator判断是否满足条件" class="headerlink" title="3. 通过ConditionEvaluator判断是否满足条件"></a>3. 通过<code>ConditionEvaluator</code>判断是否满足条件</h2><p>如果条件不满足(<small>在<code>ConfigurationPhase.PARSE_CONFIGURATION</code>期间</small>)则跳过，然后扫描下一个bean，继续从步骤1开始  </p><blockquote><p>如@ConditionOnBean、@ConditionOnClass、@ConditionMiss...等  </p></blockquote><p>条件满足则会判断是不是已经被扫描过，如果没有扫描则接着处理4、5、6。。。之后的全部步骤<br><strong><font color='red'>并把当前扫描的类保存到</font><code>configurationClasses</code><font color='red'>中</font></strong>  </p><p>如果已经被扫描过，则优先处理非导入的，如果都是被导入的，则会合并  </p><span id="4-遇到-component注解时优先处理内嵌的类继续循环2、3、4步骤"></span><h2 id="4-遇到-Component注解时优先处理内嵌的类继续循环2、3、4步骤"><a href="#4-遇到-Component注解时优先处理内嵌的类继续循环2、3、4步骤" class="headerlink" title="4. 遇到@Component注解时优先处理内嵌的类继续循环2、3、4步骤"></a>4. 遇到<code>@Component</code>注解时优先处理内嵌的类继续循环2、3、4步骤</h2><p>内嵌的类作为一个被导入的类</p><span id="5-遇到-propertysources、-propertysource注解时处理配置文件并添加到environment中"></span><h2 id="5-遇到-PropertySources、-PropertySource注解时处理配置文件并添加到environment中"><a href="#5-遇到-PropertySources、-PropertySource注解时处理配置文件并添加到environment中" class="headerlink" title="5. 遇到@PropertySources、@PropertySource注解时处理配置文件并添加到environment中"></a>5. 遇到<code>@PropertySources、@PropertySource</code>注解时处理配置文件并添加到environment中</h2><span id="6-遇到-componentscans、-componentscan注解时扫描对应的basepackages或basepackageclasses"></span><h2 id="6-遇到-ComponentScans、-ComponentScan注解时扫描对应的basePackages或basePackageClasses"><a href="#6-遇到-ComponentScans、-ComponentScan注解时扫描对应的basePackages或basePackageClasses" class="headerlink" title="6. 遇到@ComponentScans、@ComponentScan注解时扫描对应的basePackages或basePackageClasses"></a>6. 遇到<code>@ComponentScans、@ComponentScan</code>注解时扫描对应的basePackages或basePackageClasses</h2><p>@ComponentScan扫描的class会注册到beanFactory中并且继续循环2、3、4、5、6的步骤，但必须满足以下几个条件  </p><ul><li>扫描指定的包下面所有的class时必须有@Component注解或者@ManagedBean  <blockquote><p>该条件通过<code>ClassPathScanningCandidateComponentProvider#registerDefaultFilters</code>注册  </p></blockquote></li><li>通过<a href="#2-%E9%80%9A%E8%BF%87conditionevaluator%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6"><code>ConditionEvaluator</code></a>判断是否可以注册到beanFactory中</li><li>非接口、非abstract、并且为 top-level class or a nested class (static inner class),或者为abstract的类中必须有方法上是<code>@Lookup</code>注解的</li><li>未往beanFactory注册过的</li></ul><span id="7-遇到-import注解时进行导入操作"></span><h2 id="7-遇到-Import注解时进行导入操作"><a href="#7-遇到-Import注解时进行导入操作" class="headerlink" title="7. 遇到@Import注解时进行导入操作"></a>7. 遇到<code>@Import</code>注解时进行导入操作</h2><p>@Import可以导入任何一个类，作为一个被导入的类，继续循环2、3、4、5、6、7的步骤,但是注意有三种类型比较特殊  </p><blockquote><p>在本步骤处理import时，不想相互import。例如：A import B，如果 B 在 import A就会报错</p></blockquote><span id="importselector"></span><h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>  此类型的实现通过调用selectImports获取import的类全名称(可以为多个)，挨个循环继续执行步骤7</p><blockquote><p>实现此类的有：<br>@EnableTransactionManagement-TransactionManagementConfigurationSelector-事务管理器<br>@EnableAsync-AsyncConfigurationSelector-开启异步<br>@EnableCaching-CachingConfigurationSelector-开启缓存  </p></blockquote><span id="deferredimportselector"></span><h3 id="DeferredImportSelector"><a href="#DeferredImportSelector" class="headerlink" title="DeferredImportSelector"></a>DeferredImportSelector</h3><p>  作用同ImportSelector，但是是延后处理，调用时机在<a href="#1-%E6%8C%A8%E4%B8%AA%E6%8C%A8%E4%B8%AA%E6%89%AB%E6%8F%8Fbeanfactory%E4%B8%AD%E7%9A%84%E6%9C%AA%E6%89%AB%E6%8F%8F%E7%9A%84bean">步骤1</a>扫描bean执行完全部的步骤之后才会调用  </p><blockquote><p>实现此类的有：<br>@EnableAutoConfiguration-AutoConfigurationImportSelector-开启自动配置<br>@ImportAutoConfiguration-ImportAutoConfigurationImportSelector-通过springSpi自定义具体的实现  </p></blockquote><span id="importbeandefinitionregistrar"></span><h3 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h3><p>  也是延后处理，调用时机在<a href="#1-%E6%8C%A8%E4%B8%AA%E6%8C%A8%E4%B8%AA%E6%89%AB%E6%8F%8Fbeanfactory%E4%B8%AD%E7%9A%84%E6%9C%AA%E6%89%AB%E6%8F%8F%E7%9A%84bean">步骤1</a>扫描bean执行完全部的步骤之后才会调用<br>  不同于<a href="#importselector">ImportSelector</a>此接口需要使用者自己往beanFactory注册bean，注册之前会有注解相关的信息供使用者使用  </p><blockquote><p>实现此类的有：<br>@EnableAspectJAutoProxy-AspectJAutoProxyRegistrar-aop拦截符合条件的类<br>@EnableConfigurationProperties-EnableConfigurationPropertiesRegistrar-配置实体和配置文件的映射（配置文件类）  </p></blockquote><span id="8-遇到-importresource注解时"></span><h2 id="8-遇到-ImportResource注解时"><a href="#8-遇到-ImportResource注解时" class="headerlink" title="8. 遇到@ImportResource注解时"></a>8. 遇到<code>@ImportResource</code>注解时</h2><p>  @ImportResource用来导入一个资源文件如早期的spring-application.xml的配置文件<br>  但是资源并不会立马解析，也是延后处理，调用时机也是在<a href="#1-%E6%8C%A8%E4%B8%AA%E6%8C%A8%E4%B8%AA%E6%89%AB%E6%8F%8Fbeanfactory%E4%B8%AD%E7%9A%84%E6%9C%AA%E6%89%AB%E6%8F%8F%E7%9A%84bean">步骤1</a>扫描bean执行完全部的步骤之后才会解析此资源</p><span id="9-收集当前扫描的class中有-bean注解的方法-包含接口上有此注解的方法"></span><h2 id="9-收集当前扫描的class中有-Bean注解的方法-包含接口上有此注解的方法"><a href="#9-收集当前扫描的class中有-Bean注解的方法-包含接口上有此注解的方法" class="headerlink" title="9. 收集当前扫描的class中有@Bean注解的方法(包含接口上有此注解的方法)"></a>9. 收集当前扫描的class中有@Bean注解的方法(包含接口上有此注解的方法)</h2><span id="10-继续扫描当前class的父类，直到为object为止"></span><h2 id="10-继续扫描当前class的父类，直到为Object为止"><a href="#10-继续扫描当前class的父类，直到为Object为止" class="headerlink" title="10. 继续扫描当前class的父类，直到为Object为止"></a>10. 继续扫描当前class的父类，直到为Object为止</h2><p>继续从步骤2开始</p><h1 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h1><h2 id="步骤1的代码"><a href="#步骤1的代码" class="headerlink" title="步骤1的代码"></a>步骤1的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">PriorityOrdered</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">            <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">            <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      parser.parse(candidates);<span class="comment">//执行2、3、4、5、6 。。。全部步骤</span></span><br><span class="line">      parser.validate();<span class="comment">// 对于@Configuration的，类验证是否可以重写内部的方法</span></span><br><span class="line"></span><br><span class="line">      Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">      configClasses.removeAll(alreadyParsed);<span class="comment">// 过滤已经处理过的</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 步骤1当中的每一个bean，parse完之后都会做的步骤</span></span><br><span class="line">      <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">      alreadyParsed.addAll(configClasses); <span class="comment">// 添加到已处理过的</span></span><br><span class="line"></span><br><span class="line">      candidates.clear();</span><br><span class="line">      <span class="comment">// 过滤未扫描的bean继续扫描，这一块spring开发人员写的不怎么样，阅读起来有点费劲</span></span><br><span class="line">      <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">        String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">        Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">        Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">          alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">            BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">            <span class="comment">// 如果class没有步骤2中注解的话直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                    !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">              candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        candidateNames = newCandidateNames;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤2的代码"><a href="#步骤2的代码" class="headerlink" title="步骤2的代码"></a>步骤2的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassUtils</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkConfigurationClassCandidate</span><span class="params">(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    AnnotationMetadata metadata = <span class="comment">// 通过beanDef和metadataReaderFactory获取到metadata;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果是以下几种的class则至直接跳过，不解析</span></span><br><span class="line">    <span class="comment">// BeanFactoryPostProcessor、BeanPostProcessor、AopInfrastructureBean、EventListenerFactory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有@Configuration注解  </span></span><br><span class="line">    Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">&quot;proxyBeanMethods&quot;</span>))) &#123;</span><br><span class="line">      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// isConfigurationCandidate: </span></span><br><span class="line">    <span class="comment">// 包含@Component、@PropertySources、@ComponentScan、@Import、@ImportResource</span></span><br><span class="line">    <span class="comment">// 或方法上有@Bean注解的</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (config != <span class="keyword">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; candidateIndicators = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">    candidateIndicators.add(Component.class.getName());</span><br><span class="line">    candidateIndicators.add(ComponentScan.class.getName());</span><br><span class="line">    candidateIndicators.add(Import.class.getName());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line">      <span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      ...  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤3的代码"><a href="#步骤3的代码" class="headerlink" title="步骤3的代码"></a>步骤3的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassParser</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 当前类初始化的时候</span></span><br><span class="line">  <span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, resourceLoader);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 在PARSE_CONFIGURATION期间判断是否满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经处理过，则优先处理非导入的类，如果都是导入的。则合并导入的类</span></span><br><span class="line">    ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">          existingClass.mergeImportedBy(configClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">        <span class="comment">// Let&#x27;s remove the old one and go with the new one.</span></span><br><span class="line">        <span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">        <span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">    SourceClass sourceClass = asSourceClass(configClass, filter);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 执行4、5、6、7、8....等全部步骤</span></span><br><span class="line">      sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤4之后的代码"><a href="#步骤4之后的代码" class="headerlink" title="步骤4之后的代码"></a>步骤4之后的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassParser</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理内嵌的类</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">      processMemberClasses(configClass, sourceClass, filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤5的代码</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), </span><br><span class="line">            PropertySources.class, org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">        processPropertySource(propertySource);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤6的代码</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp; !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">        <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">        <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">          BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">          <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bdCand = holder.getBeanDefinition();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤7的代码</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), filter, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤8的代码</span></span><br><span class="line">    AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">        String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">        configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤9的代码</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">      configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤10的代码</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">      String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">      <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp; !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">        <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">        <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有兴趣的可以用IDE阅读源码一番，会有不一样的收获</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ConfigurationClassPostProcessor的作用就是扫描类上的注解，继而处理注解对应的功能<br>@Component、@PropertySources、@ComponentScan、@Import、@ImportResource、方法上@Bean的注解都有不同的职责，都是由此类进行处理<br>从<a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B#4-contextloaded--applicationpreparedevent">spring启动过程中的refresh</a>阶段对beanFactory的操作，到<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90#4-%E8%B0%83%E7%94%A8beanfactorypostprocessors">调用beanFactory的后置处理器</a><small>本文的实现</small>，大体对spring的整体流程有了个全新的概貌<br>此时、beanFactory也初始化、bean的定义也都注册了，接下来我们会<a href="/posts/spring%E5%AF%B9bean%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%B5%81%E7%A8%8B">分析bean的实例化流程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;&lt;big&gt;&lt;strong&gt;ConfigurationClassPostProcessor&lt;/strong&gt;&lt;/big&gt;&lt;br&gt;该类是一个Be</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>JVM所有的参数配置详解</title>
    <link href="https://dongmaxiang.vercel.app/posts/jvm%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://dongmaxiang.vercel.app/posts/jvm%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-09-18T21:21:03.000Z</published>
    <updated>2021-09-18T21:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="启动时输出jvm所有的配置"><a href="#启动时输出jvm所有的配置" class="headerlink" title="启动时输出jvm所有的配置"></a>启动时输出jvm所有的配置</h1><ol><li>-XX:+PrintFlagsFinal</li></ol><h1 id="启动时输出非默认的jvm参数-人为配置的"><a href="#启动时输出非默认的jvm参数-人为配置的" class="headerlink" title="启动时输出非默认的jvm参数(人为配置的)"></a>启动时输出非默认的jvm参数(人为配置的)</h1><ol><li>-XX:+PrintCommandLineFlags</li></ol><h1 id="循环放置安全点"><a href="#循环放置安全点" class="headerlink" title="循环放置安全点"></a><a href="/posts/java%E5%AE%89%E5%85%A8%E7%82%B9safepoint%E4%BB%A5%E5%8F%8Ajit#%E5%AE%89%E5%85%A8%E7%82%B9%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%91%A2">循环放置安全点</a></h1><ol><li>-XX:+UseCountedLoopSafepoints</li></ol><h1 id="设置默认的hashcode"><a href="#设置默认的hashcode" class="headerlink" title="设置默认的hashcode"></a>设置默认的hashcode</h1><ul><li><p>-XX:hashCode=0<br>此类方案返回一个Park-Miller伪随机数生成器生成的随机数</p></li><li><p>-XX:hashCode=1<br>此类方案将对象的内存地址，做移位运算后与一个随机数进行异或得到结果</p></li><li><p>-XX:hashCode=2<br>永远返回固定值1</p></li><li><p>-XX:hashCode=3<br>此类方案返回一个自增序列的当前值  </p></li><li><p>-XX:hashCode=4<br>此类方案返回当前对象的内存地址  </p></li></ul><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><span id="1-xms1024m"></span><h2 id="1-Xms1024m"><a href="#1-Xms1024m" class="headerlink" title="1. -Xms1024m"></a>1. -Xms1024m</h2><p>   最小堆内存大小(memory start)</p><span id="2-mmx2048m"></span><h2 id="2-Mmx2048m"><a href="#2-Mmx2048m" class="headerlink" title="2. -Mmx2048m"></a>2. -Mmx2048m</h2><p>   最大堆内存大小(memory max)</p><span id="3-xx-usecompressedoops"></span><h2 id="3-XX-UseCompressedOops"><a href="#3-XX-UseCompressedOops" class="headerlink" title="3. -XX:+UseCompressedOops"></a>3. -XX:+UseCompressedOops</h2><p>   开启普通对象的指针压缩，此参数也会默认开启UseCompressedClassPointers<br>   一个对象的指针默认为8字节(64bit)，压缩后变为4字节(32bit)，最大可表示4G(2^32)，经JVM处理之后最大可访问地址为32G(堆内存大于32G时会自动失效)<br>   为什么压缩后用4字节就可以最大访问32G呢，因为根据jvm对象对齐空间来算(ObjectAlignmentInBytes默认是8)，也就是按照最小对象8字节来算有8个空挡(间隔)，所以2^32*8bit=32G<br>   开启之后会在机器码中植入压缩与解压指令，会给JVM增加额外的开销<br>   在jdk6以后不是clientVM且是64位的jvm中默认为开启状态  </p><span id="4-xx-usecompressedclasspointers"></span><h2 id="4-XX-UseCompressedClassPointers"><a href="#4-XX-UseCompressedClassPointers" class="headerlink" title="4. -XX:+UseCompressedClassPointers"></a>4. -XX:+UseCompressedClassPointers</h2><p>   开启在对象头中<a href="/posts/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Cgc%E4%BB%A5%E5%8F%8A%E9%94%81#1-%E5%AF%B9%E8%B1%A1%E5%A4%B4">类指针的压缩</a><br>   如果UseCompressedOops是关闭的状态，则会报错  </p><span id="5-xx-objectalignmentinbytes-8"></span><h2 id="5-XX-ObjectAlignmentInBytes-8"><a href="#5-XX-ObjectAlignmentInBytes-8" class="headerlink" title="5. -XX:ObjectAlignmentInBytes=8"></a>5. -XX:ObjectAlignmentInBytes=8</h2><p>   对象对齐空间大小(bit)默认为8</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><span id="xx-usebiasedlocking"></span><h2 id="XX-UseBiasedLocking"><a href="#XX-UseBiasedLocking" class="headerlink" title="-XX:-UseBiasedLocking"></a>-XX:-UseBiasedLocking</h2><p>  关闭<a href="/posts/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Cgc%E4%BB%A5%E5%8F%8A%E9%94%81#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>、jdk1.6之后默认为开启偏向锁。偏向锁竞争时会STW，如果竞争过于激烈，会导致性能下降  </p><span id="xx-biasedlockingstartupdelay-4000"></span><h2 id="XX-BiasedLockingStartupDelay-4000"><a href="#XX-BiasedLockingStartupDelay-4000" class="headerlink" title="-XX:BiasedLockingStartupDelay=4000"></a>-XX:BiasedLockingStartupDelay=4000</h2><p>  jvm启用偏向锁延迟时间，偏向锁的信息都是在markword(对象头)里面，刚出生的对象markword信息都是由对应的Klass中的prototype_header(包含锁标识、epoch)决定的<br>  默认启动4秒之后会把所有的klass的prototype_header中的数据标识为匿名偏向锁，只有匿名偏向锁才可以使用偏向锁  </p><blockquote><p>延时机制是为了解决：JVM启动时必不可免会有大量sync的操作，而偏向锁竞争时会STW并升级为轻量级锁。如果开启了偏向锁，竞争会发生大量锁撤销和锁升级操作，大大降低JVM启动效率  </p></blockquote><span id="xx-biasedlockingbulkrebiasthreshold-20"></span><h2 id="XX-BiasedLockingBulkRebiasThreshold-20"><a href="#XX-BiasedLockingBulkRebiasThreshold-20" class="headerlink" title="-XX:BiasedLockingBulkRebiasThreshold=20"></a>-XX:BiasedLockingBulkRebiasThreshold=20</h2><p>  偏向锁批量重偏向阈值，因为默认只能锁升级，升级轻量级锁需要等待<a href="/posts/java%E5%AE%89%E5%85%A8%E7%82%B9safepoint%E4%BB%A5%E5%8F%8Ajit#safepoint">全局安全点</a>，会耗费性能<br>  如果某个class的对象的偏向锁升级轻量级锁次数达到第20次时，则会标识第20个(包含)之后的对象全部可以偏向新的线程，避免升级为轻量级锁  </p><blockquote><p>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁升级为轻量级锁<br>重偏原理是修改klass的prototype_header中的epoch,做+1操作，这样偏向锁上锁时检测epoch为失效状态，就会重新使用CAS上锁  </p></blockquote><span id="xx-biasedlockingbulkrevokethreshold-40"></span><h2 id="XX-BiasedLockingBulkRevokeThreshold-40"><a href="#XX-BiasedLockingBulkRevokeThreshold-40" class="headerlink" title="-XX:BiasedLockingBulkRevokeThreshold=40"></a>-XX:BiasedLockingBulkRevokeThreshold=40</h2><p>  偏向锁批量撤销阈值，撤销之后直接从轻量级锁开始。同上，如果锁升级过多，在25秒(如下参数设置)内，超过40次，则直接撤销当前class对应所有对象的偏向锁，后续一律从轻量级锁开始<br>  撤销的原理是：刚出生的对象markword信息都是由对应的Klass的决定的，修改Klass中的prototype_header弃用偏向锁即可  </p><blockquote><p>批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的  </p></blockquote><span id="xx-biasedlockingdecaytime-25000-默认"></span><h2 id="XX-BiasedLockingDecayTime-25000-默认"><a href="#XX-BiasedLockingDecayTime-25000-默认" class="headerlink" title="-XX:BiasedLockingDecayTime=25000(默认)"></a>-XX:BiasedLockingDecayTime=25000(默认)</h2><p>  同上，一定时间内的阈值  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;启动时输出jvm所有的配置&quot;&gt;&lt;a href=&quot;#启动时输出jvm所有的配置&quot; class=&quot;headerlink&quot; title=&quot;启动时输出jvm所有的配置&quot;&gt;&lt;/a&gt;启动时输出jvm所有的配置&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;-XX:+PrintFlagsFinal</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="jvm" scheme="https://dongmaxiang.vercel.app/categories/java/jvm/"/>
    
    
    <category term="jvm" scheme="https://dongmaxiang.vercel.app/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>打印日志引起的oom的解决方案</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E5%BC%95%E8%B5%B7%E7%9A%84oom%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E5%BC%95%E8%B5%B7%E7%9A%84oom%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-09-18T19:44:42.000Z</published>
    <updated>2021-09-18T19:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>电商促销的逻辑，由于算价过程涉及的逻辑较多，所以有关算价的过程及结果数据都会打印下来，一旦有问题较容易排查<br><strong>满减赠折</strong>是促销模块比较复杂的逻辑，这次出现问题的原因是因为建了一个<em>满减赠折</em>的活动，满1元送一个赠品以及100个积分，几十万元送几十w个赠品，导致在打印日志的时候出现了问题  </p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>好在运维人员配置了自动dumpMemory  </p><blockquote><p> <strong><a href="/posts/jvm%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/applicationNameHeapdump.hprof</a></strong><br> 在JVM内存溢出的时候自动dump内存快照,HeapDumpPath指定dump的路径，不指定的话默认输出路径为项目的根路径<br> 经本地main方法测验，只要dump过一次，之后多次出现的oom不会dump第二次(删除dump的文件也不行)</p></blockquote><p>用jProfiler分析之后发现果然是日志打印过多，就是因为送赠品送了几十w个，会产生几十w个对象，显然这是不正确的，实际应该用数值表示有多少个即可。所以几十w个对象再用日志输出的时候显然就成为了一个系统瓶颈<br>毕竟在写完磁盘之前，这些对象一直贮存在内存中，导致内存偏小，机器的tps明显下降、甚至多次出现oom</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>可参考<a href="/posts/java%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%89%93%E5%8D%B0log#%E9%99%90%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%95%BF%E5%BA%A6">优雅打印日志</a><br>或者修改代码逻辑，用数值代表几十万的赠品，不应该用几十万个对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h1&gt;&lt;p&gt;电商促销的逻辑，由于算价过程涉及的逻辑较多，所以有关算价的过程及结果数据都会打印下来，一旦有问题较容易排查&lt;br&gt;&lt;strong&gt;满减赠折&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="log" scheme="https://dongmaxiang.vercel.app/categories/java/log/"/>
    
    
    <category term="log" scheme="https://dongmaxiang.vercel.app/tags/log/"/>
    
    <category term="线上问题" scheme="https://dongmaxiang.vercel.app/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>spring对Bean的排序</title>
    <link href="https://dongmaxiang.vercel.app/posts/spring%E5%AF%B9bean%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>https://dongmaxiang.vercel.app/posts/spring%E5%AF%B9bean%E7%9A%84%E6%8E%92%E5%BA%8F/</id>
    <published>2021-09-12T19:29:56.000Z</published>
    <updated>2021-09-12T19:29:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h1><p>不同的bean实现的接口不同、它的作用也不不同、那么他的加载顺序也不同<br>具体可参考<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90#4-%E8%B0%83%E7%94%A8beanfactorypostprocessors">beanFactory对不同类型的bean加载的顺序</a>  </p><p>如果bean的类型相同、实现的接口也相同则根据</p><ol><li>实现<code>org.springframework.core.PriorityOrdered</code>接口</li><li>实现<code>org.springframework.core.Ordered</code>接口</li><li>注解<code>@Order</code></li><li>注解<code>@Priority</code>  </li></ol><p>以上优先级从高到低<br>接口优先级比注解的高<br>如果都是接口PriorityOrdered优先级更高<br>如果都是注解@Order优先级更高<br><strong>数值越小的优先级就越高</strong></p><h1 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h1><p>具体可参考<code>org.springframework.core.OrderComparator</code></p><blockquote><p>默认的排序（不支持注解）</p></blockquote><p>具体可参考<code>org.springframework.core.annotation.AnnotationAwareOrderComparator</code></p><blockquote><p>支持注解的排序</p></blockquote><p>具体可参考<code>org.springframework.core.annotation.OrderUtils</code></p><blockquote><p>获取注解</p></blockquote><p>spring 中对bean的排序用的是<code>org.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE</code></p><span id="spring初始化context时会把排序的类注册到beanfactory中"></span><h2 id="spring初始化context时会把排序的类注册到beanFactory中"><a href="#spring初始化context时会把排序的类注册到beanFactory中" class="headerlink" title="spring初始化context时会把排序的类注册到beanFactory中"></a>spring初始化context时会把排序的类注册到beanFactory中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">    beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大体流程&quot;&gt;&lt;a href=&quot;#大体流程&quot; class=&quot;headerlink&quot; title=&quot;大体流程&quot;&gt;&lt;/a&gt;大体流程&lt;/h1&gt;&lt;p&gt;不同的bean实现的接口不同、它的作用也不不同、那么他的加载顺序也不同&lt;br&gt;具体可参考&lt;a href=&quot;/posts/sp</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>springBeanFactory流程解析</title>
    <link href="https://dongmaxiang.vercel.app/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>https://dongmaxiang.vercel.app/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</id>
    <published>2021-09-12T18:22:28.000Z</published>
    <updated>2021-09-12T18:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring启动流程中的refresh阶段"><a href="#spring启动流程中的refresh阶段" class="headerlink" title="spring启动流程中的refresh阶段"></a><a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">spring启动流程</a>中的refresh阶段</h1><p>beanFactory在refresh阶段完成配置、扫描bean、注册bean等重要操作步骤  </p><ul><li>refresh代码流程  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 获取beanFactory,默认为new DefaultListableBeanFactory()</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">            prepareBeanFactory(beanFactory);<span class="comment">// 配置beanFactory</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postProcessBeanFactory(beanFactory);<span class="comment">// 交给context去配置beanFactory</span></span><br><span class="line"></span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);<span class="comment">// 调用BeanFactoryPostProcessors</span></span><br><span class="line"></span><br><span class="line">                registerBeanPostProcessors(beanFactory);<span class="comment">// 注册拦截bean创建的bean处理器</span></span><br><span class="line"></span><br><span class="line">                initMessageSource();</span><br><span class="line"></span><br><span class="line">                initApplicationEventMulticaster();<span class="comment">// 初始化事件广播器，待会扫描以注解形式存在的listener</span></span><br><span class="line"></span><br><span class="line">                onRefresh(); <span class="comment">// context容器进行onRefresh，servletContext会在这个时候创建tomcat</span></span><br><span class="line"></span><br><span class="line">                registerListeners();<span class="comment">// 注册以注解形式存在的listener，并且广播之前已广播的事件</span></span><br><span class="line"></span><br><span class="line">                finishBeanFactoryInitialization(beanFactory); <span class="comment">// 加载LoadTimeWeaverAware(增强AOP，通过修改字节码实现AOP，class已加载过的话则不起作用)，冻结配置，初始化所有的bean(单例、notLazy)</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 最后一步: 发布相对应的事件</span></span><br><span class="line"><span class="comment">                    1:获取所有Lifecycle类型的bean，如果是SmartLifecycle的类型并且isAutoStartup为true，则调用start方法</span></span><br><span class="line"><span class="comment">                    2:发布contextRefreshedEvent</span></span><br><span class="line"><span class="comment">                    3:把bean的信息注册到ManagementFactory（java监控工厂）</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">                destroyBeans();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">                <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">                resetCommonCaches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们具体分析下refresh当中的重要操作步骤，分析之前，我们先了解beanFactory的作用以及实现都有哪些</p><hr><span id="beanfactory作用"></span><h1 id="beanFactory作用"><a href="#beanFactory作用" class="headerlink" title="beanFactory作用"></a>beanFactory作用</h1><p>实现的类结构，如图<img src="/img/posts/2021/spring-beanFactory.png" alt="spring-beanFactory"></p><span id="1-beanfactory"></span><h2 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1. BeanFactory"></a>1. BeanFactory</h2><blockquote><p>主要作用是通过名字或类型get对应的bean实例</p></blockquote><p>getBean|isTypeMatch|getBeanProvider|getType|getAliases等方法</p><span id="2-singletonbeanregistry"></span><h2 id="2-SingletonBeanRegistry"><a href="#2-SingletonBeanRegistry" class="headerlink" title="2. SingletonBeanRegistry"></a>2. SingletonBeanRegistry</h2><blockquote><p>主要作用是注册单例的bean  </p></blockquote><p>registerSingleton|getSingleton|getSingletonNames等方法</p><span id="3-hierarchicalbeanfactory"></span><h2 id="3-HierarchicalBeanFactory"><a href="#3-HierarchicalBeanFactory" class="headerlink" title="3. HierarchicalBeanFactory"></a>3. HierarchicalBeanFactory</h2><blockquote><p>可分层的beanFactory主要作用是可以多个beanFactory并且有父子关系</p></blockquote><p>getParentBeanFactory|containsLocalBean 只有两个方法</p><span id="4-beandefinitionregistry"></span><h2 id="4-BeanDefinitionRegistry"><a href="#4-BeanDefinitionRegistry" class="headerlink" title="4. BeanDefinitionRegistry"></a>4. <strong>BeanDefinitionRegistry</strong></h2><p>registerBeanDefinition|removeBeanDefinition|getBeanDefinition|getBeanDefinitionNames等方法  </p><ul><li>registerBeanDefinition<br>BeanDefinition是包含了bean的所有信息，bean的名称、bean的class、scope、isLazy、isPrimary、bean的属性和bean的依赖关系等<br>beanFactory获取一个bean时，除非bean已经存在，否则会通过beanDefinition自动创建，没有beanDefinition就会报错，所以beanDefinition是一个很重要的存在<br>BeanDefinition包含了class的各种信息如注解的信息、class的资源路径等，但是不会初始化class，主要通过ASM字节码读取器来解析class字节码的内容  <blockquote><p>ASM解析class字节码默认实现类<code>SimpleMetadataReaderFactory</code>，由<code>SharedMetadataReaderFactoryContextInitializer</code>在spring启动阶段中的<code>context#initialize</code>注册<br>beanFactory通过调用<a href="#4-%E8%B0%83%E7%94%A8beanfactorypostprocessors">BeanFactoryPostProcessor</a>主要的实现<a href="/posts/%E8%A7%A3%E6%9E%90spring%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%91beanfactory%E6%B3%A8%E5%86%8Cbean%E7%9A%84">ConfigurationClassPostProcessor</a>先扫描所有的class，通过AMS既可以读取class内容也不会加载class，然后符合条件的bean会包装成BeanDefinition注册到beanFactory中</p></blockquote></li></ul><span id="5-aliasregistry"></span><h2 id="5-AliasRegistry"><a href="#5-AliasRegistry" class="headerlink" title="5. AliasRegistry"></a>5. AliasRegistry</h2><blockquote><p>为注册bean的别名，通过别名也可以获取到bean，主要作用就是注册bean的别名  </p></blockquote><p>registerAlias|removeAlias|<br>getAliases|isAlias 只有这四个方法</p><span id="6-listablebeanfactory"></span><h2 id="6-ListableBeanFactory"><a href="#6-ListableBeanFactory" class="headerlink" title="6. ListableBeanFactory"></a>6. ListableBeanFactory</h2><blockquote><p>可列举的beanFactory，通过条件获取beans，主要作用通过类型或注解或其他条件获取对应的bean  </p></blockquote><p>getBeansOfType|getBeanNamesForType|findAnnotationOnBean 等方法</p><span id="7-autowirecapablebeanfactory"></span><h2 id="7-AutoWireCapableBeanFactory"><a href="#7-AutoWireCapableBeanFactory" class="headerlink" title="7. AutoWireCapableBeanFactory"></a>7. <strong>AutoWireCapableBeanFactory</strong></h2><blockquote><p>可自动装配的factory，在<a href="#1-beanfactory">获取Bean</a>的时候，如果bean还没有创建则会<a href="/posts/spring%E5%AF%B9bean%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%B5%81%E7%A8%8B#%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B">创建</a><br>默认实现<code>AbstractAutowireCapableBeanFactory#createBean</code>ioc、aop等逻辑都嵌套在内  </p></blockquote><p>resolveDependency|resolveBeanByName|applyBeanPostProcessorsBeforeInitialization|applyBeanPostProcessorsBeforeInitialization等其他方法  </p><ul><li>resolveDependency<br>在自动装配的时候会通过此方法获取可被装配的值</li></ul><span id="8-configurablelistablebeanfactory和configurablebeanfactory"></span><h2 id="8-ConfigurableListableBeanFactory和ConfigurableBeanFactory"><a href="#8-ConfigurableListableBeanFactory和ConfigurableBeanFactory" class="headerlink" title="8. ConfigurableListableBeanFactory和ConfigurableBeanFactory"></a>8. ConfigurableListableBeanFactory和ConfigurableBeanFactory</h2><blockquote><p>生产bean时、装配时、类型转化时、销毁bean、冻结等配置各种各样的组件供方便使用</p></blockquote><p>registerResolvableDependency|ignoreDependencyInterface|registerScope|addBeanPostProcessor|<br>freezeConfiguration|isConfigurationFrozen|<br>preInstantiateSingletons|destroySingletons|setTypeConverter|setConversionService等其他方法  </p><ul><li>registerResolvableDependency<br>注册一个bean，其他依赖此类型的，可以直接用，autowiredValue不会放到bean工厂中，只会为其他类提供依赖</li><li>ignoreDependencyInterface<br>自动装配时忽略某个类型，通常配合beanFactory的addBeanPostProcessor一起使用。当bean初始化完后，<a href="#5-%E6%B3%A8%E5%86%8C%E6%8B%A6%E6%88%AAbean%E5%88%9B%E5%BB%BA%E7%9A%84bean%E5%A4%84%E7%90%86%E5%99%A8-beanpostprocessor">BeanPostProcessor</a>专门set忽略的字段<br>如常用的如ServletContextAwareProcessor、EnvironmentAware、ApplicationContextAware等</li><li>registerScope<br>除单例和prototype之外有request、session等bean的生命周期定义都是由这个方法完成注册。通过Scope接口中的get方法获取bean</li></ul><span id="9-defaultlistablebeanfactory为以上全部接口的默认实现"></span><h2 id="9-DefaultListableBeanFactory为以上全部接口的默认实现"><a href="#9-DefaultListableBeanFactory为以上全部接口的默认实现" class="headerlink" title="9. DefaultListableBeanFactory为以上全部接口的默认实现"></a>9. DefaultListableBeanFactory为以上全部接口的默认实现</h2><hr><span id="beanfactory大体工作流程"></span><h1 id="beanFactory大体工作流程"><a href="#beanFactory大体工作流程" class="headerlink" title="beanFactory大体工作流程"></a>beanFactory大体工作流程</h1><span id="1-获取beanfactory"></span><h2 id="1-获取beanFactory"><a href="#1-获取beanFactory" class="headerlink" title="1 获取beanFactory"></a>1 获取beanFactory</h2><p>   context初始化时就自动创建好了<br>   默认实现<code>org.springframework.beans.factory.support.DefaultListableBeanFactory</code><br>   <code>this.beanFactory = new DefaultListableBeanFactory()</code></p><span id="2-准备beanfactory"></span><h2 id="2-准备beanFactory"><a href="#2-准备beanFactory" class="headerlink" title="2. 准备beanFactory"></a>2. 准备beanFactory</h2><p>   beanFactory是刚new出来，没有经过配置，prepareBeanFactory方法对beanFactory进行一些简单的配置<br>   如注册<a href="#5-%E6%B3%A8%E5%86%8C%E6%8B%A6%E6%88%AAbean%E5%88%9B%E5%BB%BA%E7%9A%84bean%E5%A4%84%E7%90%86%E5%99%A8-beanpostprocessor">ApplicationContextAwareProcessor</a>，调用<a href="#8-configurablelistablebeanfactory%E5%92%8Cconfigurablebeanfactory">registerResolvableDependency</a>注册BeanFactory、ApplicationContext等</p><span id="3-交给context实现类去配置beanfactory"></span><h2 id="3-交给context实现类去配置beanFactory"><a href="#3-交给context实现类去配置beanFactory" class="headerlink" title="3. 交给context实现类去配置beanFactory"></a>3. 交给context实现类去配置beanFactory</h2><p>   例如：如果是servletBeanApplicationContext会对beanFactory增加额外的<a href="#8-configurablelistablebeanfactory%E5%92%8Cconfigurablebeanfactory">Scope：registerScope</a>，比如RequestScope、SessionScope等</p><span id="4-调用beanfactorypostprocessors"></span><h2 id="4-调用BeanFactoryPostProcessors"><a href="#4-调用BeanFactoryPostProcessors" class="headerlink" title="4. 调用BeanFactoryPostProcessors"></a>4. 调用BeanFactoryPostProcessors</h2><blockquote><p>针对beanFactory注册一些的bean、移除一些bean，等其他操作<br>总之beanFactory不关心具体的实现，只调用后置处理器并把beanFactory作为参数传递过去即可</p></blockquote><p>调用beanFactory的后置处理(beanFactory已经创建了)<br>BeanFactoryPostProcessor：针对<a href="#8-configurablelistablebeanfactory%E5%92%8Cconfigurablebeanfactory">ConfigurableListableBeanFactory</a>初始化后的后置处理<br>BeanDefinitionRegistryPostProcessor：针对<a href="#4-beandefinitionregistry">BeanDefinitionRegistry</a>初始化后的后置处理<br><font color='red'>BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子类，会优先调用子类</font></p><ul><li>那BeanFactoryPostProcessor具体的实现都有哪些、以及调用顺序是什么呢<ul><li>具体的实现<ol><li>context有一个beanFactoryPostProcessors成员，在context初始化的时候可以往里面添加<br><small>默认有LazyInitializationBeanFactoryPostProcessor:如果条件满足，则设置全部的bean为懒加载、PropertySourceOrderingPostProcessor:把defaultProperties配置文件的优先级降到最低，等</small></li><li>context持有beanFactory，在context初始化的时候会往beanFactory注册<a href="#4-beandefinitionregistry">BeanDefinition</a><br><small>默认注册的有<a href="/posts/%E8%A7%A3%E6%9E%90spring%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%91beanfactory%E6%B3%A8%E5%86%8Cbean%E7%9A%84">ConfigurationClassPostProcessor，会扫描所有、注册符合条件的bean</a>等其他<br>具体可参考<code>AnnotationConfigUtils#registerAnnotationConfigProcessors</code></small></li></ol></li><li>调用的顺序<ol><li>context里面的beanFactoryPostProcessors成员，如果是<code>BeanDefinitionRegistryPostProcessor</code>类型，则优先调用，优先级是最高的</li><li>然后从beanFactory获取<code>BeanDefinitionRegistryPostProcessor</code>类型，优先调用实现了<code>PriorityOrdered</code>的接口</li><li>然后从beanFactory获取<code>BeanDefinitionRegistryPostProcessor</code>类型，调用实现了<code>Ordered</code>的接口</li><li>然后从beanFactory获取<code>BeanDefinitionRegistryPostProcessor</code>类型，经过<a href="/posts/spring%E5%AF%B9bean%E7%9A%84%E6%8E%92%E5%BA%8F">排序</a>之后、在调用没有调用过的。直到调用完beanFactory里面所有BeanDefinitionRegistryPostProcessor类型的bean为止</li><li>因为BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子类，所以等调用完所有1,2,3,4步骤对应的BeanDefinitionRegistryPostProcessor之后接着调用1、2、3、4步骤中的BeanFactoryPostProcessor</li><li>调用context里面的beanFactoryPostProcessors成员且只是<code>BeanFactoryPostProcessor</code>的类型</li><li>然后从beanFactory获取<code>BeanFactoryPostProcessor</code>类型的所有BeanName，优先调用实现了<code>PriorityOrdered</code>的接口，在调用实现了<code>Ordered</code>的接口，最后未调用过的经<a href="/posts/spring%E5%AF%B9bean%E7%9A%84%E6%8E%92%E5%BA%8F">排序</a>之后在调用</li></ol></li></ul></li></ul><span id="5-注册拦截bean创建的bean处理器-beanpostprocessor"></span><h2 id="5-注册拦截bean创建的bean处理器-BeanPostProcessor"><a href="#5-注册拦截bean创建的bean处理器-BeanPostProcessor" class="headerlink" title="5. 注册拦截bean创建的bean处理器-BeanPostProcessor"></a>5. 注册拦截bean创建的bean处理器-BeanPostProcessor</h2><p><a href="/posts/beanpostprocessor%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0">它的作用就是在bean实例化前、后，初始化前、后进行拦截操作</a></p><ul><li>BeanPostProcessor注册顺序是什么呢？<ol><li>从beanFactory获取<code>BeanPostProcessor</code>类型的所有beanNames  </li><li>遍历所有的beanNames，优先注册实现了<code>PriorityOrdered</code>的接口、然后在注册实现了<code>Ordered</code>的接口，最后未注册过的经<a href="/posts/spring%E5%AF%B9bean%E7%9A%84%E6%8E%92%E5%BA%8F">排序</a>之后在注册  </li><li>等所有的BeanPostProcessor注册完之后，如果是MergedBeanDefinitionPostProcessor类型的话注册顺序都会移到最后面哦  </li></ol></li></ul><h2 id="6-初始化国际化资源"><a href="#6-初始化国际化资源" class="headerlink" title="6. 初始化国际化资源"></a>6. 初始化国际化资源</h2><h2 id="7-初始化事件广播器"><a href="#7-初始化事件广播器" class="headerlink" title="7. 初始化事件广播器"></a>7. 初始化事件广播器</h2><p>不同于spring启动的listener，这个事件广播器用户是可以用来广播自定义事件并自定义监听的<br>默认广播器的实现<code>SimpleApplicationEventMulticaster</code>  </p><blockquote><p>使用时注入<code>ApplicationEventPublisher</code>bean，调用publishEvent方法,监听者需实现<code>ApplicationListener</code>接口即可使用</p></blockquote><span id="8-onrefresh初始化webserver"></span><h2 id="8-onRefresh初始化webServer"><a href="#8-onRefresh初始化webServer" class="headerlink" title="8. onRefresh初始化webServer"></a>8. onRefresh初始化webServer</h2><p>如果是servletContext，则会在此阶段初始化内嵌的tomcat,<a href="/posts/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B">并扫描所有的servlet、filter、其他servlet注册器等并关联到servletContext中</a></p><span id="9-获取并广播以注解形式存在的applicationlistener"></span><h2 id="9-获取并广播以注解形式存在的ApplicationListener"><a href="#9-获取并广播以注解形式存在的ApplicationListener" class="headerlink" title="9. 获取并广播以注解形式存在的ApplicationListener"></a>9. 获取并广播以注解形式存在的ApplicationListener</h2><p>在<a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">spring启动流程中</a>通过spring-spi方式获取bean来事件广播，如果某些bean非spi配置的方式，而是以注解形式配置的，则广播不了<br>所以在此阶段通过beanFactory获取以注解形式存在的listener，并把之前已广播的事件再次广播（伪事件，因为已经过了那个阶段了）</p><h2 id="10-实例化所有bean"><a href="#10-实例化所有bean" class="headerlink" title="10. 实例化所有bean"></a>10. <a href="/posts/spring%E5%AF%B9bean%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%B5%81%E7%A8%8B">实例化所有bean</a></h2><p>实例化之前，优先实例化LoadTimeWeaverAware类型的bean(增强AOP，通过修改字节码实现AOP，class已加载过的话则不起作用，但是在这个阶段class基本上都已经被加载过)  </p><ul><li><p>实例化notLazyBean、singletonBean、如果为factoryBean，必须实现<code>SmartFactoryBean</code>接口且方法<code>isEagerInit</code>返回true才可以实例化  </p><blockquote><p>notLazy And singletons 的bean是从哪里来的呢？<br>都是通过<a href="#4-beandefinitionregistry">BeanDefinitionRegistry</a>注册的bean</p></blockquote></li><li><p>实例化完之后如果是单例的bean并且实现了<code>SmartInitializingSingleton</code>接口，则会按照bean的注册顺序依次调用<code>afterSingletonsInstantiated</code></p></li></ul><h2 id="11-收尾工作-发布相对应的事件"><a href="#11-收尾工作-发布相对应的事件" class="headerlink" title="11 收尾工作-发布相对应的事件"></a>11 收尾工作-发布相对应的事件</h2><ol><li>获取所有Lifecycle类型的bean，如果是SmartLifecycle的类型并且isAutoStartup为true，则调用start方法  </li><li>发布contextRefreshedEvent  </li><li>把bean的信息注册到ManagementFactory（java监控工厂）</li></ol><p><big><strong>至此beanFactory流程解析完成</strong></big>后续继续<a href="/posts/spring%E5%AF%B9bean%E5%AE%9E%E4%BE%8B%E5%8C%96-%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%B5%81%E7%A8%8B">分析bean实例化,ioc,aop</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring启动流程中的refresh阶段&quot;&gt;&lt;a href=&quot;#spring启动流程中的refresh阶段&quot; class=&quot;headerlink&quot; title=&quot;spring启动流程中的refresh阶段&quot;&gt;&lt;/a&gt;&lt;a href=&quot;/posts/springb</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>springMvc执行流程</title>
    <link href="https://dongmaxiang.vercel.app/posts/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://dongmaxiang.vercel.app/posts/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2021-08-29T23:18:37.000Z</published>
    <updated>2021-08-29T23:18:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>spring的MVC是遵循着servlet规范的。</p><h1 id="servlet规范"><a href="#servlet规范" class="headerlink" title="servlet规范"></a>servlet规范</h1><p>当Http服务器接收请求后，Http服务器不直接调用业务类，而是把请求交给Servlet容器去处理，Servlet容器会将请求转发到具体的Servlet<br>Servlet是个接口，如果想要让业务类具备处理请求的能力则需要实现此并接口，并配置到web.xml当中即可。<br>调用servlet时如果还没创建，就加载并实例化这个Servlet，然后调用这个Servlet的service方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Servlet容器在加载Servlet类的时候会调用init方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ServletConfig就是封装Servlet的初始化参数。可以在web.xml给Servlet配置参数</span></span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Servlet容器在卸载Servlet类的时候会调用destory方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="springboot的dispatcherservlet关联到servlet容器中"></span><h1 id="springBoot的DispatcherServlet关联到servlet容器中"><a href="#springBoot的DispatcherServlet关联到servlet容器中" class="headerlink" title="springBoot的DispatcherServlet关联到servlet容器中"></a>springBoot的DispatcherServlet关联到servlet容器中</h1><p>我们知道springMVC的入口类dispatcherServlet，其实他也是servlet的实现类。那么他是如何和servlet容器关联上的呢，为什么所有的请求都由它管控呢？  </p><h2 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h2><ol><li>在springBoot容器启动流程中的<a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">ContextRefresh阶段</a>，context如果是ServletContext则会执行ServletContext的onStartup逻辑进行bind</li><li>bind逻辑通过ServletContextInitializerBeans和beanFactory获取以下实现类<br>ServletContextInitializer、Filter、Servlet、ServletContextAttributeListener、ServletRequestListener、ServletRequestAttributeListener、HttpSessionAttributeListener、HttpSessionListener、ServletContextListener</li><li>不是ServletContextInitializer的话，全部包装成ServletContextInitializer</li><li>排序所有的ServletContextInitializer，进行迭代依次调用onStartup</li><li>onStartup时会把对应的urlMapping和servlet、filter、listener绑定到servletContext中</li></ol><h2 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// servletContext会创建WebServer,该context为spring的容器上下文</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericWebApplicationContext</span> <span class="keyword">implements</span> <span class="title">ConfigurableWebServerApplicationContext</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// onRefresh是在refresh阶段调用的</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRefresh();</span><br><span class="line">        ...</span><br><span class="line">        createWebServer();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建webServer</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了阅读方便，我把代码直接写在这里。最终处理注册的实现类</span></span><br><span class="line">        ServletContextInitializer initializer = <span class="keyword">new</span> ServletContextInitializer() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 1 绑定当前context到servletContext中</span></span><br><span class="line">                <span class="comment">// 2 新增scope为application，和servlertContext关联上</span></span><br><span class="line">                <span class="comment">// 3 把servletContextParam绑定到Environment</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">for</span> (ServletContextInitializer beans : <span class="keyword">new</span> ServletContextInitializerBeans(getBeanFactory())) &#123;</span><br><span class="line">                    beans.onStartup(servletContext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建内嵌的webServer后在调用onStartup</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.webServer == <span class="keyword">null</span> &amp;&amp; getServletContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.webServer = getWebServerFactory().getWebServer(initializer);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 非内嵌的WebServer，直接调用onStartup</span></span><br><span class="line">            initializer.onStartup(servletContext);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onStartup方法通过ServletContextInitializerBeans最终获取了一批ServletContextInitializer类型的处理类，然后调用各自的onStartup完成的注册。</p><blockquote><p>ServletContextInitializer是个接口，只提供onStartup方法。具体实现有filter注册、servlet注册、Listener注册器等。<br>不同的实现会调用不同的方法，如filter只会调用servletContext.addFilter();</p></blockquote><p>ServletContextInitializer是根据ServletContextInitializerBeans以及BeanFactory获取到的。继续分析获取的流程  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContextInitializerBeans</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">ServletContextInitializer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Object&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 以及添加过的bean，不允许再次添加</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有的需要注册的bean,key为类型。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;Class&lt;?&gt;, ServletContextInitializer&gt; initializers = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 排序过后的所有要注册的bean</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ServletContextInitializer&gt; sortedList;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终迭代的对象为sortedList，sortedList是通过initializers的values排序之后的结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;ServletContextInitializer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sortedList.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sortedList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServletContextInitializerBeans</span><span class="params">(ListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通过beanFactory获取ServletContextInitializer实例</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, ? extends ServletContextInitializer&gt; initializerBean : getOrderedBeansOfType(beanFactory, ServletContextInitializer.class)) &#123;</span><br><span class="line">            <span class="comment">// 添加到成员initializers中</span></span><br><span class="line">            addServletContextInitializerBean(initializerBean.getKey(), initializerBean.getValue(), beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 通过beanFactory直接获取以下实例</span></span><br><span class="line"><span class="comment">         Servlet、Filter、</span></span><br><span class="line"><span class="comment">         ServletContextAttributeListener、ServletRequestListener、ServletRequestAttributeListener、</span></span><br><span class="line"><span class="comment">         HttpSessionAttributeListener、HttpSessionListener、ServletContextListener</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        addAdaptableBeans(beanFactory);</span><br><span class="line">        <span class="comment">// 最终排序</span></span><br><span class="line">        <span class="keyword">this</span>.sortedList = <span class="keyword">this</span>.initializers.values().stream()</span><br><span class="line">                .flatMap((value) -&gt; value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过beanFactory获取ServletContextInitializer实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addServletContextInitializerBean</span><span class="params">(String beanName, ServletContextInitializer initializer, ListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简化代码阅读</span></span><br><span class="line">        ...</span><br><span class="line">        Class&lt;?&gt; type;</span><br><span class="line">        Object source;</span><br><span class="line">        <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> ServletRegistrationBean) &#123;</span><br><span class="line">            source = ((ServletRegistrationBean&lt;?&gt;) initializer).getServlet();</span><br><span class="line">            type = Servlet.class;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> FilterRegistrationBean) &#123;</span><br><span class="line">            source = ((FilterRegistrationBean&lt;?&gt;) initializer).getFilter();</span><br><span class="line">            type = Filter.class;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> DelegatingFilterProxyRegistrationBean) &#123;</span><br><span class="line">            source = ((DelegatingFilterProxyRegistrationBean) initializer).getTargetBeanName();</span><br><span class="line">            type = Filter.class;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> ServletListenerRegistrationBean) &#123;</span><br><span class="line">            source = ((ServletListenerRegistrationBean&lt;?&gt;) initializer).getListener();</span><br><span class="line">            type = EventListener.class;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            source = initializer;</span><br><span class="line">            type = ServletContextInitializer.class;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.initializers.add(type, initializer);</span><br><span class="line">        <span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 防止重复添加，不同的包装获取source的方式不同</span></span><br><span class="line">            <span class="comment">// Mark the underlying source as seen in case it wraps an existing bean</span></span><br><span class="line">            <span class="keyword">this</span>.seen.add(source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过beanFactory直接获取以下实例</span></span><br><span class="line"><span class="comment">         Servlet、Filter、</span></span><br><span class="line"><span class="comment">         ServletContextAttributeListener、ServletRequestListener、ServletRequestAttributeListener、</span></span><br><span class="line"><span class="comment">         HttpSessionAttributeListener、HttpSessionListener、ServletContextListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addAdaptableBeans</span><span class="params">(ListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        addAsRegistrationBean(beanFactory, Servlet.class, Servlet.class, <span class="keyword">new</span> ServletRegistrationBeanAdapter(getMultipartConfig(beanFactory)));<span class="comment">//Adapter = addServlet</span></span><br><span class="line">        addAsRegistrationBean(beanFactory, Filter.class, Filter.class, <span class="keyword">new</span> FilterRegistrationBeanAdapter());<span class="comment">// Adapter = addFilter</span></span><br><span class="line">        <span class="comment">// supportedTypes = ServletContextAttributeListener、ServletRequestListener、ServletRequestAttributeListener、HttpSessionAttributeListener、HttpSessionListener、ServletContextListener</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; listenerType : ServletListenerRegistrationBean.getSupportedTypes()) &#123;</span><br><span class="line">            addAsRegistrationBean(beanFactory, EventListener.class, (Class&lt;EventListener&gt;) listenerType, <span class="keyword">new</span> ServletListenerRegistrationBeanAdapter());<span class="comment">// Adapter = addListener</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T, B extends T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAsRegistrationBean</span><span class="params">(ListableBeanFactory beanFactory, Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        Class&lt;B&gt; beanType, RegistrationBeanAdapter&lt;T&gt; adapter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, B&gt; entry : getOrderedBeansOfType(beanFactory, beanType, <span class="keyword">this</span>.seen)) &#123;</span><br><span class="line">            String beanName = entry.getKey();</span><br><span class="line">            B bean = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.seen.add(bean)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RegistrationBean registration = adapter.createRegistrationBean(beanName, bean, entries.size());</span><br><span class="line">            registration.setOrder(getOrder(bean));<span class="comment">// 获取顺序</span></span><br><span class="line">            <span class="keyword">this</span>.initializers.add(type, registration);<span class="comment">// 添加到成员当中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么所有的请求都由它管控呢<br>由DispatcherServletRegistrationBean注册dispatchServlet实例。<br>DispatcherServletRegistrationBean继承自DispatcherServletPath<br>getServletUrlMapping获取servletPath,然后addMapping到对应的servlet中  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DispatcherServletPath</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="function"><span class="keyword">default</span> String <span class="title">getServletUrlMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* getPath() 为yml配置文件中的</span></span><br><span class="line"><span class="comment">       server:</span></span><br><span class="line"><span class="comment">         servlet:</span></span><br><span class="line"><span class="comment">           context-path: ...</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (getPath().equals(<span class="string">&quot;&quot;</span>) || getPath().equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (getPath().contains(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">         <span class="keyword">return</span> getPath();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (getPath().endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">         <span class="keyword">return</span> getPath() + <span class="string">&quot;*&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> getPath() + <span class="string">&quot;/*&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此servletContext已经配置完毕。按照servlet容器的规范，我们的dispatcherServlet以及项目当中配置的filter，FilterRegistrationBean等配置都已经绑定好并生效。</p><h1 id="dispatcher正常执行流程"><a href="#dispatcher正常执行流程" class="headerlink" title="dispatcher正常执行流程"></a>dispatcher正常执行流程</h1><h2 id="大体流程-1"><a href="#大体流程-1" class="headerlink" title="大体流程"></a>大体流程</h2><ol><li>通过request从HandlerMapping获取HandlerExecutionChain（包含了handler和拦截器）handlerMapping：定位资源，不执行、不获取，只用来定位  <ul><li>@RequestMapping：<small>handler默认由RequestMappingHandlerMapping提供=org.springframework.web.method.HandlerMethod</small>  </li><li>静态资源：<small>handler默认由SimpleUrlHandlerMapping提供=org.springframework.web.servlet.resource.ResourceHttpRequestHandler</small></li></ul></li><li>通过handler获取handlerAdaptor(真正执行handler的处理器)<br>handlerAdaptor: 根据定位的资源，进行获取(执行)  <ul><li>@RequestMapping：<small>默认由org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter提供执行服务</small>    </li><li>静态资源：<small>默认由org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter提供执行服务</small></li></ul></li><li>如果资源可以复用（未修改），直接返回304，由handlerAdaptor提供服务</li><li>执行前置拦截器interceptor，返回false不允许往下执行</li><li>由handlerAdaptor执行handler的逻辑并返回modelAndView  </li><li>执行后置拦截器interceptor</li><li>根据modelAndView或者执行期间捕获的exception处理最终的响应</li></ol><blockquote><p>spring的MVC常用的配置，默认由org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration提供<br>如静态资源、拦截器、跨域请求、@RequestMapping对应的方法等等。。。</p></blockquote><h2 id="代码流程-1"><a href="#代码流程-1" class="headerlink" title="代码流程"></a>代码流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// servlet最终会调用的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      HttpServletRequest processedRequest = request;</span><br><span class="line">      HandlerExecutionChain mappedHandler = <span class="keyword">null</span>; <span class="comment">// 本次请求request的处理器，包含了拦截器</span></span><br><span class="line">      ...</span><br><span class="line">      ModelAndView mv = <span class="keyword">null</span>; <span class="comment">//处理结果</span></span><br><span class="line">      Exception dispatchException = <span class="keyword">null</span>; <span class="comment">// 处理遇到的异常</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// @RequestMapping：默认由RequestMappingHandlerMapping提供handler=org.springframework.web.method.HandlerMethod</span></span><br><span class="line">         mappedHandler = getHandler(processedRequest);</span><br><span class="line">         <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 404处理 </span></span><br><span class="line">            noHandlerFound(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取执行handler的适配器。</span></span><br><span class="line">         <span class="comment">// @RequestMapping，默认由org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter提供执行服务</span></span><br><span class="line">         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 304。资源复用。</span></span><br><span class="line">         String method = request.getMethod();</span><br><span class="line">         <span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">         <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(ha.getLastModified(request, mappedHandler.getHandler())) &amp;&amp; isGet) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 调用拦截器pre的方法</span></span><br><span class="line">         <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          @RequestMapping方法的执行逻辑：     </span></span><br><span class="line"><span class="comment">          RequestMappingHandlerAdapter执行HandlerMethod时，会通过ServletInvocableHandlerMethod执行HandlerMethod中的方法</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 调用后置拦截器</span></span><br><span class="line">         mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         dispatchException = ex;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">         dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理最终的结果，异常和结果都用同一个方法</span></span><br><span class="line">      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="requestmapping方法提供者-requestmappinghandlermapping"></span><h2 id="RequestMapping方法提供者-RequestMappingHandlerMapping"><a href="#RequestMapping方法提供者-RequestMappingHandlerMapping" class="headerlink" title="@RequestMapping方法提供者-RequestMappingHandlerMapping"></a>@RequestMapping方法提供者-RequestMappingHandlerMapping</h2><p>RequestMappingHandlerMapping在初始化时会把所有带有@Controller注解或者@RequestMapping注解的bean解析<br>然后把@RequestMapping对应的url和对应的方法(bean和method)绑定到MappingRegistry(MultiValueMap类型)中：key为uri，value为多个HandlerMethod<br>dispatcherServlet在获取对应的Handler时，根据UrlPathHelper从request获取请求的uri(去除contextPath和双斜杠之后的uri)。在根据uri从MappingRegistry获取对应的handlerMethod(可能为0个,1个，多个)<br>如果获取不到可能是restful的接口，则需要遍历所有的接口。根据AntPathMatcher进行挨个匹配，直到循环完所有的mapping<br>此时handlerMethod可能为空，为1个，甚至为多个，然后再从中选取最优的</p><ul><li><p>@RequestMapping注册的逻辑  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MappingRegistry</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//mapping为@RequestMapping的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HandlerMethod handlerMethod = createHandlerMethod(handler, method);<span class="comment">// HandlerMethod包含了bean和对应的method</span></span><br><span class="line">            validateMethodMapping(handlerMethod, mapping);<span class="comment">// 验证@RequestMapping注解不能出现重复的值</span></span><br><span class="line">            <span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; directUrls = getDirectUrls(mapping);<span class="comment">// 获取@RequestMapping的url（direct：不包含&quot;*&quot;、&quot;?&quot;、&quot;&#123;&quot;、&quot;&#125;&quot;符合的url）</span></span><br><span class="line">            <span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line">                <span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 处理跨域@CrossOrigin的注解</span></span><br><span class="line">            CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line">            <span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);<span class="comment">// 保存跨域的注解，后期由CorsInterceptor来处理跨域的信息</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据请求获取对应的@RequestMapping  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHandlerMethodMapping</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractHandlerMapping</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 根据uri直接获取</span></span><br><span class="line">        List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">        <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// uri匹配的mapping，需要判断其他的配置是否匹配，比如@RequestMapping(params = &quot;abc=123&quot;, method = RequestMethod.POST)</span></span><br><span class="line">            addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为空可能为restful风格，需要遍历所有的接口 原文：No choice but to go through all mappings...</span></span><br><span class="line">        <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">            addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">            Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 获取最优的接口</span></span><br><span class="line">            <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));<span class="comment">// 选取最优逻辑的排序器</span></span><br><span class="line">                matches.sort(comparator);</span><br><span class="line">                bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 如果是预检请求直接返回一个预检的handler代表已匹配，但是预检请求并不会真正的执行，注意：只有大于2个handler时才会返回，这是因为预检请求和真实请求可能header或参数不一样。无法精确匹配handler</span></span><br><span class="line">                <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (comparator.compare(bestMatch, matches.get(<span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 选择不了最优的接口直接抛异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><span id="多个-requestmapping时选择最优的匹配"></span><h2 id="多个-RequestMapping时选择最优的匹配"><a href="#多个-RequestMapping时选择最优的匹配" class="headerlink" title="多个@RequestMapping时选择最优的匹配"></a>多个@RequestMapping时选择最优的匹配</h2><p>如以下几个配置</p><ol><li><code>@RequestMapping(value = &quot;*&quot;, headers = &quot;content-type=text/*&quot;, method = RequestMethod.POST)</code>  </li><li><code>@RequestMapping(value = &quot;/abc/*&quot;, method = RequestMethod.GET)</code></li><li><code>@RequestMapping(value = &quot;/abc/&#123;id&#125;&quot;, params = &quot;abc=123&quot;)</code></li><li><code>@RequestMapping(value = &quot;/abc/def&quot;)</code></li></ol><p>如果请求地址为 /abc/def,那么会直接匹配第四个注解。</p><blockquote><p>如果url无占位符号、通用符号，那么会根据url进行直接匹配</p></blockquote><p>如果请求地址为 /abc/123?abc=123，则都会匹配前三个的RequestMapping，那么是如何选取最优的呢？</p><ol><li>如果request请求是head方法，则优先匹配方法一致的<br>method = RequestMethod.HEAD</li><li>然后再次匹配pattern精度比较高的</li><li>匹配params精度比较高的<br>params = &quot;abc=123&quot;</li><li>匹配headers精度比较高的<br>headers = &quot;content-type=text/*&quot;</li><li>consumers精度比较高的</li><li>produces精度比较高的</li><li>method精度比较高的</li></ol><p>源码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingInfo</span> <span class="keyword">implements</span> <span class="title">RequestCondition</span>&lt;<span class="title">RequestMappingInfo</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(RequestMappingInfo other, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="comment">// Automatic vs explicit HTTP HEAD mapping</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.HEAD.matches(request.getMethod())) &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.methodsCondition.compareTo(other.getMethodsCondition(), request);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">this</span>.patternsCondition.compareTo(other.getPatternsCondition(), request);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">this</span>.paramsCondition.compareTo(other.getParamsCondition(), request);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">this</span>.headersCondition.compareTo(other.getHeadersCondition(), request);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">this</span>.consumesCondition.compareTo(other.getConsumesCondition(), request);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">this</span>.producesCondition.compareTo(other.getProducesCondition(), request);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Implicit (no method) vs explicit HTTP method mappings</span></span><br><span class="line">        result = <span class="keyword">this</span>.methodsCondition.compareTo(other.getMethodsCondition(), request);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">this</span>.customConditionHolder.compareTo(other.customConditionHolder, request);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="requestmappinghandleradapter"></span><h2 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h2><p>@RequestMapping对应的方法最终会封装成一个HandlerMethod，由RequestMappingHandlerAdapter执行HandlerMethod<br>但在RequestMappingHandlerAdapter内部，把执行权交给了ServletInvocableHandlerMethod，该类继承自HandlerMethod</p><span id="servletinvocablehandlermethod"></span><h3 id="ServletInvocableHandlerMethod"><a href="#ServletInvocableHandlerMethod" class="headerlink" title="ServletInvocableHandlerMethod"></a><span id="ServletInvocableHandlerMethod">ServletInvocableHandlerMethod</span></h3><ol><li>ServletInvocableHandlerMethod调用之前会组装(bind)参数    </li><li>bind参数需要获取方法参数上的参数名,默认提供者：DefaultParameterNameDiscoverer    </li><li>以及根据参数名从request获取对应的value，默认提供者：RequestMappingHandlerAdapter#getDefaultArgumentResolvers。<strong>ps:通过实现WebMvcConfigurer#addArgumentResolvers，可自定义参数解析器</strong>  </li><li>组装好参数之后ServletInvocableHandlerMethod通过反射调用真正的@RequestMapping对应的方法  </li><li>调用出现异常会把异常抛出去，由<a href="#dispatcher%E9%94%99%E8%AF%AF%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">dispatcher处理</a>  </li><li>调用方法后返回的结果会通过HandlerMethodReturnValueHandler处理响应，默认提供者：RequestMappingHandlerAdapter#getDefaultReturnValueHandlers。<strong>ps:通过实现WebMvcConfigurer#addReturnValueHandlers可自定义返回值处理</strong>  </li><li>returnValue处理完之后动态的返回modelAndView<strong>ps:如果是@ResponseBody则返回null，因为返回值已经在内部处理了，其他的如重定向、重转发、返回页面渲染等通过modelAndView完成</strong></li></ol><h1 id="dispatcher错误执行流程"><a href="#dispatcher错误执行流程" class="headerlink" title="dispatcher错误执行流程"></a><span id='dispatcher错误执行流程'>dispatcher错误执行流程</span></h1><p>常见的错误有</p><ol><li>404</li><li>@RequestMapping请求方式不对。</li><li>参数转换异常</li><li>参数校验失败</li><li><strong>逻辑处理异常</strong></li><li>...等其他的不常见异常</li></ol><h2 id="大体流程-2"><a href="#大体流程-2" class="headerlink" title="大体流程"></a>大体流程</h2><ol><li><p>dispatcherServlet遇到异常会通过内部的方法processHandlerException遍历HandlerExceptionResolver的实现类处理异常</p></li><li><p>HandlerExceptionResolver的默认提供者<code>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#addDefaultHandlerExceptionResolvers</code><br>@ExceptionHandler的注解，由ExceptionHandlerExceptionResolver处理  </p></li><li><p>ExceptionHandlerExceptionResolve处理异常时：通过异常的类型找出能处理的方法  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   如果handler不为空代表在执行handler期间遇到的异常 ，优先从当前handler找出能处理对应异常的@ExceptionHandler注解方法  </span><br><span class="line">   如果handler为空或handler找不到能处理异常的方法，则从全局@ControllerAdvice注解的类中找出能处理对应异常的@ExceptionHandler注解方法  </span><br><span class="line">1. 获取然后包装成[ServletInvocableHandlerMethod](#ServletInvocableHandlerMethod)，并把执行权交给它</span><br><span class="line">1. 如果ServletInvocableHandlerMethod在执行异常处理期间遇到了异常则```return null```,交由下一个HandlerExceptionResolver的实现类接着处理原先的异常 </span><br><span class="line"></span><br><span class="line">## 代码流程</span><br><span class="line"></span><br><span class="line">1. dispatcherServlet遇到异常会通过内部的方法processHandlerException遍历HandlerExceptionResolver的实现类处理异常  </span><br><span class="line">   @ExceptionHandler的注解，由ExceptionHandlerExceptionResolver处理  </span><br><span class="line">```java</span><br><span class="line">public class DispatcherServlet extends FrameworkServlet &#123;</span><br><span class="line">    ...</span><br><span class="line">    protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        ...</span><br><span class="line">ModelAndView exMv = null;</span><br><span class="line">if (this.handlerExceptionResolvers != null) &#123;</span><br><span class="line">    // 遍历HandlerExceptionResolver的实现类处理异常</span><br><span class="line">for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) &#123;</span><br><span class="line">exMv = resolver.resolveException(request, response, handler, ex);</span><br><span class="line">if (exMv != null) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (exMv != null) &#123;</span><br><span class="line">if (exMv.isEmpty()) &#123;// @ResponseBody已处理</span><br><span class="line">request.setAttribute(EXCEPTION_ATTRIBUTE, ex);</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">if (!exMv.hasView()) &#123;// 重定向、重转发、页面渲染等</span><br><span class="line">String defaultViewName = getDefaultViewName(request);</span><br><span class="line">if (defaultViewName != null) &#123;</span><br><span class="line">exMv.setViewName(defaultViewName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">return exMv;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ExceptionHandlerExceptionResolve处理异常时：通过异常的类型找出能处理的方法<br>获取然后包装成<a href="#ServletInvocableHandlerMethod">ServletInvocableHandlerMethod</a>，并把执行权交给它</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandlerExceptionResolver</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMethodExceptionResolver</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">doResolveHandlerMethodException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod, Exception exception)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 通过异常的类型找出能处理的方法</span></span><br><span class="line">         ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);</span><br><span class="line">         <span class="keyword">if</span> (exceptionHandlerMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            exceptionHandlerMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">         ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            Throwable cause = exception.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable invocationEx) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 如果已经对response做过处理</span></span><br><span class="line">         <span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView();</span><br><span class="line">         &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 找出能处理对应异常的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> ServletInvocableHandlerMethod <span class="title">getExceptionHandlerMethod</span><span class="params">(HandlerMethod handlerMethod, Exception exception)</span> </span>&#123;</span><br><span class="line">      Class&lt;?&gt; handlerType = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 如果handler不为空代表在执行handler期间遇到的异常 ，优先从当前handler找出能处理对应异常的@ExceptionHandler注解方法</span></span><br><span class="line">      <span class="keyword">if</span> (handlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">         handlerType = handlerMethod.getBeanType();</span><br><span class="line">         Method method = <span class="keyword">new</span> ExceptionHandlerMethodResolver(handlerType).resolveMethod(exception);</span><br><span class="line">         <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServletInvocableHandlerMethod(handlerMethod.getBean(), method);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (Proxy.isProxyClass(handlerType)) &#123;</span><br><span class="line">            handlerType = AopUtils.getTargetClass(handlerMethod.getBean());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果handler为空或handler找不到能处理异常的方法，则从全局@ControllerAdvice注解的类中找出能处理对应异常的@ExceptionHandler注解方法</span></span><br><span class="line">      <span class="comment">// 具体获取@ControllerAdvice对应的方法可参考ExceptionHandlerExceptionResolver#initExceptionHandlerAdviceCache</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; entry : <span class="keyword">this</span>.exceptionHandlerAdviceCache.entrySet()) &#123;</span><br><span class="line">         ControllerAdviceBean advice = entry.getKey();</span><br><span class="line">         <span class="keyword">if</span> (advice.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">            ExceptionHandlerMethodResolver resolver = entry.getValue();</span><br><span class="line">            Method method = resolver.resolveMethod(exception);</span><br><span class="line">            <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> ServletInvocableHandlerMethod(advice.resolveBean(), method);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ExceptionHandlerExceptionResolver是@ExceptionHandler注解的实现。通过异常的类型优先从handler对应的bean里面寻找@ExceptionHandler<br>如果找不到处理异常的方法或者handler为空，则从全局@ControllerAdvice的bean里面寻找对应的方法<br>获取然后包装成<a href="#ServletInvocableHandlerMethod">ServletInvocableHandlerMethod</a>，并把执行权交给它</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;spring的MVC是遵循着servlet规范的。&lt;/p&gt;
&lt;h1 id=&quot;servlet规范&quot;&gt;&lt;a href=&quot;#servlet规范&quot; class=&quot;headerlink&quot; title=&quot;servlet规范&quot;&gt;&lt;/a&gt;servlet规范&lt;/h1&gt;&lt;p&gt;当Http服务器接</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>springMvc统一异常处理</title>
    <link href="https://dongmaxiang.vercel.app/posts/springmvc%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://dongmaxiang.vercel.app/posts/springmvc%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2021-08-29T21:00:06.000Z</published>
    <updated>2021-08-29T21:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>先配置处理异常的类，然后在分析源码</p><h1 id="mvc统一处理异常的实现"><a href="#mvc统一处理异常的实现" class="headerlink" title="mvc统一处理异常的实现"></a>mvc统一处理异常的实现</h1><p>常见的异常如下，基本都是参数校验的异常。参数校验需要配合jsr303的注解校验哦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">// 只有web容器才会初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本项目自定义的业务异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BizException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">exceptionHandler</span><span class="params">(BizException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;全局BizException异常params:&quot;</span> + WebUtils.getPrettyParam(request), e);</span><br><span class="line">        <span class="keyword">return</span> Result.toThis(e.getResultEnum(), e.getMessage(), e.getData());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(RpcException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handleException(RpcException e) &#123;</span><br><span class="line">        <span class="comment">// todo 需要系统通知</span></span><br><span class="line">        log.info(<span class="string">&quot;全局异常--dubbo调用异常RPC_INVOKE_ERROR:&quot;</span>, e);</span><br><span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> RemotingException) &#123;</span><br><span class="line">            <span class="comment">// dubbo 提供者 不在线</span></span><br><span class="line">            <span class="keyword">return</span> Result.toThis(ResultEnum.RPC_INVOKE_ERROR, <span class="string">&quot;服务提供者出现了问题\n&quot;</span> + e.getCause().getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dubbo 未找到提供者</span></span><br><span class="line">        <span class="keyword">return</span> Result.toThis(ResultEnum.RPC_INVOKE_ERROR, <span class="string">&quot;dubbo调用异常\n&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数校验异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">exceptionHandler</span><span class="params">(HttpMessageNotReadableException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;全局方法参数校验异常HttpMessageNotReadableException,params:&quot;</span> + WebUtils.getPrettyParam(request), e);</span><br><span class="line">        <span class="keyword">if</span> (e.getRootCause() <span class="keyword">instanceof</span> EnumDeserializeException) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.toThis(ResultEnum.ERROR_ALERT, e.getRootCause().getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.toThis(ResultEnum.ERROR_ALERT, <span class="string">&quot;参数读取失败:&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数校验异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@code</span> 直接在方法参数上进行校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ConstraintViolationException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">exceptionHandler</span><span class="params">(ConstraintViolationException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;全局方法参数校验异常ConstraintViolationException,params:&quot;</span> + WebUtils.getPrettyParam(request), e);</span><br><span class="line"></span><br><span class="line">        String message = e.getConstraintViolations().stream()</span><br><span class="line">                .map(ConstraintViolation::getMessage)</span><br><span class="line">                .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.toThis(ResultEnum.ERROR_ALERT, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理所有接口数据验证异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@code</span> <span class="doctag">@RequestBody</span> 里面的字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException e, HttpServletRequest request) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;全局方法参数校验异常MethodArgumentNotValidException,params:&quot;</span> + WebUtils.getPrettyParam(request), e);</span><br><span class="line"></span><br><span class="line">        List&lt;ObjectError&gt; errors = e.getBindingResult().getAllErrors();</span><br><span class="line">        String msg = errors.stream()</span><br><span class="line">                .map(DefaultMessageSourceResolvable::getDefaultMessage)</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> Result.toThis(ResultEnum.ERROR_ALERT, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数验证异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@code</span> <span class="doctag">@ModelAttribute</span> 里面的字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BindException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">validateExp</span><span class="params">(BindException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;全局方法参数校验异常BindException,params:&quot;</span> + WebUtils.getPrettyParam(request), e);</span><br><span class="line">        String sb = e.getAllErrors().stream()</span><br><span class="line">                .map(error -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Object source = FieldUtils.readField(error, <span class="string">&quot;source&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">if</span> (source <span class="keyword">instanceof</span> TypeMismatchException) &#123;</span><br><span class="line">                            <span class="keyword">return</span> getMessage((TypeMismatchException) source);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> error.getDefaultMessage();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException ignored) &#123;</span><br><span class="line">                        <span class="keyword">return</span> error.getDefaultMessage();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).distinct()</span><br><span class="line">                .collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.toThis(ResultEnum.ERROR_ALERT, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数验证异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@code</span> <span class="doctag">@RequestParam</span>(required = true)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MissingServletRequestParameterException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">validateExp</span><span class="params">(MissingServletRequestParameterException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;全局方法参数校验异常MissingServletRequestParameterException,params:&quot;</span> + WebUtils.getPrettyParam(request), e);</span><br><span class="line">        log.info(<span class="string">&quot;类型&#123;&#125;, 字段&#123;&#125;, 不能为空，必填项&quot;</span>, e.getParameterType(), e.getParameterName());</span><br><span class="line">        <span class="keyword">return</span> Result.toThis(ResultEnum.ERROR_ALERT, e.getParameterName() + <span class="string">&quot;不能为空，必填项！类型：&quot;</span> + e.getParameterType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数验证异常 -- 对于springMVC接受参数类型转化问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentTypeMismatchException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">validateExp</span><span class="params">(MethodArgumentTypeMismatchException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;全局方法参数校验异常MethodArgumentTypeMismatchException,params:&quot;</span> + WebUtils.getPrettyParam(request), e);</span><br><span class="line">        String message = getMessage(e);</span><br><span class="line">        log.info(message);</span><br><span class="line">        <span class="keyword">return</span> Result.toThis(ResultEnum.ERROR_ALERT, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getMessage</span><span class="params">(TypeMismatchException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;参数：&quot;</span> + e.getPropertyName() + <span class="string">&quot;,值：&quot;</span> + e.getValue() + <span class="string">&quot;，不能转成&quot;</span> + e.getRequiredType() + <span class="string">&quot;类型！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局异常管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RestControllerAdvice</span></span><br><span class="line">    <span class="meta">@ConditionalOnWebApplication</span> <span class="comment">// 当前是web容器才会初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理所有不可知的异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@ExceptionHandler(Throwable.class)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">handleException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            log.error(<span class="string">&quot;全局系统异常捕获&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">            String stackStr = Arrays.stream(ObjectUtils.defaultIfNull(e.getStackTrace(), <span class="keyword">new</span> StackTraceElement[<span class="number">0</span>]))</span><br><span class="line">                    .filter(t -&gt; t.getClassName().startsWith(<span class="string">&quot;com&quot;</span>) || t.getClassName().startsWith(<span class="string">&quot;cn&quot;</span>))</span><br><span class="line">                    .filter(t -&gt; t.getLineNumber() &gt; <span class="number">0</span>)</span><br><span class="line">                    .map(t -&gt; t.getClassName() + <span class="string">&quot;.&quot;</span> + t.getMethodName() + <span class="string">&quot;:&quot;</span> + t.getLineNumber())</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">            stackStr = e.getClass() + <span class="string">&quot;:&quot;</span> + e.getMessage() + <span class="string">&quot;\n&quot;</span> + stackStr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Result.toThis(ResultEnum.SYSTEM_ERROR, ResultEnum.SYSTEM_ERROR.getMessage(), stackStr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不支持的请求-post-get-put-delete</span></span><br><span class="line">        <span class="meta">@ExceptionHandler(HttpRequestMethodNotSupportedException.class)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">validateExp</span><span class="params">(HttpRequestMethodNotSupportedException ex, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            String supportList = Arrays.toString(ex.getSupportedMethods());</span><br><span class="line">            log.warn(<span class="string">&quot;不支持的请求，uri:&#123;&#125;,method:&#123;&#125;,支持的请求:&#123;&#125;&quot;</span>, request.getRequestURI(), method, supportList);</span><br><span class="line">            <span class="keyword">return</span> Result.toThis(ResultEnum.SYSTEM_ERROR, <span class="string">&quot;不支持&quot;</span> + method + <span class="string">&quot;请求，支持的请求：&quot;</span> + supportList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不支持的请求-post-get-put-delete</span></span><br><span class="line">        <span class="meta">@ExceptionHandler(NoHandlerFoundException.class)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">validateExp</span><span class="params">(NoHandlerFoundException ex, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;404，访问的接口地址:&#123;&#125;,请求头:&#123;&#125;&quot;</span>, request.getRequestURI(), WebUtils.getPrettyHeaders(request));</span><br><span class="line">            <span class="keyword">return</span> Result.toThis(ResultEnum.SYSTEM_ERROR, <span class="string">&quot;访问接口不存在，联系开发人员&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>咱们一起来看看他是怎么生效的。为什么还区分全局和非全局？<a href="/posts/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B#%E6%80%BB%E7%BB%93">springMvc异常时的执行流程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先配置处理异常的类，然后在分析源码&lt;/p&gt;
&lt;h1 id=&quot;mvc统一处理异常的实现&quot;&gt;&lt;a href=&quot;#mvc统一处理异常的实现&quot; class=&quot;headerlink&quot; title=&quot;mvc统一处理异常的实现&quot;&gt;&lt;/a&gt;mvc统一处理异常的实现&lt;/h1&gt;&lt;p&gt;常见的异常</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
    <category term="代码规范" scheme="https://dongmaxiang.vercel.app/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    <category term="异常拦截" scheme="https://dongmaxiang.vercel.app/tags/%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>spring-spi</title>
    <link href="https://dongmaxiang.vercel.app/posts/spring-spi/"/>
    <id>https://dongmaxiang.vercel.app/posts/spring-spi/</id>
    <published>2021-08-23T01:41:55.000Z</published>
    <updated>2021-08-23T01:41:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>java有<a href="/posts/java-spi">java的spi</a><br>dubbo有<a href="/posts/dubbo-spi">dubbo的spi</a><br>spring也有自己的spi  </p><p>spring spi 入口类为<code>org.springframework.core.io.support.SpringFactoriesLoader</code></p><p>springBoot main启动时就用到了  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Context initialize 监听器</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 所有的ApplicationListener</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    <span class="comment">// SpringFactoriesLoader为spring spi</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在所有的classPath中寻找资源为<code>META-INF/spring.factories</code>的文件。<br>里面的格式为key=value[,value,value]</p><blockquote><p>key为class全类名，value为对应实现类的全类名</p></blockquote><p>通过SpringFactoriesLoader 加载文件的内容。使用时通过<code>SpringFactoriesLoader.loadFactoryNames(type, classLoader)</code>来获取对应的value，然后在通过反射实例化</p><h1 id="源码赏析"><a href="#源码赏析" class="headerlink" title="源码赏析"></a>源码赏析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringFactoriesLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过classLoader获取所有的资源，并加载本地缓存里面</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java有&lt;a href=&quot;/posts/java-spi&quot;&gt;java的spi&lt;/a&gt;&lt;br&gt;dubbo有&lt;a href=&quot;/posts/dubbo-spi&quot;&gt;dubbo的spi&lt;/a&gt;&lt;br&gt;spring也有自己的spi  &lt;/p&gt;
&lt;p&gt;spring spi 入口类为&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>MybatisPlus语法糖的校验</title>
    <link href="https://dongmaxiang.vercel.app/posts/mybatisplus%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E6%A0%A1%E9%AA%8C/"/>
    <id>https://dongmaxiang.vercel.app/posts/mybatisplus%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E6%A0%A1%E9%AA%8C/</id>
    <published>2021-08-22T01:43:20.000Z</published>
    <updated>2021-08-22T01:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>mybatisPlus大大的提高了我们开发的速度。因为不需要关心sql。建立好的对象通过mybatisPlus语法糖来拼接sql。但是坏处是语法糖不好统一维护。到处都是语法糖。所以我们规定建立一层Dao，dao层负责统一管理sql。因为要去除xml里面的sql。写sql容易出问题（字符串容易写错，不同数据库还需要关心不同的特性）<br>建议Dao统一<a href="/posts/%E9%87%8D%E6%96%B0%E5%8A%A0%E8%A3%85mybatisplus#5%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88%E4%BD%BFapi%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%AE%89%E5%85%A8">继承此BaseDao</a>    </p><blockquote><p>一个表对应一个实体、一个mapper，一个Dao<br>Dao继承BaseDao，需要实体继承BaseDomain,mapper继承CustomBaseMapper<br>如果实体不继承baseDomain，mapper不继承CustomBaseMapper，则dao也无法继承BaseDao</p></blockquote><p><strong>如何有效(强制)的避免以下相同拼接的sql出现在多处？</strong><br>例如以下的sql拼接语法糖  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DemoService &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DemoDao demoDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">this</span>.demoDao.lambdaQuery()</span><br><span class="line">            .eq(<span class="string">&quot;Demo.field1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">            .eq(<span class="string">&quot;Demo.field2&quot;</span>, <span class="number">3</span>)</span><br><span class="line">            .like(<span class="string">&quot;Demo.field3&quot;</span>, <span class="string">&quot;like&quot;</span>)</span><br><span class="line">            .list();</span><br><span class="line">        <span class="comment">// 其他业务逻辑</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            List&lt;Object&gt; list = <span class="keyword">this</span>.demoDao.lambdaQuery()</span><br><span class="line">                .eq(<span class="string">&quot;Demo.field1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                .eq(<span class="string">&quot;Demo.field2&quot;</span>, <span class="number">3</span>)</span><br><span class="line">                .like(<span class="string">&quot;Demo.field3&quot;</span>, <span class="string">&quot;like&quot;</span>)</span><br><span class="line">                .list();</span><br><span class="line">            <span class="comment">// 其他业务逻辑</span></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们可以定制规范来约束大家把.点.点.的sql拼接的语法封装成一个方法。但是在人员越来越多的情况下，没有强制的规范约束会变得越来越乱。</p><h2 id="如何强制约束"><a href="#如何强制约束" class="headerlink" title="如何强制约束"></a>如何强制约束</h2><ol><li>通过编写maven的编译插件，检测代码是否有冗余的，或者sql拼接出现在非Dao层中直接编译不通过，予以警告。但是由于学习成本比较大，编译平台过多，就放弃了(有心者可以按照此方法来实现，欢迎交流探讨)。  </li><li>通过Java的调用栈来判断是谁在调用(本文的实现)</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过看源码，语法糖拼接sql之前必定会<code>new  com.baomidou.mybatisplus.core.conditions.Wrapper</code>该类是语法糖对象顶层的超类(abstract class)。<br>通过切入wrapper的构造方法，判断是谁new的，如果调用者是别的模块，比如在service层中new的Wrapper，则直接报异常。如果是在dao层new的，则允许通过。<br>我们用javassist工具来切入com.baomidou.mybatisplus.core.conditions.Wrapper 的构造方法。</p><h2 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h2><p>spring factories 配置容器启动的监听类</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">com.DaoVerify</span></span><br></pre></td></tr></table></figure><p>factories可参考<a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">springBoot容器启动流程</a></p><p>ENV可参考 <a href="/posts/%E8%8E%B7%E5%8F%96spring%E5%90%AF%E5%8A%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB">获取spring启动环境的工具类</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoVerify</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationPreparedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationPreparedEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;begin Weaving for runtime check&quot;</span>);</span><br><span class="line">        <span class="comment">// test环境肯定都是按照规范来的,正式环境不做切入。提高性能。</span></span><br><span class="line">        <span class="keyword">if</span> (ENV.isProd()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Non-dev does not check&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wrapper超类实现的接口的classLoader</span></span><br><span class="line">        <span class="comment">// 有用到restartDevTools或者spring-boot-maven-plugins，classLoader都会不同，用超类的classLoader准没错</span></span><br><span class="line">        ClassLoader loader = ISqlSegment.class.getClassLoader();</span><br><span class="line">        log.info(<span class="string">&quot;begin Weaving into  Dao for verify caller ，verify package name :dao ,classLoader:&#123;&#125;&quot;</span>, loader);</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> LoaderClassPath(loader));</span><br><span class="line">        CtClass wrapper = pool.get(<span class="string">&quot;com.baomidou.mybatisplus.core.conditions.Wrapper&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果已经toClass，则是冻结的状态，spring多容器下此方法肯定会多次调用</span></span><br><span class="line">        <span class="keyword">if</span> (wrapper.isFrozen()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;isFrozen&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用栈字符串拼接，用来做错误提示</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">// 整个的调用栈</span></span><br><span class="line">            StackTraceElement[] ste = (<span class="keyword">new</span> Throwable()).getStackTrace();</span><br><span class="line">            <span class="comment">// Dao层的调用次数</span></span><br><span class="line">            <span class="keyword">int</span> daoCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ste.length; ++i) &#123;</span><br><span class="line">                StackTraceElement s = ste[i];</span><br><span class="line">                <span class="comment">// 这个是mybatisPlus源码中new的，如果是此类，我们不做校验</span></span><br><span class="line">                <span class="keyword">if</span> (s.getClassName().contains(<span class="string">&quot;com.baomidou.mybatisplus.core.toolkit.Wrappers$EmptyWrapper&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String className = s.getClassName();</span><br><span class="line">                sb.append(className).append(<span class="string">&quot;:&quot;</span>).append(s.getMethodName()).append(<span class="string">&quot;:&quot;</span>).append(s.getLineNumber()).append(<span class="string">&quot;\\\\n&quot;</span>);</span><br><span class="line">                <span class="comment">// s.getLineNumber() &gt; 0: 忽略动态代理的调用栈，动态代理的lineNumber = -1</span></span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(<span class="string">&quot;你的项目的Dao层的包名&quot;</span>) &amp;&amp; !className.contains(<span class="string">&quot;BaseDao&quot;</span>) &amp;&amp; s.getLineNumber() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    daoCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有Dao层调用，而是其他层调用，则直接报错，起到了强制校验的功能</span></span><br><span class="line">            <span class="keyword">if</span> (daoCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 提示并携带stacktrace</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;请把sql拼接的条件写在Dao中\n&quot;</span> + sb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wrapper.getConstructors()[<span class="number">0</span>].insertBeforeBody(<span class="string">&quot;需要把上面括号中的代码粘贴到此处，为了读者阅读方便就给提到了上面。&quot;</span>);</span><br><span class="line">        <span class="comment">// 加载class，一但加载之后本工具类，不能再次修改</span></span><br><span class="line">        wrapper.toClass(loader, <span class="keyword">null</span>);</span><br><span class="line">        log.info(<span class="string">&quot;weaving succeed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>配置好容器启动监听之后，赶在语法糖超类加载之前，利用javassist修改字节码工具。修改语法糖超类的构造方法。<br>构造方法执行的时候我们通过(new Throwable)查看java的stackTrace调用栈，如果没有我们的Dao层调用的话，直接抛出异常，这样就起到了强制校验的功能了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;mybatisPlus大大的提高了我们开发的速度。因为不需要关心sql。建立好的对象通过mybatisPlus语法糖来拼接sql。但是坏处是语法糖不好统一维护。到处都是语法糖。
所以我们规定建立一层Dao，dao层负责统一管理sql。因为要去除xml里面的sql。写sql容</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="设计模式" scheme="https://dongmaxiang.vercel.app/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="mybatisPlus" scheme="https://dongmaxiang.vercel.app/tags/mybatisPlus/"/>
    
    <category term="代码规范" scheme="https://dongmaxiang.vercel.app/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring的代码分层校验</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E5%9F%BA%E4%BA%8Espring%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E6%A0%A1%E9%AA%8C/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E5%9F%BA%E4%BA%8Espring%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E6%A0%A1%E9%AA%8C/</id>
    <published>2021-08-22T01:00:38.000Z</published>
    <updated>2021-08-22T01:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的代码分层图"><a href="#常见的代码分层图" class="headerlink" title="常见的代码分层图"></a>常见的代码分层图</h1><p><img src="/img/posts/2021/layer-code.png" alt="代码分层图"></p><h2 id="分层很明确，先说缺点"><a href="#分层很明确，先说缺点" class="headerlink" title="分层很明确，先说缺点"></a>分层很明确，先说缺点</h2><ol><li>service层可以依赖多个dao层<br>一个表肯定对应一个dao。如果一个service直接操作多张表(dao)也没问题，但是有可能所有表的操作都封闭在一个service中。  <ul><li>如果后期维护某一张表的时候你就得需要屡下所有调用此表的service，花费时间不说，还有可能漏掉。</li><li>如果对其中一个表进行别的业务复用的话，则需要把代码抽离出来，并且有可能开发人员不抽离，而是直接copy粘贴，导致代码原来越乱。<blockquote><p>所以建议一个表对应一个dao和一个service，其中service只能操作自己的表(dao)。要是操作其他的表只能依赖其对应的service</p></blockquote></li></ul></li><li>上图没有明确表明哪些是可以互相依赖(service依赖其他service，dao可以依赖其他dao...)，哪些不可以互相依赖。所以我们认为都是可以相互依赖的。互相依赖比较混乱。<blockquote><p>dao专门负责管理sql，如果对一个实体的curd还涉及到另外其他的实体curd。那么这就显然属于业务范畴了，应该放在service。所以在dao这一层。我们不能让他操作多张表(不能有互相依赖)</p></blockquote></li><li>没有强制的依赖校验。如果controller直接引用dao层也可以正常运行。会增加后期维护的困难性</li></ol><h1 id="代码依赖的强制校验"><a href="#代码依赖的强制校验" class="headerlink" title="代码依赖的强制校验"></a>代码依赖的强制校验</h1><p>对于代码依赖校验，按照以上几个点来校验的话</p><ol><li>首先得定义一个dao层，确保一个表的curd的sql不会乱出现别的dao地方。所以用到<a href="/posts/mybatisplus%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E6%A0%A1%E9%AA%8C">mybatisPlus的sql语法糖校验</a>  </li><li>其次不同层有不同的依赖规则。  <ul><li>如controller不能依赖dao，</li><li>service不能依赖其他dao(表)，只能依赖自己的dao</li><li>dao不能有相互依赖。  </li></ul></li></ol><p>不同层有不用的配置,所以我们需要一个可配置的注解</p><h2 id="校验依赖的注解"><a href="#校验依赖的注解" class="headerlink" title="校验依赖的注解"></a>校验依赖的注解</h2><p>此注解只能放在package上。代表对此包以及子包里面spring管理的bean进行校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.PACKAGE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PackageCheck &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前包的校验排除子包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] checkExcludeSubPackages() <span class="keyword">default</span> <span class="string">&quot;config&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不能依赖此包的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] notAllowDependPackageNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须命名正则的规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">mustNamePattern</span><span class="params">()</span> <span class="keyword">default</span> &quot;.*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前包所有的类必须继承的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; classMustExtendClass() <span class="keyword">default</span> Object.class;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclusionClass() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前包所有的类可以相互依赖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">interdependenceOnSamePackage</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前包所有的类依赖的类型有且只能有一个(如果指定的话)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] dependOnly() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解校验的配置"><a href="#注解校验的配置" class="headerlink" title="注解校验的配置"></a>注解校验的配置</h2><ol><li>controller层在controller包结构目录下新建一个packang-info.java。然后用此注解配置校验的内容  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CodeVerify</span>.PackageCheck(classMustExtendClass = BaseController.class <span class="comment">// 所有的controller必须要继承此类，可有可无</span></span><br><span class="line">, mustNamePattern = <span class="string">&quot;.*Controller$&quot;</span> <span class="comment">// controller命名必须匹配该正则</span></span><br><span class="line">, notAllowDependPackageNames = &#123;<span class="string">&quot;mapper层的包名称&quot;</span>, <span class="string">&quot;dao层的包名称&quot;</span>&#125;) <span class="comment">// controller不能直接依赖dao，也不能直接依赖mapper。（只能通过service调用）</span></span><br></pre></td></tr></table></figure></li><li>service层在service包结构目录下新建一个packang-info.java。然后用此注解配置校验的内容  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CodeVerify</span>.PackageCheck(classMustExtendClass = BaseService.class<span class="comment">// 所有的service必须要继承此类，可有可无</span></span><br><span class="line">     , mustNamePattern = <span class="string">&quot;.*Service(Impl)?$&quot;</span><span class="comment">// 该包下spring管理的bean命名必须匹配该正则</span></span><br><span class="line">     , notAllowDependPackageNames = &#123;<span class="string">&quot;mapper层的包名称&quot;</span>&#125; <span class="comment">// 不能直接依赖mapper层，只能通过依赖dao。</span></span><br><span class="line">     , dependOnly = BaseDao.class)<span class="comment">//只能依赖一个Dao，一般都是一个表，一个mapper，一个dao，一个service</span></span><br></pre></td></tr></table></figure></li><li>dao层建议Dao统一<a href="/posts/%E9%87%8D%E6%96%B0%E5%8A%A0%E8%A3%85mybatisplus#5%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88%E4%BD%BFapi%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%AE%89%E5%85%A8">继承此BaseDao</a><br>一个表的所有sql按照规范写在同一个类中<a href="/posts/mybatisplus%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E6%A0%A1%E9%AA%8C">mybatisPlus的sql语法糖强制校验</a>  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CodeVerify</span>.PackageCheck(classMustExtendClass = BaseDAO.class</span><br><span class="line">        , mustNamePattern = <span class="string">&quot;.*Dao$&quot;</span></span><br><span class="line">        , notAllowDependPackageNames = &#123;&#125;<span class="comment">// 如果dao的java代码可以引用service不报错，可以配置不能依赖service包。因为我们项目是分模块，如果用service代码编译器会直接报错，所以写不写都没有必要</span></span><br><span class="line">        , interdependenceOnSamePackage = <span class="keyword">false</span>) <span class="comment">// 不允许有互相依赖，一个dao只能管理自己的表，如果涉及到其他表则应该放在service处理。</span></span><br></pre></td></tr></table></figure><h2 id="开始校验"><a href="#开始校验" class="headerlink" title="开始校验"></a>开始校验</h2><p>待容器启动后，所有bean的依赖的关系已形成，我们就可以校验了。</p><blockquote><p>可以参考<a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">springBoot容器启动流程</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DependCheck</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationStartedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@SneakyThrows</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationStartedEvent event)</span> </span>&#123;</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = event.getApplicationContext().getBeanFactory();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 所有需要校验的包。Package.getPackages()只有对应的package有真正的类才算是真正的一个package，只有Package-info.java是不行的</span></span><br><span class="line">      List&lt;Package&gt; checkPackageList = Arrays.stream(Package.getPackages())</span><br><span class="line">              .filter(t -&gt; t.isAnnotationPresent(PackageCheck.class))<span class="comment">// 把需要校验的过滤出来</span></span><br><span class="line">              .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">      String[] allBeanNames = beanFactory.getBeanDefinitionNames(); <span class="comment">// 获取所有的bean</span></span><br><span class="line"></span><br><span class="line">      List&lt;String&gt; errorMessageList = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">      log.info(<span class="string">&quot;check PackageNames:&#123;&#125;&quot;</span>, checkPackageList);</span><br><span class="line">      <span class="keyword">for</span> (Package checkPackage : checkPackageList) &#123;</span><br><span class="line">         PackageCheck annotation = checkPackage.getAnnotation(PackageCheck.class);</span><br><span class="line">         log.info(<span class="string">&quot;DependCheck starting package:&#123;&#125;, configuration:&#123;&#125;&quot;</span>, checkPackage.getName(), annotation);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 校验的条件</span></span><br><span class="line">         String[] excludeSubPackages = annotation.checkExcludeSubPackages();</span><br><span class="line">         Class&lt;?&gt; mustExtendClass = annotation.classMustExtendClass();</span><br><span class="line">         String mustSuffixName = annotation.mustNamePattern();</span><br><span class="line">         String[] notAllowDependPackageNames = annotation.notAllowDependPackageNames();</span><br><span class="line">         <span class="keyword">boolean</span> interdependenceOnSamePackage = annotation.interdependenceOnSamePackage();</span><br><span class="line">         Class&lt;?&gt;[] dependOnly = annotation.dependOnly();</span><br><span class="line">         Class&lt;?&gt;[] exclusionsClass = annotation.exclusionClass();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         String currentPackage = checkPackage.getName();</span><br><span class="line">         <span class="keyword">for</span> (String beanName : allBeanNames) &#123;</span><br><span class="line">            BeanDefinition mergedBeanDefinition = beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">            String beanClassName = mergedBeanDefinition.getResolvableType().getType().getTypeName();</span><br><span class="line">            <span class="keyword">if</span> (!beanClassName.startsWith(currentPackage)) &#123; <span class="comment">// 只有这个package的包才会校验</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> excludeSubPackage = Arrays.stream(excludeSubPackages)</span><br><span class="line">                    .anyMatch(t -&gt; beanClassName.substring(currentPackage.length()).contains(t)); <span class="comment">// 排除子包的校验，如果有的话</span></span><br><span class="line">            <span class="keyword">if</span> (excludeSubPackage) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; beanClass = Class.forName(beanClassName);</span><br><span class="line">            <span class="keyword">boolean</span> exclusionClass = Arrays.stream(exclusionsClass) <span class="comment">// 排除class的校验，如果有的话</span></span><br><span class="line">                    .anyMatch(beanClass::isAssignableFrom);</span><br><span class="line">            <span class="keyword">if</span> (exclusionClass) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前bean的依赖</span></span><br><span class="line">            String[] beanDependenciesName = beanFactory.getDependenciesForBean(beanName);</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; beanDependenciesClass = Arrays.stream(beanDependenciesName)</span><br><span class="line">                    .map(beanFactory::getMergedBeanDefinition)</span><br><span class="line">                    .map(BeanDefinition::getResolvableType)</span><br><span class="line">                    .map(ResolvableType::getRawClass)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不允许依赖其他的包</span></span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isNotEmpty(notAllowDependPackageNames)) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> match = Arrays.stream(notAllowDependPackageNames)</span><br><span class="line">                       .anyMatch(notAllowDependPackageName -&gt;</span><br><span class="line">                               beanDependenciesClass.stream()</span><br><span class="line">                                       .map(Class::getName)</span><br><span class="line">                                       .anyMatch(className -&gt;</span><br><span class="line">                                               className.startsWith(notAllowDependPackageName)</span><br><span class="line">                                       )</span><br><span class="line">                       );</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                  String msg = MessageFormat.format(</span><br><span class="line">                          <span class="string">&quot;类:&#123;0&#125;，不能依赖&#123;1&#125;包的内容. \n\t目前依赖的有:&#123;2&#125;&quot;</span></span><br><span class="line">                          , beanClassName</span><br><span class="line">                          , Arrays.toString(notAllowDependPackageNames)</span><br><span class="line">                          , Arrays.toString(beanDependenciesName)</span><br><span class="line">                  );</span><br><span class="line">                  errorMessageList.add(<span class="string">&quot;依赖不规范:\n\t&quot;</span> + msg);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不能有相互依赖</span></span><br><span class="line">            <span class="keyword">if</span> (!interdependenceOnSamePackage) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> match = beanDependenciesClass.stream()</span><br><span class="line">                       .map(Class::getName)</span><br><span class="line">                       .anyMatch(dependTypeName -&gt; dependTypeName.startsWith(currentPackage));</span><br><span class="line">               <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                  String msg = MessageFormat.format(</span><br><span class="line">                          <span class="string">&quot;类:&#123;0&#125;，不能依赖同包及子包的类. \n\t目前依赖的有:&#123;1&#125;&quot;</span></span><br><span class="line">                          , beanClassName</span><br><span class="line">                          , Arrays.toString(beanDependenciesName)</span><br><span class="line">                  );</span><br><span class="line">                  errorMessageList.add(<span class="string">&quot;依赖不规范:\n\t&quot;</span> + msg);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 依赖的类型有且只能有一个</span></span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isNotEmpty(dependOnly)) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> match = Arrays.stream(dependOnly)</span><br><span class="line">                       .anyMatch(dependOnlyClass -&gt;</span><br><span class="line">                               beanDependenciesClass.stream()</span><br><span class="line">                                       .filter(dependOnlyClass::isAssignableFrom)</span><br><span class="line">                                       .count() &gt; <span class="number">1</span></span><br><span class="line">                       );</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                  String msg = MessageFormat.format(</span><br><span class="line">                          <span class="string">&quot;类:&#123;0&#125;，依赖的类型有且只能有一个&#123;1&#125;, \n\t目前依赖的有:&#123;2&#125;&quot;</span></span><br><span class="line">                          , beanClassName</span><br><span class="line">                          , Arrays.toString(dependOnly)</span><br><span class="line">                          , Arrays.toString(beanDependenciesName)</span><br><span class="line">                  );</span><br><span class="line">                  errorMessageList.add(<span class="string">&quot;依赖不规范:\n\t&quot;</span> + msg);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> configBean = beanClass.isAnnotationPresent(ConfigurationProperties.class) || beanClass.isAnnotationPresent(Component.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!configBean &amp;&amp; !mustExtendClass.isAssignableFrom(beanClass)) &#123;</span><br><span class="line">               errorMessageList.add(<span class="string">&quot;类继承不规范:\n\t&quot;</span> + beanClassName + <span class="string">&quot;必须继承&quot;</span> + mustExtendClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!configBean &amp;&amp; !beanClassName.matches(mustSuffixName)) &#123;</span><br><span class="line">               errorMessageList.add(<span class="string">&quot;名称不规范:\n\t&quot;</span> + beanClassName + <span class="string">&quot;名称格式必须是:&quot;</span> + mustSuffixName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!errorMessageList.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;代码编写不规范\n&quot;</span> + String.join(<span class="string">&quot;\n&quot;</span>, errorMessageList)) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于每个团队，每个项目工程的规范都不同。所以我们根据注解的配置进行校验。<br>在结合<a href="/posts/mybatisplus%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E6%A0%A1%E9%AA%8C">mybatisPlus语法糖校验</a>，保证sql只允许出现在一处，确保我们的项目curd不会过于混乱。<br>以本文的代码分层为规范的技术思想，不同于DDD领域驱动设计的是：按照本文设计的规范，在不用DDD(领取驱动设计)的前提下，应用过于庞大或复杂的情况时我们还能保证业务代码不会过于臃肿、林乱不堪。</p><p>引用知乎的DDD驱动设计的简介。</p><blockquote><p>DDD解决的问题是单体应用过大过于复杂导致开发团队的成员没有人能够了解业务全貌，换句话说程序的复杂度失控了。比如你有一个方法上千行，肯定难以维护，所以你要拆。但是一个应用你怎么拆？传统的拆分角度的出发点是基于技术，比如三层架构，比如前后分离。但是这样的拆分不能降低业务的复杂度。DDD就是用来划分业务边界的。DDD不是架构思想，是统筹规划软件开发的思想。很多架构模式应用到DDD设计的系统里。其实你用DDD拆分出来的服务用传统的代码组织方式(传统的分层,repository, service, controller)也完全没有问题</p></blockquote><p>DDD就是用来划分业务边界的。但是DDD设计在普通的CURD应用开发中很难运用好，大部分都是分层的设计。但是我们可以吸取DDD的好处，并结合分层设计的思想来处理我们的业务代码<br>所以规范一张表对应一个实体，并且对应一个dao。然后我们保证一个dao只能由一个service操作，换句话说一个service只能操作一个dao，操作其他dao只能依赖其对应的service。<br>那么这种分层方式和DDD领取驱动设计的精髓有相似（重合）之处。在不用学习DDD的前提下还能保证我们的代码不会过于的混乱，也只有这种更精细的分层方式了。</p><blockquote><p>贫血模型：普通bean的一些内置get|set毫无意义，这就叫贫血模型。<br>充血模型：由于DDD的设计思想就是把bean里面塞满各种各样的自身业务逻辑。使此bean所有的操作都能聚合在一个bean(domain)中。这就叫充血模型。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见的代码分层图&quot;&gt;&lt;a href=&quot;#常见的代码分层图&quot; class=&quot;headerlink&quot; title=&quot;常见的代码分层图&quot;&gt;&lt;/a&gt;常见的代码分层图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/img/posts/2021/layer-code.png&quot; alt=</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="设计模式" scheme="https://dongmaxiang.vercel.app/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
    <category term="代码规范" scheme="https://dongmaxiang.vercel.app/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>springBoot容器启动流程</title>
    <link href="https://dongmaxiang.vercel.app/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://dongmaxiang.vercel.app/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2021-08-21T20:15:44.000Z</published>
    <updated>2021-08-21T20:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>main方法启动时，springBoot启动流程的各个生命周期会以事件通知的方式，把事件告知其他程序<br>前期通过<a href="/posts/spring-spi">spring-spi</a>获取所有监听事件的类   </p><ul><li>spring启动的大体流程为以下的几个方法    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventPublishingRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleApplicationEventMulticaster initialMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventPublishingRunListener</span><span class="params">(SpringApplication application, String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过springSPI获取所有的ApplicationListener，并copy到initialMulticaster</span></span><br><span class="line">        <span class="comment">// 如果ApplicationListener是以注解形式使用，非spi配置的。会在[refresh阶段](/posts/springbeanfactory流程解析)扫描所有以注解形式配置的listener</span></span><br><span class="line">        <span class="comment">// 也就是说注解形式配置的listener，监听refresh之前的事件都是伪事件</span></span><br><span class="line">        <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 开始</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationStartingEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 环境准备</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationEnvironmentPreparedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, environment));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     protected void applyInitializers(ConfigurableApplicationContext context) &#123;</span></span><br><span class="line"><span class="comment">         for (ApplicationContextInitializer initializer : getInitializers()) &#123;</span></span><br><span class="line"><span class="comment">             Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</span></span><br><span class="line"><span class="comment">             ApplicationContextInitializer.class);</span></span><br><span class="line"><span class="comment">             Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);</span></span><br><span class="line"><span class="comment">             initializer.initialize(context);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">     &#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepared之前 会调用 mian方法启动的SpringApplication 内置的 initialize,如上面的注释的代码</span></span><br><span class="line">    <span class="comment">// 3 上下文准备</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationContextInitializedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, context));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4 上下文已加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : <span class="keyword">this</span>.application.getListeners()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (listener <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">                ((ApplicationContextAware) listener).setApplicationContext(context);</span><br><span class="line">            &#125;</span><br><span class="line">            context.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationPreparedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, context));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contextLoaded之后 会调用 [context.refresh](/posts/springbeanfactory流程解析)，会实例化所有的bean(单例的、notLazy的)，包括以注解形式配置的listener</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 启动完成</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在refresh阶段后，后续的事件会通过context发出，context持有beanFactory,beanFactory在refresh期间会扫描所有的listener。所以就不能仅仅调用spi配置的listener了</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> ApplicationStartedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, context));</span><br><span class="line">        AvailabilityChangeEvent.publish(context, LivenessState.CORRECT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 运行中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过context发出事件，context持有beanFactory,beanFactory会扫描所有的ApplicationListener。</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> ApplicationReadyEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, context));</span><br><span class="line">        AvailabilityChangeEvent.publish(context, ReadinessState.ACCEPTING_TRAFFIC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p></blockquote><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><span id="1-starting-》applicationstartingevent"></span><h2 id="1-starting-》ApplicationStartingEvent"><a href="#1-starting-》ApplicationStartingEvent" class="headerlink" title="1. starting -》ApplicationStartingEvent"></a>1. starting -》ApplicationStartingEvent</h2><p>正在进行时、代表容器刚开始运行了---发出程序开始事件<br>springDevTools就是用到了此事件，把类加载器给换了一下，起到了热部署的作用，后期咱们会有详细的分析</p><span id="2-environmentprepared-》applicationenvironmentpreparedevent"></span><h2 id="2-environmentPrepared-》ApplicationEnvironmentPreparedEvent"><a href="#2-environmentPrepared-》ApplicationEnvironmentPreparedEvent" class="headerlink" title="2. environmentPrepared -》ApplicationEnvironmentPreparedEvent"></a>2. environmentPrepared -》ApplicationEnvironmentPreparedEvent</h2><p><a href="/posts/%E5%88%86%E6%9E%90spring%E7%9A%84environment%EF%BC%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E5%8A%A0%E8%BD%BD">配置环境变量加载配置文件资源等</a>---发出环境配置已就绪事件<br>nacos和springCloud远程加载配置文件就是用到了此事件，后期咱们会有详细的分析  </p><blockquote><p>事件发出之后，马上就要实例化ApplicationContext了，不同的WebApplicationType，context不同<br><strong>不管什么样的context，都会持有beanFactory,并且都会向beanFactory注册一个非常重要的bean<br>注册代码<code>AnnotationConfigUtils#registerAnnotationConfigProcessors</code><br><a href="/posts/%E8%A7%A3%E6%9E%90spring%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%91beanfactory%E6%B3%A8%E5%86%8Cbean%E7%9A%84">=ConfigurationClassPostProcessor</a>，在<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90#4-%E8%B0%83%E7%94%A8beanfactorypostprocessors">beanFactory执行后置处理</a>时，会调用此类，并扫描所有的bean</strong><br>实例化完后会发布事情通知容器已经实例化，调用ApplicationContextInitializer的initialize</p></blockquote><span id="3-contextprepared-》applicationcontextinitializedevent"></span><h2 id="3-contextPrepared-》ApplicationContextInitializedEvent"><a href="#3-contextPrepared-》ApplicationContextInitializedEvent" class="headerlink" title="3. contextPrepared -》ApplicationContextInitializedEvent"></a>3. contextPrepared -》ApplicationContextInitializedEvent</h2><p>容器准备---发出应用程序上下文初始化事件<br><strong>contextPrepared之后springBoot会把main方法所在的类注册到beanFactory中</strong><br>beanFactory在执行<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90#4-%E8%B0%83%E7%94%A8beanfactorypostprocessors">beanFactory执行后置处理</a>时，会调用<a href="/posts/%E8%A7%A3%E6%9E%90spring%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%91beanfactory%E6%B3%A8%E5%86%8Cbean%E7%9A%84">ConfigurationClassPostProcessor<br>ConfigurationClassPostProcessor通过扫描beanFactory所有注册的bean上的注解继而扫描其他的bean(包)</a></p><span id="4-contextloaded-》applicationpreparedevent"></span><h2 id="4-contextLoaded-》ApplicationPreparedEvent"><a href="#4-contextLoaded-》ApplicationPreparedEvent" class="headerlink" title="4. contextLoaded -》ApplicationPreparedEvent"></a>4. contextLoaded -》ApplicationPreparedEvent</h2><p>容器已加载完毕---发出应用程序已准备就绪事件</p><blockquote><p>contextLoaded之后 会调用 context.refresh，会实例化所有的bean(单例的、notLazy的)<br>refresh阶段比较复杂，基本上都是操作beanFactory完成bean的扫描、组装、初始化等逻辑<br>beanFactory可参考<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90">springBeanFactory流程解析</a></p></blockquote><span id="5-started-》applicationstartedevent"></span><h2 id="5-started-》ApplicationStartedEvent"><a href="#5-started-》ApplicationStartedEvent" class="headerlink" title="5. started -》ApplicationStartedEvent"></a>5. started -》ApplicationStartedEvent</h2><p>发出应用程序已启动事件</p><span id="6-running-》applicationreadyevent"></span><h2 id="6-running-》ApplicationReadyEvent"><a href="#6-running-》ApplicationReadyEvent" class="headerlink" title="6. running -》ApplicationReadyEvent"></a>6. running -》ApplicationReadyEvent</h2><p>运行中---发出程序已做完事件</p><p>--failed -》ApplicationFailedEvent<br>启动失败时的事件处理器，spring默认就是打印日志。<br>我们可以实现此事件的监听，项目启动失败之后直接报警等</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ApplicationContext这个是spring的容器（非常重要），启动的流程基本上都是围绕着他展开。<br>从各个事件的通知事件我们不难看出。从最开始的starting、environmentPrepared都是为applicationContext做准备。根据不同的WebType实例化不同的applicationContext，之后context会持有environment<br>environment包含了所有的配置文件<br>然后再以context为中心进行initialize事件的触发、然后contextPrepared、contextLoaded、context.refresh<br>refresh工作比较复杂也是beanFactory的核心，具体可参考<a href="/posts/springbeanfactory%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90">springBeanFactory流程解析</a>最后在做结尾的工作started和running</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;main方法启动时，springBoot启动流程的各个生命周期会以事件通知的方式，把事件告知其他程序&lt;br&gt;前期通过&lt;a href=&quot;/posts/spring-spi&quot;&gt;spring-spi&lt;/a&gt;获取所有监听事件的类   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;spring启动的大</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>获取spring启动环境的工具类</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E8%8E%B7%E5%8F%96spring%E5%90%AF%E5%8A%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E8%8E%B7%E5%8F%96spring%E5%90%AF%E5%8A%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2021-08-20T23:53:57.000Z</published>
    <updated>2021-08-20T23:53:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="必须用到的枚举工具类"><a href="#必须用到的枚举工具类" class="headerlink" title="必须用到的枚举工具类"></a>必须用到的枚举工具类</h1><ul><li>参考通用枚举的---使用例子一 <a href="/posts/%E9%80%9A%E7%94%A8%E6%9E%9A%E4%B8%BE">通用枚举</a>  </li></ul><span id="定义env枚举"></span><h1 id="定义ENV枚举"><a href="#定义ENV枚举" class="headerlink" title="定义ENV枚举"></a>定义ENV枚举</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ENV</span> <span class="keyword">implements</span> <span class="title">IEnums</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    RELEASE(<span class="string">&quot;正式&quot;</span>, <span class="string">&quot;release&quot;</span>, <span class="string">&quot;prod&quot;</span>),</span><br><span class="line">    PRE(<span class="string">&quot;预发&quot;</span>, <span class="string">&quot;pre&quot;</span>),</span><br><span class="line">    TEST(<span class="string">&quot;测试&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;test1&quot;</span>, <span class="string">&quot;test2&quot;</span>, <span class="string">&quot;test3&quot;</span>),</span><br><span class="line">    DEV(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;dev&quot;</span>),</span><br><span class="line">    LOCAL(<span class="string">&quot;本地&quot;</span>, <span class="string">&quot;local&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] envs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String doc;</span><br><span class="line"></span><br><span class="line">    ENV(String doc, String... envs) &#123;</span><br><span class="line">        <span class="keyword">this</span>.envs = envs;</span><br><span class="line">        <span class="keyword">this</span>.doc = doc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ENV CURRENT_ENV;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCurrentEnv</span><span class="params">(ENV env)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此变量不可随意改变，如有程序错乱，环境不一致就直接退出程序，避免后续的问题</span></span><br><span class="line">        <span class="keyword">if</span> (CURRENT_ENV != <span class="keyword">null</span> &amp;&amp; CURRENT_ENV != env) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ENV只能赋值一次，请查看spring容器配置是否正确&quot;</span>);</span><br><span class="line">            System.err.println(<span class="string">&quot;ENV只能赋值一次，请查看spring容器配置是否正确&quot;</span>);</span><br><span class="line">            log.error(<span class="string">&quot;ENV只能赋值一次，请查看spring容器配置是否正确&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        CURRENT_ENV = env;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前启动环境:&quot;</span> + CURRENT_ENV);</span><br><span class="line">        log.warn(<span class="string">&quot;当前启动环境:&quot;</span> + CURRENT_ENV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(getENV(), RELEASE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDEV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(getENV(), DEV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDevOrTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isDEV() || Objects.equals(getENV(), TEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ENV <span class="title">getENV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(CURRENT_ENV, <span class="string">&quot;环境还未初始化，请确认代码顺序&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> CURRENT_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getIdentities() &#123;</span><br><span class="line">        <span class="keyword">return</span> envs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDoc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义spring-listener-推断程序的环境"><a href="#定义spring-listener-推断程序的环境" class="headerlink" title="定义spring listener 推断程序的环境"></a>定义spring listener 推断程序的环境</h1><h2 id="先要在factories文件配置此类的监听"><a href="#先要在factories文件配置此类的监听" class="headerlink" title="先要在factories文件配置此类的监听"></a>先要在factories文件配置此类的监听</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run Listeners</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">com.DecideENVProcessor</span></span><br></pre></td></tr></table></figure><h2 id="java推断逻辑的代码"><a href="#java推断逻辑的代码" class="headerlink" title="java推断逻辑的代码"></a>java推断逻辑的代码</h2><p><a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">springBoot容器启动流程</a><br>ApplicationContextInitializedEvent 事件是容器上下文准备初始化的时候进行调用，此事件代表之前的environment，已经初始化完毕<br><a href="/posts/%E5%88%86%E6%9E%90spring%E7%9A%84environment%EF%BC%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E5%8A%A0%E8%BD%BD">environment主要流程解析</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DecideENVProcessor</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationContextInitializedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean initialized = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationContextInitializedEvent event)</span> </span>&#123;</span><br><span class="line">        ConfigurableEnvironment environment = event.getApplicationContext().getEnvironment();</span><br><span class="line">        <span class="comment">// profiles多容器下有可能 会多次调用，头几次可能为空</span></span><br><span class="line">        <span class="keyword">if</span> (environment.getActiveProfiles().length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 命令行传递参数的active.profile 肯定不为空，多次调用的话要避免重复执行以下逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (!initialized.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ENV env = IEnums.getEnum(ENV.class, environment.getActiveProfiles()[<span class="number">0</span>], RELEASE);</span><br><span class="line">        ENV.setCurrentEnv(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在ApplicationContextInitializedEvent事件之后的逻辑，直接调用枚举Env，用来处理不同的业务逻辑即可。<br>虽然直接用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">Environment env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isDev = Objects.eqalse(<span class="string">&quot;dev&quot;</span>, env.getActiveProfiles()[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>也能实现，但是这用容易写错，后期也不易于维护。更多的缺点你懂得。。。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们用通用枚举实现配置我们各个不同的环境的env枚举。然后再监听spring 容器启动事件，获取Environment的activeProfiles，存到上下文当中，这样我们在后续的工作后期写代码中，用起来特别的方便。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;必须用到的枚举工具类&quot;&gt;&lt;a href=&quot;#必须用到的枚举工具类&quot; class=&quot;headerlink&quot; title=&quot;必须用到的枚举工具类&quot;&gt;&lt;/a&gt;必须用到的枚举工具类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;参考通用枚举的---使用例子一 &lt;a href=&quot;/posts/</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>分析spring的Environment（配置文件）的加载</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E5%88%86%E6%9E%90spring%E7%9A%84environment%EF%BC%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E5%88%86%E6%9E%90spring%E7%9A%84environment%EF%BC%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-08-19T23:53:57.000Z</published>
    <updated>2021-08-19T23:53:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目立项-&gt;开发-&gt;测试-&gt;维护-&gt;上线-&gt;维护，这几个过程中分为不同的环境。不同的环境不同业务有着不同的逻辑。<br>spring完美支持启动的时候加载不同的配置文件。我们通过指定不同的spring.profiles.active即可实现加载不同的配置文件。<br>不管怎么样默认会加载如下几个配置文件   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigFileApplicationListener</span> <span class="keyword">implements</span> <span class="title">EnvironmentPostProcessor</span>, <span class="title">SmartApplicationListener</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Note the order is from least to most specific (last one wins)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SEARCH_LOCATIONS = <span class="string">&quot;classpath:/,classpath:/config/,file:./,file:./config/*/,file:./config/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAMES = <span class="string">&quot;application&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesPropertySourceLoader</span> <span class="keyword">implements</span> <span class="title">PropertySourceLoader</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getFileExtensions() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;properties&quot;</span>, <span class="string">&quot;xml&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlPropertySourceLoader</span> <span class="keyword">implements</span> <span class="title">PropertySourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getFileExtensions() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;yml&quot;</span>, <span class="string">&quot;yaml&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5个位置，一个名称，4个后缀，总共有多少种组合？（还没有profile情况下😁）</p><h1 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h1><p><a href="/posts/springboot%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">springBoot容器启动流程</a></p><span id="springlistener"></span><h2 id="springListener"><a href="#springListener" class="headerlink" title="springListener"></a>springListener</h2><p>spring factories 配置了容器启动的监听类  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Application Listeners</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">org.springframework.boot.context.config.ConfigFileApplicationListener,\</span><br><span class="line"><span class="attr">...</span></span><br></pre></td></tr></table></figure><p>此监听类又独自搞了一套EnvironmentPostProcessor，同样也是用的spring spi机制来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigFileApplicationListener</span> <span class="keyword">implements</span> <span class="title">EnvironmentPostProcessor</span>, <span class="title">SmartApplicationListener</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default order for the processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_ORDER = Ordered.HIGHEST_PRECEDENCE + <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听spring boot容器的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) &#123;</span><br><span class="line">            <span class="comment">// 调用 独自搞的EnvironmentPostProcessor</span></span><br><span class="line">            onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationPreparedEvent) &#123;</span><br><span class="line">            onApplicationPreparedEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationEnvironmentPreparedEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据spring spi 找出environment处理类</span></span><br><span class="line">        List&lt;EnvironmentPostProcessor&gt; postProcessors = SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader());</span><br><span class="line">        <span class="comment">// 添加self</span></span><br><span class="line">        postProcessors.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 排序如果有比DEFAULT_ORDER优先级高的那么会优先处理。</span></span><br><span class="line">        AnnotationAwareOrderComparator.sort(postProcessors);</span><br><span class="line">        <span class="keyword">for</span> (EnvironmentPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">            <span class="comment">// 进行处理</span></span><br><span class="line">            postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// self postProcessEnvironment</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessEnvironment</span><span class="params">(ConfigurableEnvironment environment, SpringApplication application)</span> </span>&#123;</span><br><span class="line">        RandomValuePropertySource.addToEnvironment(environment);</span><br><span class="line">        <span class="comment">// 核心loader逻辑。下如下代码</span></span><br><span class="line">        <span class="keyword">new</span> Loader(environment, application.getResourceLoader()).load();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="真正加载的逻辑"><a href="#真正加载的逻辑" class="headerlink" title="真正加载的逻辑"></a>真正加载的逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PropertySourcesPlaceholdersResolver placeholdersResolver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertySourceLoader&gt; propertySourceLoaders;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Profile&gt; profiles;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Profile&gt; processedProfiles;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> activatedProfiles;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Profile, MutablePropertySources&gt; loaded;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;DocumentsCacheKey, List&lt;Document&gt;&gt; loadDocumentsCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Loader(ConfigurableEnvironment environment, ResourceLoader resourceLoader) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">        <span class="keyword">this</span>.placeholdersResolver = <span class="keyword">new</span> PropertySourcesPlaceholdersResolver(<span class="keyword">this</span>.environment);</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = (resourceLoader != <span class="keyword">null</span>) ? resourceLoader : <span class="keyword">new</span> DefaultResourceLoader(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.propertySourceLoaders = SpringFactoriesLoader.loadFactories(PropertySourceLoader.class,</span><br><span class="line">                getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排除 defaultProperties资源里面的spring.profiles.active|include属性</span></span><br><span class="line">        FilteredPropertySource.apply(<span class="keyword">this</span>.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,</span><br><span class="line">                (defaultProperties) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">this</span>.profiles = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">this</span>.processedProfiles = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">this</span>.activatedProfiles = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">this</span>.loaded = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">                    <span class="comment">// 初始化profile,非命令行传递的active的参数，profiles会有两个，一个是null，一个是default</span></span><br><span class="line">                    <span class="comment">// 意思是直接搜索application名字的资源，以及application-default的资源（如果命令行参数指定了active则不会有default）</span></span><br><span class="line">                    initializeProfiles();</span><br><span class="line">                    <span class="comment">// 循环加载不同的profile</span></span><br><span class="line">                    <span class="keyword">while</span> (!<span class="keyword">this</span>.profiles.isEmpty()) &#123;</span><br><span class="line">                        Profile profile = <span class="keyword">this</span>.profiles.poll();</span><br><span class="line">                        <span class="keyword">if</span> (isDefaultProfile(profile)) &#123;</span><br><span class="line">                            addProfileToEnvironment(profile.getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 配合5个位置，1个名称，4个后缀，加载不同的profile。</span></span><br><span class="line">                        <span class="comment">// 加载当前的profile，如果遇到新的spring.profiles.active|include属性，则会再次添加到profiles里，继续while循环加载</span></span><br><span class="line">                        load(profile, <span class="keyword">this</span>::getPositiveProfileFilter,</span><br><span class="line">                                addToLoaded(MutablePropertySources::addLast, <span class="keyword">false</span>));</span><br><span class="line">                        <span class="comment">/* </span></span><br><span class="line"><span class="comment">                         * this::getPositiveProfileFilter：</span></span><br><span class="line"><span class="comment">                         * yml配置文件 支持 &#x27;---&#x27; 用来分隔配置，此方法就是用来判断是否可以加载分隔的内容</span></span><br><span class="line"><span class="comment">                         * 如果分割的内容中有spring.profiles，但是spring还未加载过的话，spring是不支持加载此内容的</span></span><br><span class="line"><span class="comment">                         * 具体可移步org.springframework.boot.context.config.ConfigFileApplicationListener.Loader#asDocuments</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * addToLoaded(MutablePropertySources::addLast, false)</span></span><br><span class="line"><span class="comment">                         * 顾名思义，把profile找到的source无条件的加载到这个字段里：Map&lt;Profile, MutablePropertySources&gt; loaded;</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">this</span>.processedProfiles.add(profile);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// yml配置文件 支持 &#x27;---&#x27; 用来分隔配置，此方法就是优先加载 (5个位置，1个名称，4个后缀)的文件里面的分隔内容</span></span><br><span class="line">                    load(<span class="keyword">null</span>, <span class="keyword">this</span>::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="comment">// 把加载的资源配置到spring的environment里面</span></span><br><span class="line">                    addLoadedPropertySources();</span><br><span class="line">                    <span class="comment">// environment.setActiveProfiles</span></span><br><span class="line">                    applyActiveProfiles(defaultProperties);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此代码分析完毕，如果想看更细节的东西，请移步至org.springframework.boot.context.config.ConfigFileApplicationListener.Loader#load()</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过监听springEnvironment事件，然后用spring SPI找出所有的EnvironmentPostProcessor<br>Load类为加载配置文件的类。它的逻辑主要分为<br>1.初始化profile(包含null,以及未指定命令行参数的active时用defaultProfile)<br>2.循环profile加载（5个位置、1个名称、4个后缀）的文件<br>3.把加载的资源配置到spring的environment里面<br>4.setActiveProfiles</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;项目立项-&amp;gt;开发-&amp;gt;测试-&amp;gt;维护-&amp;gt;上线-&amp;gt;维护，这几个过程中分为不同的环境。不同的环境不同业务有着不同的逻辑。&lt;br&gt;spring完美支持启动的时候加载不同的配置文件。我们通过指定不同的spring.profiles.active即可实现加载</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/categories/java/spring/"/>
    
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="spring" scheme="https://dongmaxiang.vercel.app/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>java如何优雅的打印log</title>
    <link href="https://dongmaxiang.vercel.app/posts/java%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%89%93%E5%8D%B0log/"/>
    <id>https://dongmaxiang.vercel.app/posts/java%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%89%93%E5%8D%B0log/</id>
    <published>2021-08-19T07:16:01.000Z</published>
    <updated>2021-08-19T07:16:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>1 用sl4j（采用门面模式，不提供实现，且提供占位符打印的方式）<br>2 过长的内容没有意义，<a href="#%E9%99%90%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%95%BF%E5%BA%A6">集合最多打印几十个</a><br>3 如果有字符串拼接或者toJSON的情况，打印log之前判断该级别是否开启，不然会白白浪费cpu<br>4 对于第3点可优化的地方，用下面的util，配合着sl4j，这样就不用写判断日志级别是否开启的代码了  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LogUtils <span class="title">lazyJson</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogUtils() &#123;</span><br><span class="line">            String json = <span class="keyword">null</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 只有在输出的时候在toJSON，并且如果是集合的类型限制最多输出100个</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> json != <span class="keyword">null</span> ? json : (json = JSON.toJSONString(object, JSONMaxSerializeConfig.MAX_100_SERIALIZE_CONFIG));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;我要打印一个实体，想在开启info级别的情况下toJSON，还不想写if代码，并且实体里面有集合类型字段的话，最多输出100长度即可：&#123;&#125;&quot;</span>, LogUtils.lazyJson(实体));</span><br></pre></td></tr></table></figure><h1 id="限制序列化的长度"><a href="#限制序列化的长度" class="headerlink" title="限制序列化的长度"></a>限制序列化的长度</h1><p>日志过多过长也就没有了意义，所以如果是集合类型，我们只打印前100几个，输出过多的日志非常影响服务器性能  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化限制集合的长度</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONMaxSerializeConfig</span> <span class="keyword">extends</span> <span class="title">SerializeConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量-最多序列化100个集合</span></span><br><span class="line">    <span class="comment">// 用法 JSON.toJSONString(object, MAX_100_SERIALIZE_CONFIG)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> JSONMaxSerializeConfig MAX_100_SERIALIZE_CONFIG = <span class="keyword">new</span> JSONMaxSerializeConfig(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SERIALIZE_NUM;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JSONMaxSerializeConfig</span><span class="params">(<span class="keyword">int</span> MAX_SERIALIZE_NUM)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">true</span>);<span class="comment">// 不使用ASM，以field类型为基础进行序列化，不然无法使用当前ObjectSerializer</span></span><br><span class="line">        <span class="keyword">this</span>.MAX_SERIALIZE_NUM = MAX_SERIALIZE_NUM;</span><br><span class="line">        <span class="keyword">this</span>.register(<span class="keyword">new</span> Module() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ObjectDeserializer <span class="title">createDeserializer</span><span class="params">(ParserConfig parserConfig, Class aClass)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ObjectSerializer <span class="title">createSerializer</span><span class="params">(SerializeConfig serializeConfig, Class aClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (AbstractList.class.isAssignableFrom(aClass)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ABSTRACT_LIST_SERIALIZER;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (AbstractSet.class.isAssignableFrom(aClass)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ABSTRACT_SET_SERIALIZER;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// map类型长度限制是否需要限制？</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectSerializer ABSTRACT_LIST_SERIALIZER = (jsonSerializer, o, o1, type, i) -&gt; &#123;</span><br><span class="line">        AbstractList&lt;?&gt; list = (AbstractList&lt;?&gt;) o;</span><br><span class="line">        ListSerializer.instance.write(jsonSerializer, <span class="keyword">new</span> AbstractList&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (list.size() &gt; MAX_SERIALIZE_NUM) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;序列化输出已超出最大限制，后续的序列化将要舍弃，实际大小:&#123;&#125;, max:&#123;&#125;&quot;</span>, list.size(), MAX_SERIALIZE_NUM);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Math.min(list.size(), MAX_SERIALIZE_NUM);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> list.get(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, o1, type, i);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectSerializer ABSTRACT_SET_SERIALIZER = (jsonSerializer, o, o1, type, i) -&gt; &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        AbstractSet&lt;Object&gt; set = (AbstractSet&lt;Object&gt;) o;</span><br><span class="line">        CollectionCodec.instance.write(jsonSerializer, <span class="keyword">new</span> AbstractSet&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;Object&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="keyword">final</span> Iterator&lt;?&gt; originIterator = set.iterator();</span><br><span class="line">                    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        <span class="keyword">if</span> (count &gt; MAX_SERIALIZE_NUM) &#123;</span><br><span class="line">                            log.warn(<span class="string">&quot;序列化输出已超出最大限制，后续的序列化将要舍弃, max:&#123;&#125;&quot;</span>, MAX_SERIALIZE_NUM);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> count &lt;= MAX_SERIALIZE_NUM &amp;&amp; originIterator.hasNext();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> originIterator.next();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(set.size(), MAX_SERIALIZE_NUM);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, o1, type, i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1 用sl4j（采用门面模式，不提供实现，且提供占位符打印的方式）&lt;br&gt;2 过长的内容没有意义，&lt;a href=&quot;#%E9%99%90%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%95%BF%E5%BA%A6&quot;&gt;集合最多</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="log" scheme="https://dongmaxiang.vercel.app/categories/java/log/"/>
    
    
    <category term="log" scheme="https://dongmaxiang.vercel.app/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>重新加装MybatisPlus</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E9%87%8D%E6%96%B0%E5%8A%A0%E8%A3%85mybatisplus/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E9%87%8D%E6%96%B0%E5%8A%A0%E8%A3%85mybatisplus/</id>
    <published>2021-08-19T05:20:21.000Z</published>
    <updated>2021-08-19T05:20:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-字段填充器"><a href="#1-字段填充器" class="headerlink" title="1.字段填充器"></a>1.字段填充器</h1><p>注意重写了<code>strictFill</code>方法<br>统一规范，字段填充的值和类型所有的表都一样。所以不作类型判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldAutoFillHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        User user = CurrentUser.getCurrentUser();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;deleteFlag&quot;</span>, <span class="keyword">null</span>, DeleteFlag.N);</span><br><span class="line">        <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;isDelete&quot;</span>, <span class="keyword">null</span>, DeleteFlag.N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createUserId&quot;</span>, <span class="keyword">null</span>, user.getUserId());</span><br><span class="line">        <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;creatorUserId&quot;</span>, <span class="keyword">null</span>, user.getUserId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createUserName&quot;</span>, <span class="keyword">null</span>, user.getUserName());</span><br><span class="line">        <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;creatorUserName&quot;</span>, <span class="keyword">null</span>, user.getUserName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, <span class="keyword">null</span>, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        User user = CurrentUser.getCurrentUser();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, <span class="keyword">null</span>, LocalDateTime.now());</span><br><span class="line">        <span class="keyword">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateUserId&quot;</span>, <span class="keyword">null</span>, user.getUserId());</span><br><span class="line">        <span class="keyword">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateUserName&quot;</span>, <span class="keyword">null</span>, user.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写自动填充的逻辑</span></span><br><span class="line"><span class="comment">     * 只要有该字段、且字段为空、则填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MetaObjectHandler <span class="title">strictFill</span><span class="params">(<span class="keyword">boolean</span> insertFill, TableInfo tableInfo, MetaObject metaObject, List&lt;StrictFill&gt; strictFills)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        strictFills.forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> String fieldName = i.getFieldName();</span><br><span class="line">            <span class="keyword">if</span> (!metaObject.hasSetter(fieldName)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (metaObject.getValue(fieldName) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Object value = i.getFieldVal().get();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            metaObject.setValue(fieldName, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>最终调用了<code>insertFill</code>或者<code>updateFill</code>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用MybatisPlus 的 ibatis代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">// 就是在这里调用了MybatisPlus的填充逻辑</span></span><br><span class="line">        <span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MybatisPlus的参数处理程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisDefaultParameterHandler</span> <span class="keyword">extends</span> <span class="title">DefaultParameterHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BoundSql boundSql;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MybatisDefaultParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// processParameter 处理参数</span></span><br><span class="line">        <span class="keyword">super</span>(mappedStatement, processParameter(mappedStatement, parameterObject), boundSql);</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title">processParameter</span><span class="params">(MappedStatement ms, Object parameterObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (SqlCommandType.INSERT == ms.getSqlCommandType() || SqlCommandType.UPDATE == ms.getSqlCommandType())</span><br><span class="line">        ) &#123;</span><br><span class="line">            。。。</span><br><span class="line">            Collection&lt;Object&gt; parameters = getParameters(parameterObject);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != parameters) &#123;</span><br><span class="line">                parameters.forEach(obj -&gt; process(ms, obj));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                process(ms, parameterObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parameterObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(MappedStatement ms, Object parameterObject)</span> </span>&#123;</span><br><span class="line">        TableInfo tableInfo;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (tableInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            MetaObject metaObject = ms.getConfiguration().newMetaObject(entity);</span><br><span class="line">            <span class="keyword">if</span> (SqlCommandType.INSERT == ms.getSqlCommandType()) &#123;</span><br><span class="line">                populateKeys(tableInfo, metaObject, entity);</span><br><span class="line">                <span class="comment">// 最终填充</span></span><br><span class="line">                insertFill(metaObject, tableInfo);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 最终填充</span></span><br><span class="line">                updateFill(metaObject, tableInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-批量-单个-软删除使自动填充器生效（默认不生效）"><a href="#2-批量-单个-软删除使自动填充器生效（默认不生效）" class="headerlink" title="2.[批量|单个]软删除使自动填充器生效（默认不生效）"></a>2.[批量|单个]软删除使自动填充器生效（默认不生效）</h1><p>mybatisPlus 使用<code>@TableLogic</code>注解在字段上，表示当前表软删除，当前字段为软删除字段<br>正常调用删除的API即可软删除。但是缺点是：并不会使字段填充器生效<br>目前我用的3.3.2有单个的软删除使字段填充器生效，但是批量的没有<br>批量软删除参考批量删除的方法  </p><ul><li>mybatisPlus在初始化的时候会给每个表添加通用的Statement映射</li><li>批量软删除需要再加一个参数，总共两个参数，一个是实体(不然字段填充器往哪里填？)，一个是删除的idList集合，所以需要从新定义一个方法</li></ul><h2 id="自定义批量软删除的代码"><a href="#自定义批量软删除的代码" class="headerlink" title="自定义批量软删除的代码"></a>自定义批量软删除的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapper新增一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteBatchIdsWithFill</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T t, <span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体statement实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogicBatchDeleteWithFill</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapper的方法名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPER_METHOD = <span class="string">&quot;deleteBatchIdsWithFill&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果表不是逻辑删除，则复用SqlMethod.DELETE_BATCH_BY_IDS</span></span><br><span class="line">        <span class="keyword">if</span> (!tableInfo.isLogicDelete()) &#123;</span><br><span class="line">            String sql = String.format(SqlMethod.DELETE_BATCH_BY_IDS.getSql()</span><br><span class="line">                    , tableInfo.getTableName()</span><br><span class="line">                    , tableInfo.getKeyColumn()</span><br><span class="line">                    , SqlScriptUtils.convertForeach(<span class="string">&quot;#&#123;item&#125;&quot;</span>, Constants.COLLECTION, <span class="keyword">null</span>, <span class="string">&quot;item&quot;</span>, COMMA)</span><br><span class="line">            );</span><br><span class="line">            SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, Object.class);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.addDeleteMappedStatement(mapperClass, MAPPER_METHOD, sqlSource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用批量删除的sql</span></span><br><span class="line">        SqlMethod sqlMethod = SqlMethod.LOGIC_DELETE_BATCH_BY_IDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出是需要记录更新的字段</span></span><br><span class="line">        List&lt;TableFieldInfo&gt; fieldInfos = tableInfo.getFieldList().stream()</span><br><span class="line">                .filter(TableFieldInfo::isWithUpdateFill)</span><br><span class="line">                .collect(toList());</span><br><span class="line">        String sql;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(fieldInfos)) &#123;</span><br><span class="line">            <span class="comment">// 这里是重点，把mapper新定义的方法第一个参数作为前缀，把需要更新的字段拼到sql中</span></span><br><span class="line">            String sqlSet = <span class="string">&quot;SET &quot;</span> + fieldInfos.stream().map(i -&gt; i.getSqlSet(Constants.ENTITY_DOT)).collect(joining(EMPTY))</span><br><span class="line">                    + tableInfo.getLogicDeleteSql(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            sql = String.format(sqlMethod.getSql()</span><br><span class="line">                    , tableInfo.getTableName()</span><br><span class="line">                    , sqlSet, tableInfo.getKeyColumn()</span><br><span class="line">                    , SqlScriptUtils.convertForeach(<span class="string">&quot;#&#123;item&#125;&quot;</span>, Constants.COLLECTION, <span class="keyword">null</span>, <span class="string">&quot;item&quot;</span>, COMMA)</span><br><span class="line">                    , tableInfo.getLogicDeleteSql(<span class="keyword">true</span>, <span class="keyword">true</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sql = String.format(sqlMethod.getSql()</span><br><span class="line">                    , tableInfo.getTableName()</span><br><span class="line">                    , sqlLogicSet(tableInfo)</span><br><span class="line">                    , tableInfo.getKeyColumn()</span><br><span class="line">                    , SqlScriptUtils.convertForeach(<span class="string">&quot;#&#123;item&#125;&quot;</span>, Constants.COLLECTION, <span class="keyword">null</span>, <span class="string">&quot;item&quot;</span>, COMMA)</span><br><span class="line">                    , tableInfo.getLogicDeleteSql(<span class="keyword">true</span>, <span class="keyword">true</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addUpdateMappedStatement(mapperClass, modelClass, MAPPER_METHOD, sqlSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="最后需要把sql映射的工具类添加到spring容器中哦"></span><h2 id="最后需要把sql映射的工具类添加到Spring容器中哦"><a href="#最后需要把sql映射的工具类添加到Spring容器中哦" class="headerlink" title="最后需要把sql映射的工具类添加到Spring容器中哦"></a>最后需要把sql映射的工具类添加到Spring容器中哦</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractSqlInjector <span class="title">customSqlMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;AbstractMethod&gt; allMethodList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//单个删除withFillApi（3.3.2自带）</span></span><br><span class="line">    allMethodList.add(<span class="keyword">new</span> LogicDeleteByIdWithFill());</span><br><span class="line">    <span class="comment">//批量删除withFillApi</span></span><br><span class="line">    allMethodList.add(<span class="keyword">new</span> LogicBatchDeleteWithFill());</span><br><span class="line">    <span class="comment">// 默认的api</span></span><br><span class="line">    allMethodList.addAll(<span class="keyword">new</span> DefaultSqlInjector().getMethodList(<span class="keyword">null</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractSqlInjector() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> allMethodList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用的话一定要使用mapper新定义的方法哦</p></blockquote><p>大功告成</p><span id="3-mybatisplus查询软删除的数据"></span><h1 id="3-MybatisPlus查询软删除的数据"><a href="#3-MybatisPlus查询软删除的数据" class="headerlink" title="3.MybatisPlus查询软删除的数据"></a>3.MybatisPlus查询软删除的数据</h1><p>批量软删除，我们已经完美的实现，字段填充器也可以生效。但有些业务需要查询已经删除的数据，mybatisPlus目前还没有对应的方法，只能自己实现了。</p><h2 id="首先定义方法到mapper里面"><a href="#首先定义方法到mapper里面" class="headerlink" title="首先定义方法到mapper里面"></a>首先定义方法到mapper里面</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// BaseDomain是我们数据库实体的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomBaseMapper</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseDomain</span>&lt;? <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据忽略已经删除的数据</span></span><br><span class="line"><span class="comment">     * ps: 如果有逻辑删除的话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">selectListIgnoreDeleted</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据忽略已经删除的数据</span></span><br><span class="line"><span class="comment">     * ps: 如果有逻辑删除的话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">selectOneIgnoreDeleted</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 查询忽略已经删除的数据</span></span><br><span class="line"><span class="comment">     * ps: 如果有逻辑删除的话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">selectByIdIgnoreDeleted</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据ID 批量查询）忽略已经删除的数据</span></span><br><span class="line"><span class="comment">     * ps: 如果有逻辑删除的话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">selectBatchIdsIgnoreDeleted</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="然后定义这些个方法的实现"><a href="#然后定义这些个方法的实现" class="headerlink" title="然后定义这些个方法的实现"></a>然后定义这些个方法的实现</h2><p><strong>有用动态代理啊<a href="/posts/javautil%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">动态代理</a></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询单个时忽略已删除的数据</span></span><br><span class="line"><span class="comment"> * ps:如果有逻辑删除的话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectOneIgnoreDeleted</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPER_METHOD = <span class="string">&quot;selectOneIgnoreDeleted&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DynamicProxy为本文的动态代理</span></span><br><span class="line">        <span class="comment">// 和源码最重要的不同点是，这里直接忽略逻辑删除 </span></span><br><span class="line">        TableInfo ignoreDeleteLogic = <span class="keyword">new</span> DynamicProxy&lt;&gt;(tableInfo, Object.class)</span><br><span class="line">                .getProxy((target, proxyMethod, args, originMethod) -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 忽略逻辑删除</span></span><br><span class="line">                    <span class="keyword">if</span> (originMethod.getName().equals(<span class="string">&quot;isLogicDelete&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 直接返回false</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> proxyMethod.invoke(target, args);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        String formatted = String.format(SqlMethod.SELECT_ONE.getSql()</span><br><span class="line">                , sqlFirst()</span><br><span class="line">                , sqlSelectColumns(tableInfo, <span class="keyword">true</span>)</span><br><span class="line">                , tableInfo.getTableName()</span><br><span class="line">                , sqlWhereEntityWrapper(<span class="keyword">true</span>, ignoreDeleteLogic)</span><br><span class="line">                , sqlComment()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, formatted, modelClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addSelectMappedStatementForTable(mapperClass, MAPPER_METHOD, sqlSource, tableInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询单个id时忽略已删除的数据</span></span><br><span class="line"><span class="comment"> * ps:如果有逻辑删除的话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectByIdIgnoreDeleted</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPER_METHOD = <span class="string">&quot;selectByIdIgnoreDeleted&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String formatted = String.format(SqlMethod.SELECT_BY_ID.getSql()</span><br><span class="line">                , sqlSelectColumns(tableInfo, <span class="keyword">false</span>)</span><br><span class="line">                , tableInfo.getTableName(), tableInfo.getKeyColumn(), tableInfo.getKeyProperty()</span><br><span class="line">                <span class="comment">// 和源码最重要的不同点是这里不拼接逻辑删除的sql</span></span><br><span class="line">                , EMPTY</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        SqlSource sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, formatted, Object.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addSelectMappedStatementForTable(mapperClass, MAPPER_METHOD, sqlSource, tableInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询多个id时忽略已删除的数据</span></span><br><span class="line"><span class="comment"> * ps:如果有逻辑删除的话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectBatchByIdsIgnoreDeleted</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPER_METHOD = <span class="string">&quot;selectBatchIdsIgnoreDeleted&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        String sqlFormatted = String.format(SqlMethod.SELECT_BATCH_BY_IDS.getSql()</span><br><span class="line">                , sqlSelectColumns(tableInfo, <span class="keyword">false</span>)</span><br><span class="line">                , tableInfo.getTableName()</span><br><span class="line">                , tableInfo.getKeyColumn()</span><br><span class="line">                , SqlScriptUtils.convertForeach(<span class="string">&quot;#&#123;item&#125;&quot;</span>, COLLECTION, <span class="keyword">null</span>, <span class="string">&quot;item&quot;</span>, COMMA)</span><br><span class="line">                <span class="comment">// 和源码最重要的不同点是这里不拼接逻辑删除的sql</span></span><br><span class="line">                , EMPTY</span><br><span class="line">        );</span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sqlFormatted, Object.class);</span><br><span class="line">        <span class="keyword">return</span> addSelectMappedStatementForTable(mapperClass, MAPPER_METHOD, sqlSource, tableInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询列表时忽略已删除的数据</span></span><br><span class="line"><span class="comment"> * ps:如果有逻辑删除的话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectListIgnoreDeleted</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPER_METHOD = <span class="string">&quot;selectListIgnoreDeleted&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和源码最重要的不同点是，这里直接忽略逻辑删除</span></span><br><span class="line">        TableInfo ignoreDeleteLogic = <span class="keyword">new</span> DynamicProxy&lt;&gt;(tableInfo, Object.class)</span><br><span class="line">                .getProxy((target, proxyMethod, args, originMethod) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (originMethod.getName().equals(<span class="string">&quot;isLogicDelete&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 直接返回false</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> proxyMethod.invoke(target, args);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        String sql = String.format(SqlMethod.SELECT_LIST.getSql()</span><br><span class="line">                , sqlFirst()</span><br><span class="line">                , sqlSelectColumns(tableInfo, <span class="keyword">true</span>)</span><br><span class="line">                , tableInfo.getTableName()</span><br><span class="line">                , sqlWhereEntityWrapper(<span class="keyword">true</span>, ignoreDeleteLogic)</span><br><span class="line">                , sqlComment()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addSelectMappedStatementForTable(mapperClass, MAPPER_METHOD, sqlSource, tableInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定statement"><a href="#绑定statement" class="headerlink" title="绑定statement"></a>绑定statement</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractSqlInjector <span class="title">customSqlMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;AbstractMethod&gt; allMethodList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 默认的api</span></span><br><span class="line">    allMethodList.addAll(<span class="keyword">new</span> DefaultSqlInjector().getMethodList(<span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增的api</span></span><br><span class="line">    List&lt;AbstractMethod&gt; methodList = Stream.of(</span><br><span class="line">            <span class="keyword">new</span> SelectByIdIgnoreDeleted(),</span><br><span class="line">            <span class="keyword">new</span> SelectBatchByIdsIgnoreDeleted(),</span><br><span class="line">            <span class="keyword">new</span> SelectOneIgnoreDeleted(),</span><br><span class="line">            <span class="keyword">new</span> SelectListIgnoreDeleted()</span><br><span class="line">    ).collect(toList());</span><br><span class="line"></span><br><span class="line">    allMethodList.addAll(allMethodList);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractSqlInjector() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> allMethodList;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此完成SQL的statement绑定，然后具体业务继承CustomBaseMapper即可享用啦</p><h1 id="4-避免字符串编码"><a href="#4-避免字符串编码" class="headerlink" title="4.避免字符串编码"></a>4.避免字符串编码</h1><p>lambda语法已经帮我们解决了字符串编码的问题，但是非lambda的api，他的参数只支持接受字符串，那么我们如何避免字符串呢？<br>参考<a href="/posts/mybatisplus%E5%88%86%E6%9E%90lambda%E8%AF%AD%E6%B3%95%E5%8E%9F%E7%90%86">Lambda转字符串</a>我们也可以自定义lambda转字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * api获取字段名</span></span><br><span class="line"><span class="comment"> * 避免面向字符串编程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">cts</span><span class="params">(SFunction&lt;T, ?&gt; column)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> columnToString(column);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">columnToString</span><span class="params">(SFunction&lt;T, ?&gt; column)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mybatisPlus自带的api</span></span><br><span class="line">    SerializedLambda resolve = LambdaUtils.resolve(column);</span><br><span class="line">    <span class="keyword">return</span> org.apache.ibatis.reflection.property.PropertyNamer.methodToProperty(resolve.getImplMethodName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在其他地方也可以用lambda转字段的语法了</p><h1 id="5-避免空指针，使api操作更安全"><a href="#5-避免空指针，使api操作更安全" class="headerlink" title="5.避免空指针，使api操作更安全"></a>5.避免空指针，使api操作更安全</h1><p>集成以上所有的特性到一个类中作为一个baseDao。<br>实际项目中一个表对应一个实体，一个mapper，当然也需要一个Dao，继承此Dao就可以顺心的使用了。<br>我们Dao的职责就是用来拼接sql的。避免sql东一处西一处，不好维护。强制校验把sql写在Dao类中👉<a href="/posts/mybatisplus%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E6%A0%A1%E9%AA%8C">MybatisPlus语法糖的校验</a>然后service的业务代码，调用Dao写好的sql即可。<strong>service层不关心sql</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和业务无关，所有数据库表的Dao继承此类</span></span><br><span class="line"><span class="comment"> * manger基类 （ 泛型：M 是 mapper 对象，T 是数据库实体 ）</span></span><br><span class="line"><span class="comment"> * 1：修改原有的api，使api操作更安全</span></span><br><span class="line"><span class="comment"> * 2：逻辑删除时使用填充删除</span></span><br><span class="line"><span class="comment"> * 3: lambda转换成字段名，可以随时随地用啦</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">CustomBaseMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseDomain</span>&lt;? <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简写方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">cts_</span><span class="params">(SFunction&lt;T, ?&gt; column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> columnToStringUnderline(column);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * api获取字段名并且驼峰变下划线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">columnToStringUnderline</span><span class="params">(SFunction&lt;T, ?&gt; column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.camelToUnderline(columnToString(column));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简写方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">cts</span><span class="params">(SFunction&lt;T, ?&gt; column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> columnToString(column);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * api获取字段名</span></span><br><span class="line"><span class="comment">     * 避免面向字符串编程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">columnToString</span><span class="params">(SFunction&lt;T, ?&gt; column)</span> </span>&#123;</span><br><span class="line">        SerializedLambda resolve = LambdaUtils.resolve(column);</span><br><span class="line">        <span class="keyword">return</span> PropertyNamer.methodToProperty(resolve.getImplMethodName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; entityClass = currentModelClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加统一校验id的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">checkId</span><span class="params">(Serializable id)</span> <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkId(id, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">checkId</span><span class="params">(Serializable id, <span class="keyword">boolean</span> ignoreDeleted)</span> <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">        T byId = ignoreDeleted ? getByIdIgnoreDeleted(id) : getById(id);</span><br><span class="line">        <span class="keyword">if</span> (byId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BizException(<span class="string">&quot;数据：&quot;</span> + id + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> byId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果条件为空一律返回null，禁止抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getById</span><span class="params">(Serializable id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getByIdIgnoreDeleted</span><span class="params">(Serializable id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectByIdIgnoreDeleted(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用软删除</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeById</span><span class="params">(Serializable id)</span> </span>&#123;</span><br><span class="line">        T baseDomain = BeanUtils.instantiateClass(entityClass);</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        ((BaseDomain&lt;Serializable&gt;) baseDomain).setId(id);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteByIdWithFill(baseDomain));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span> </span>&#123;</span><br><span class="line">        T t = BeanUtils.instantiateClass(entityClass);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteBatchIdsWithFill(t, idList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有的list 如果条件为空一律返回空的list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(idList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.listByIds(idList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有的list 如果条件为空一律返回空的list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">listByIdsIgnoreDeleted</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(idList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectBatchIdsIgnoreDeleted(idList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOneIgnoreDeleted</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getOneIgnoreDeleted(queryWrapper, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOneIgnoreDeleted</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="keyword">boolean</span> throwEx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (throwEx) &#123;</span><br><span class="line">            <span class="keyword">return</span> getBaseMapper().selectOneIgnoreDeleted(queryWrapper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.getObject(log, getBaseMapper().selectListIgnoreDeleted(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询条件忽略已经删除的数据(如果是逻辑删除的话)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LambdaQueryChainWrapper&lt;T&gt; <span class="title">lambdaQueryIgnoreDeleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LambdaQueryChainWrapper&lt;T&gt;(getBaseMapper()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> haveNullValueOfIn = <span class="keyword">false</span>;<span class="comment">// in条件是否有空的list</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">super</span>.wrapperChildren = <span class="keyword">new</span> LambdaQueryWrapper&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="comment">// 为空则不添加此条件</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> LambdaQueryWrapper&lt;T&gt; <span class="title">in</span><span class="params">(<span class="keyword">boolean</span> condition, SFunction&lt;T, ?&gt; column, Collection&lt;?&gt; coll)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (CollectionUtils.isEmpty(coll)) &#123;</span><br><span class="line">                            haveNullValueOfIn = <span class="keyword">true</span>;<span class="comment">// true，直接返回，不增加这个in条件</span></span><br><span class="line">                            <span class="keyword">return</span> typedThis;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">super</span>.in(condition, column, coll);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (haveNullValueOfIn) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 调用忽略逻辑删除的列表api</span></span><br><span class="line">                <span class="keyword">return</span> BaseDao.<span class="keyword">this</span>.getBaseMapper().selectListIgnoreDeleted(wrapperChildren);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LambdaQuery中，条件有in，并且条件为空，一律返回空的list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LambdaQueryChainWrapper&lt;T&gt; <span class="title">lambdaQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LambdaQueryChainWrapper&lt;T&gt;(getBaseMapper()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> haveNullValueOfIn = <span class="keyword">false</span>;<span class="comment">// in条件是否有空的list</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">super</span>.wrapperChildren = <span class="keyword">new</span> LambdaQueryWrapper&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="comment">// 为空则不添加此条件</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> LambdaQueryWrapper&lt;T&gt; <span class="title">in</span><span class="params">(<span class="keyword">boolean</span> condition, SFunction&lt;T, ?&gt; column, Collection&lt;?&gt; coll)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (CollectionUtils.isEmpty(coll)) &#123;</span><br><span class="line">                            haveNullValueOfIn = <span class="keyword">true</span>;<span class="comment">// true，直接返回，不增加这个in条件</span></span><br><span class="line">                            <span class="keyword">return</span> typedThis;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">super</span>.in(condition, column, coll);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (haveNullValueOfIn) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.list();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * query中，条件有且只有一个in，并且条件为空，一律返回空的list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryChainWrapper&lt;T&gt; <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QueryChainWrapper&lt;T&gt;(getBaseMapper()) &#123;</span><br><span class="line">            <span class="comment">// in条件是否有空的list</span></span><br><span class="line">            <span class="keyword">boolean</span> haveNullValueOfIn = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 只有in的条件</span></span><br><span class="line">            <span class="keyword">boolean</span> onlyInCondition = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">super</span>.wrapperChildren = <span class="keyword">new</span> QueryWrapper&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="comment">// 为空则不添加此条件</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> QueryWrapper&lt;T&gt; <span class="title">in</span><span class="params">(<span class="keyword">boolean</span> condition, String column, Collection&lt;?&gt; coll)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (CollectionUtils.isEmpty(coll)) &#123;</span><br><span class="line">                            haveNullValueOfIn = <span class="keyword">true</span>;<span class="comment">// true，直接返回，不增加这个in条件</span></span><br><span class="line">                            <span class="keyword">return</span> typedThis;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">super</span>.in(condition, column, coll);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> QueryWrapper&lt;T&gt; <span class="title">doIt</span><span class="params">(<span class="keyword">boolean</span> condition, ISqlSegment... sqlSegments)</span> </span>&#123;</span><br><span class="line">                        onlyInCondition = <span class="keyword">false</span>;<span class="comment">// 此方法执行代表有其他的条件</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.doIt(condition, sqlSegments);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (onlyInCondition &amp;&amp; haveNullValueOfIn) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.list();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>配置字段填充器<br>省去无关记录用户的操作</li><li>批量软删除使字段填充器删除时也生效  </li><li>查询已经删除的数据  </li><li>避免字符串编程  </li><li>避免空指针异常  </li></ol><p>mybatisPlus 虽然能开箱即用，但是如果没有更完善的配置，用起来也会不是特别的方便。这些特性配置完事之后，按照每个特性的使用步骤来。可以节省我们开发人员很多的代码量。以及省去了很多不需要关系的东西。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-字段填充器&quot;&gt;&lt;a href=&quot;#1-字段填充器&quot; class=&quot;headerlink&quot; title=&quot;1.字段填充器&quot;&gt;&lt;/a&gt;1.字段填充器&lt;/h1&gt;&lt;p&gt;注意重写了&lt;code&gt;strictFill&lt;/code&gt;方法&lt;br&gt;统一规范，字段填充的值和类型所有</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="mybatis" scheme="https://dongmaxiang.vercel.app/categories/java/mybatis/"/>
    
    
    <category term="mybatis" scheme="https://dongmaxiang.vercel.app/tags/mybatis/"/>
    
    <category term="mybatisPlus" scheme="https://dongmaxiang.vercel.app/tags/mybatisPlus/"/>
    
  </entry>
  
  <entry>
    <title>MybatisPlus针对Saas系统的动态多租户插件</title>
    <link href="https://dongmaxiang.vercel.app/posts/mybatisplus%E9%92%88%E5%AF%B9saas%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%8F%92%E4%BB%B6/"/>
    <id>https://dongmaxiang.vercel.app/posts/mybatisplus%E9%92%88%E5%AF%B9saas%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%8F%92%E4%BB%B6/</id>
    <published>2021-07-25T06:05:23.000Z</published>
    <updated>2021-07-25T06:05:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>多租户就是用额外的一个字段代表当前表中的数据的归属。在sql curd时根据上下文的用户（租户） 自动拼接此条件<br><strong>动态</strong>就是有些表是公用的，没有多租户的概念。那么操作此表的时候需要排除，亦或者多个字段，每个字段的值都不一样等</p><h1 id="前期工作"><a href="#前期工作" class="headerlink" title="前期工作"></a>前期工作</h1><p>1.首先定义一个多租户字段的枚举，为提取数据库多租户字段的字段做准备<br>IEnums参考<a href="/posts/%E9%80%9A%E7%94%A8%E6%9E%9A%E4%B8%BE">通用枚举</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TenantField</span> <span class="keyword">implements</span> <span class="title">IEnums</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// mid 为我们系统的租户字段</span></span><br><span class="line">    <span class="comment">// CurrentTenant 是业务系统的上下文，比如说当前的登录用户信息，可以自由改造</span></span><br><span class="line">    MID(<span class="string">&quot;商户id&quot;</span>, <span class="string">&quot;mid&quot;</span>, () -&gt; CurrentTenant.getCurrentTenant().getMid()),</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] dbFieldNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String doc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;Long&gt; getTenantValue;</span><br><span class="line"></span><br><span class="line">    TenantField(String doc, String underlineField, Supplier&lt;Long&gt; getTenantValue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doc = doc;</span><br><span class="line">        <span class="keyword">this</span>.getTenantValue = getTenantValue;</span><br><span class="line">        String underlineLower = underlineField.toLowerCase(Locale.ENGLISH);</span><br><span class="line">        String underlineUpper = underlineField.toUpperCase(Locale.ENGLISH);</span><br><span class="line">        String camel = StringUtils.underlineToCamel(underlineField);</span><br><span class="line">        String camelLower = camel.toLowerCase(Locale.ENGLISH);</span><br><span class="line">        String camelUpper = camel.toUpperCase(Locale.ENGLISH);</span><br><span class="line">        <span class="comment">// 下划线、驼峰、大写都可以匹配</span></span><br><span class="line">        <span class="keyword">this</span>.dbFieldNames = <span class="keyword">new</span> String[]&#123;underlineLower, underlineUpper, camel, camelLower, camelUpper&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getIdentities() &#123;</span><br><span class="line">        <span class="keyword">return</span> dbFieldNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDoc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好字段，以及获取字段值的方式之后接下来该读取数据库有此字段的表<br>为接下来动态拼接sql做准备</p><h1 id="读取数据库的多租户信息"><a href="#读取数据库的多租户信息" class="headerlink" title="读取数据库的多租户信息"></a>读取数据库的多租户信息</h1><p>这个是MYSQL的获取表字段的方式哦，其他类型的数据库请参考其文档LogUtils.lazyJson 可参考<a href="/posts/java%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%89%93%E5%8D%B0log">优雅打印日志</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表名称和对应的租户对应的字段</span></span><br><span class="line"><span class="comment"> * 忽略大小写的map(mysql不区分大小写)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;String&gt;&gt; tableName$tenantField_map = <span class="keyword">new</span> CaseInsensitiveKeyMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// spring容器给dataSource赋值之后的操作</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 所有的多租户字段</span></span><br><span class="line">    Set&lt;String&gt; tenantColumnNameSet = Arrays.stream(TenantField.values())</span><br><span class="line">            .map(TenantField::getDbFieldNames)</span><br><span class="line">            .flatMap(Arrays::stream)</span><br><span class="line">            .collect(Collectors.toSet());</span><br><span class="line">    log.info(<span class="string">&quot;tenant init all supports column names:\n&#123;&#125;&quot;</span>, LogUtils.lazyJson(tenantColumnNameSet));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (Connection connection = dataSource.getConnection()) &#123;</span><br><span class="line">        String catalog = connection.getCatalog();</span><br><span class="line">        DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">        ResultSet tables = metaData.getTables(catalog, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;TABLE&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环所有的表</span></span><br><span class="line">        <span class="keyword">while</span> (tables.next()) &#123;</span><br><span class="line">            String table_name = tables.getString(<span class="string">&quot;TABLE_NAME&quot;</span>);</span><br><span class="line">            ResultSet columns = metaData.getColumns(catalog, <span class="keyword">null</span>, table_name, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 循环表所有的字段</span></span><br><span class="line">            <span class="keyword">while</span> (columns.next()) &#123;</span><br><span class="line">                String column_name = columns.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>);</span><br><span class="line">                <span class="comment">// 如果有符合租户字段则Put</span></span><br><span class="line">                <span class="keyword">if</span> (tenantColumnNameSet.contains(column_name)) &#123;</span><br><span class="line">                    tableName$tenantField_map.computeIfAbsent(table_name, k -&gt; Lists.newArrayList())</span><br><span class="line">                            .add(column_name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;tenant init table name and tenant column name :\n&#123;&#125;&quot;</span>, LogUtils.lazyJson(tableName$tenantField_map));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>提取表对应的租户字段之后就可以做动态注入的操作操作了。<br>如果表结构变更，只有重启系统才会生效哦</p><h1 id="拦截增删改查sql并动态注入条件"><a href="#拦截增删改查sql并动态注入条件" class="headerlink" title="拦截增删改查sql并动态注入条件"></a>拦截增删改查sql并动态注入条件</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTenantSqlParser</span> <span class="keyword">extends</span> <span class="title">TenantSqlParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInsert</span><span class="params">(net.sf.jsqlparser.statement.insert.Insert insert)</span> </span>&#123;</span><br><span class="line">        ItemsList itemsList = insert.getItemsList();</span><br><span class="line">        <span class="keyword">if</span> (itemsList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有租户字段并且判断是否为 有效的租户</span></span><br><span class="line">        List&lt;String&gt; tenantFieldList = ObjectUtils.defaultIfNull(tableName$tenantField_map.get(insert.getTable().getName()), Collections.emptyList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经显示的有租户字段，则不用处理</span></span><br><span class="line">        Set&lt;String&gt; existsColumnsSet = insert.getColumns().stream()</span><br><span class="line">                .map(Column::getColumnName)</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        tenantFieldList = tenantFieldList.stream()</span><br><span class="line">                .filter(t -&gt; !existsColumnsSet.contains(t))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前操作的表没有租户的字段或者非有效租户，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(tenantFieldList) || !CurrentTenant.isValidTenant()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加插入的字段，到最后一列</span></span><br><span class="line">        List&lt;Column&gt; newColumnList = tenantFieldList.stream()</span><br><span class="line">                .map(Column::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        insert.getColumns().addAll(newColumnList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Expression&gt; valueExpressionList = tenantFieldList.stream()</span><br><span class="line">                .map(field -&gt; getTenantValueExpression(IEnums.mustGetEnum(TenantField.class, field)))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 批量新增</span></span><br><span class="line">        <span class="keyword">if</span> (itemsList <span class="keyword">instanceof</span> MultiExpressionList) &#123;</span><br><span class="line">            ((MultiExpressionList) itemsList).getExprList().forEach(el -&gt; el.getExpressions().addAll(valueExpressionList));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 单个新增</span></span><br><span class="line">            ((ExpressionList) insert.getItemsList()).getExpressions().addAll(valueExpressionList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processUpdate</span><span class="params">(net.sf.jsqlparser.statement.update.Update update)</span> </span>&#123;</span><br><span class="line">        Expression expression = getExpression(update.getTable(), update.getWhere());</span><br><span class="line">        <span class="keyword">if</span> (expression != <span class="keyword">null</span>) &#123;</span><br><span class="line">            update.setWhere(expression);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDelete</span><span class="params">(net.sf.jsqlparser.statement.delete.Delete delete)</span> </span>&#123;</span><br><span class="line">        Expression expression = getExpression(delete.getTable(), delete.getWhere());</span><br><span class="line">        <span class="keyword">if</span> (expression != <span class="keyword">null</span>) &#123;</span><br><span class="line">            delete.setWhere(expression);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Expression <span class="title">getExpression</span><span class="params">(Table table, Expression where)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; tenantFieldList = tableName$tenantField_map.get(table.getName());</span><br><span class="line">        <span class="keyword">return</span> builderExpression(where, table, tenantFieldList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 普通查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addColumn   是否添加租户列,insert into select语句中需要</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processPlainSelect</span><span class="params">(PlainSelect plainSelect, <span class="keyword">boolean</span> addColumn)</span> </span>&#123;</span><br><span class="line">        FromItem fromItem = plainSelect.getFromItem();</span><br><span class="line">        <span class="keyword">if</span> (fromItem <span class="keyword">instanceof</span> Table) &#123;</span><br><span class="line">            Table fromTable = (Table) fromItem;</span><br><span class="line">            List&lt;String&gt; tenantFieldList = tableName$tenantField_map.get(fromTable.getName());</span><br><span class="line">            plainSelect.setWhere(builderExpression(plainSelect.getWhere(), fromTable, tenantFieldList));</span><br><span class="line">            <span class="keyword">if</span> (addColumn) &#123;</span><br><span class="line">                tenantFieldList.forEach(field -&gt; plainSelect.getSelectItems().add(<span class="keyword">new</span> SelectExpressionItem(<span class="keyword">new</span> Column(field))));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            processFromItem(fromItem);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Join&gt; joins = plainSelect.getJoins();</span><br><span class="line">        <span class="keyword">if</span> (joins != <span class="keyword">null</span> &amp;&amp; joins.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            joins.forEach(j -&gt; &#123;</span><br><span class="line">                processJoin(j);</span><br><span class="line">                processFromItem(j.getRightItem());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联表查询</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processJoin</span><span class="params">(Join join)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (join.getRightItem() <span class="keyword">instanceof</span> Table) &#123;</span><br><span class="line">            Table rightItem = (Table) join.getRightItem();</span><br><span class="line">            List&lt;String&gt; tenantFieldList = tableName$tenantField_map.get(rightItem.getName());</span><br><span class="line">            join.setOnExpression(builderExpression(join.getOnExpression(), rightItem, tenantFieldList));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除新增外最终构造where条件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Expression <span class="title">builderExpression</span><span class="params">(Expression currentExpression, Table table, List&lt;String&gt; tenantFieldList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(tenantFieldList) || !CurrentTenant.isValidTenant()) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentExpression;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentExpression <span class="keyword">instanceof</span> BinaryExpression) &#123;</span><br><span class="line">            BinaryExpression binaryExpression = (BinaryExpression) currentExpression;</span><br><span class="line">            doExpression(binaryExpression.getLeftExpression());</span><br><span class="line">            doExpression(binaryExpression.getRightExpression());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentExpression <span class="keyword">instanceof</span> InExpression) &#123;</span><br><span class="line">            InExpression inExp = (InExpression) currentExpression;</span><br><span class="line">            ItemsList rightItems = inExp.getRightItemsList();</span><br><span class="line">            <span class="keyword">if</span> (rightItems <span class="keyword">instanceof</span> SubSelect) &#123;</span><br><span class="line">                processSelectBody(((SubSelect) rightItems).getSelectBody());</span><br><span class="line">            &#125;</span><br><span class="line">            ItemsList leftItems = inExp.getLeftItemsList();</span><br><span class="line">            <span class="keyword">if</span> (leftItems <span class="keyword">instanceof</span> SubSelect) &#123;</span><br><span class="line">                processSelectBody(((SubSelect) leftItems).getSelectBody());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Expression expression = currentExpression;</span><br><span class="line">        <span class="keyword">for</span> (String tenantField : tenantFieldList) &#123;</span><br><span class="line">            Expression tenantValueExpression = getTenantValueExpression(IEnums.mustGetEnum(TenantField.class, tenantField));</span><br><span class="line"></span><br><span class="line">            Expression appendExpression = <span class="keyword">this</span>.processTableAlias4CustomizedTenantIdExpression(tenantValueExpression, table, tenantField);</span><br><span class="line">            <span class="keyword">if</span> (expression <span class="keyword">instanceof</span> OrExpression) &#123;</span><br><span class="line">                expression = <span class="keyword">new</span> AndExpression(appendExpression, <span class="keyword">new</span> Parenthesis(expression));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expression != <span class="keyword">null</span>) &#123;</span><br><span class="line">                expression = <span class="keyword">new</span> AndExpression(appendExpression, expression);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                expression = appendExpression;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目前: 针对自定义的tenantId的条件表达式[tenant_id in (1,2,3)]，无法处理多租户的字段加上表别名</span></span><br><span class="line"><span class="comment">     * select a.id, b.name</span></span><br><span class="line"><span class="comment">     * from a</span></span><br><span class="line"><span class="comment">     * join b on b.aid = a.id and [b.]tenant_id in (1,2) --别名[b.]无法加上 TODO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Expression <span class="title">processTableAlias4CustomizedTenantIdExpression</span><span class="params">(Expression expression, Table table, String tenantField)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expression <span class="keyword">instanceof</span> ValueListExpression) &#123;</span><br><span class="line">            InExpression inExpression = <span class="keyword">new</span> InExpression();</span><br><span class="line">            inExpression.setLeftExpression(<span class="keyword">this</span>.getAliasColumn(table, tenantField));</span><br><span class="line">            inExpression.setRightItemsList(((ValueListExpression) expression).getExpressionList());</span><br><span class="line">            <span class="keyword">return</span> inExpression;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            EqualsTo equalsTo = <span class="keyword">new</span> EqualsTo();</span><br><span class="line">            equalsTo.setLeftExpression(<span class="keyword">this</span>.getAliasColumn(table, tenantField));</span><br><span class="line">            equalsTo.setRightExpression(expression);</span><br><span class="line">            <span class="keyword">return</span> equalsTo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Column <span class="title">getAliasColumn</span><span class="params">(Table table, String tenantField)</span> </span>&#123;</span><br><span class="line">        StringBuilder column = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (table.getAlias() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            column.append(table.getAlias().getName()).append(StringPool.DOT);</span><br><span class="line">        &#125;</span><br><span class="line">        column.append(tenantField);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Column(column.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从当前上下文获取租户的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Expression <span class="title">getTenantValueExpression</span><span class="params">(TenantField tenantField)</span> </span>&#123;</span><br><span class="line">        Long tenantId = tenantField.getGetTenantValue().get();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LongValue(tenantId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现增删改方法的拦截之后再把此类注入到spring容器当中即可</p><h1 id="注入并生效"><a href="#注入并生效" class="headerlink" title="注入并生效"></a>注入并生效</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CustomTenantSqlParser customTenantSqlParser;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页插件</span></span><br><span class="line"><span class="comment">     * 和</span></span><br><span class="line"><span class="comment">     * sql拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">        paginationInterceptor.setSqlParserList(Collections.singletonList(customTenantSqlParser));</span><br><span class="line">        <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此动态多租户的插件到此结束，总结分为这几个步骤<br>1.定义好多租户的字段以及值获取的方式（enum TenantField）<br>2.根据定义好的字段读取数据库有此字段的表的信息，定义一个java缓存(tableName$tenantField_map)<br>3.实现多租户sql拦截的方法包括:增(自动insert)删改查(自动拼接sql条件)<br>4.把此插件注入到spring容器中即可<br>实现的效果为所有的sql 会自动拼接对应的条件。但是具体字段名称和字段值的提供都由使用者自定义实现(enum TenantField)<br>这样我们针对saas系统的业务完全可以当做非saas系统来开发，提升开发效率</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;多租户就是用额外的一个字段代表当前表中的数据的归属。在sql curd时根据上下文的用户（租户） 自动拼接此条件&lt;br&gt;&lt;strong&gt;动态&lt;/strong&gt;就是有些表是公用的，没有多租户的概念。那么操作此表的时候需要排除，亦或者多个字段，每个字段的值都不一样等&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="mybatis" scheme="https://dongmaxiang.vercel.app/categories/java/mybatis/"/>
    
    
    <category term="mybatis" scheme="https://dongmaxiang.vercel.app/tags/mybatis/"/>
    
    <category term="多租户" scheme="https://dongmaxiang.vercel.app/tags/%E5%A4%9A%E7%A7%9F%E6%88%B7/"/>
    
  </entry>
  
  <entry>
    <title>java的序列化和反序列化Serializable原理</title>
    <link href="https://dongmaxiang.vercel.app/posts/java%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96serializable%E5%8E%9F%E7%90%86/"/>
    <id>https://dongmaxiang.vercel.app/posts/java%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96serializable%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-24T23:19:00.000Z</published>
    <updated>2021-07-24T23:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实现Serializable接口就能把对象序列化反序列化出去，那么原理是什么呢？<br>带着以下问题一探究竟  </p><ul><li>为什么实现这个接口就能序列化和反序列化呢？</li><li>序列化和反序列化的内容是什么呢，可以自定义吗？</li></ul><h2 id="为什么实现这个接口就能序列化和反序列化呢"><a href="#为什么实现这个接口就能序列化和反序列化呢" class="headerlink" title="为什么实现这个接口就能序列化和反序列化呢"></a>为什么实现这个接口就能序列化和反序列化呢</h2><ul><li>java序列化代码  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Serializable() &#123;</span><br><span class="line">        String strValue = <span class="string">&quot;这是内容&quot;</span>;</span><br><span class="line">        Integer intValue = <span class="number">999</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    File file = <span class="keyword">new</span> File(System.getProperty(<span class="string">&quot;java.io.tmpdir&quot;</span>), <span class="string">&quot;serializable/&quot;</span>);</span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">    objectOutputStream.writeObject(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样就会把对象序列化到指定的文件中，我们点开writeObject方法看源码一探究竟  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      writeObject0(obj,<span class="keyword">false</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">      <span class="keyword">if</span>(depth==<span class="number">0</span>)&#123;</span><br><span class="line">        writeFatalException(ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// handle previously written and non-replaceable objects</span></span><br><span class="line">            <span class="keyword">int</span> h;</span><br><span class="line">            <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                writeNull();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                writeHandle(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                writeClass((Class) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check for replacement object</span></span><br><span class="line">            Object orig = obj;</span><br><span class="line">            Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">            ObjectStreamClass desc;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// REMIND: skip this check for strings/arrays?</span></span><br><span class="line">                Class&lt;?&gt; repCl;</span><br><span class="line">                desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 如果有无参的writeReplace且返回值为Object类型的方法则会调用</span></span><br><span class="line">                <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">                    (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">                    (repCl = obj.getClass()) == cl)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cl = repCl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">                Object rep = replaceObject(obj);</span><br><span class="line">                <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cl = rep.getClass();</span><br><span class="line">                    desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                obj = rep;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if object replaced, run through original checks a second time</span></span><br><span class="line">            <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">                subs.assign(orig, obj);</span><br><span class="line">                <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    writeNull();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    writeHandle(h);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                    writeClass((Class) obj, unshared);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remaining cases</span></span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                writeString((String) obj, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                writeArray(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">                writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">                <span class="comment">// 这里是重点，如果序列化的对象不是Serializable的实现类，else就会报错</span></span><br><span class="line">                writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                        cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            depth--;</span><br><span class="line">            bout.setBlockDataMode(oldMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以要想[反]序列化对象，类型必须是String|array|enum|Serializable|class，不然就会直接报错</p><ul><li><p>writeOrdinaryObject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bout.writeByte(TC_OBJECT);</span><br><span class="line">            writeClassDesc(desc, <span class="keyword">false</span>);</span><br><span class="line">            handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">            <span class="comment">// 实现java.io.Externalizable接口，可自定义[反]序列化的内容</span></span><br><span class="line">            <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">                writeExternalData((Externalizable) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                writeSerialData(obj, desc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>writeSerialData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">            ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">            <span class="comment">// 当前对象[反]序列化工具类的包装，</span></span><br><span class="line">            <span class="comment">// 如果没有实现java.io.Externalizable自定义[反]序列化接口也没关系</span></span><br><span class="line">            <span class="comment">// 直接把writeObject(序列化)和readObject(反序列化)名称写在你自己的类当中，也可以自定义[反]序列化的内容哦</span></span><br><span class="line">            <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">                PutFieldImpl oldPut = curPut;</span><br><span class="line">                curPut = <span class="keyword">null</span>;</span><br><span class="line">                SerialCallbackContext oldContext = curContext;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.push(</span><br><span class="line">                        <span class="string">&quot;custom writeObject data (class \&quot;&quot;</span> +</span><br><span class="line">                        slotDesc.getName() + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">                    bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                    bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">                    bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    curContext.setUsed();</span><br><span class="line">                    curContext = oldContext;</span><br><span class="line">                    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                        debugInfoStack.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                curPut = oldPut;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 直接获取对象内的字段，进行递归[反]序列化</span></span><br><span class="line">                defaultWriteFields(obj, slotDesc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果类中有writeReplace方法，则会调用，并且序列化的目标类为该方法的返回值</p></li><li><p>defaultWriteFields</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; obj != <span class="keyword">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        desc.checkDefaultSerialize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优先输出基本类型</span></span><br><span class="line">        <span class="keyword">int</span> primDataSize = desc.getPrimDataSize();</span><br><span class="line">        <span class="keyword">if</span> (primVals == <span class="keyword">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">            primVals = <span class="keyword">new</span> <span class="keyword">byte</span>[primDataSize];</span><br><span class="line">        &#125;</span><br><span class="line">        desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">        bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ObjectStreamField[] fields = desc.getFields(<span class="keyword">false</span>);</span><br><span class="line">        Object[] objVals = <span class="keyword">new</span> Object[desc.getNumObjFields()];</span><br><span class="line">        <span class="keyword">int</span> numPrimFields = fields.length - objVals.length;</span><br><span class="line">        desc.getObjFieldValues(obj, objVals);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">&quot;field (class \&quot;&quot;</span> + desc.getName() + <span class="string">&quot;\&quot;, name: \&quot;&quot;</span> +</span><br><span class="line">                    fields[numPrimFields + i].getName() + <span class="string">&quot;\&quot;, type: \&quot;&quot;</span> +</span><br><span class="line">                    fields[numPrimFields + i].getType() + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 继续递归调用</span></span><br><span class="line">                writeObject0(objVals[i],</span><br><span class="line">                             fields[numPrimFields + i].isUnshared());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>除基本类型和String、Enum、class和array外，其他类型想要[反]序列化，必须实现Serializable接口，不然直接报错</p></li><li><p>自定义[反]序列化内容有两种方法，一是直接写方法(writeObject(序列化)|readObject(反序列化))到自己的类中，二是实现java.io.Externalizable接口.<br>writeObject参数类型是ObjectOutputStream<br>readObject参数类型是ObjectInputStream<br><strong>方法返回类型必须为void，private，非static</strong></p></li><li><p>writeReplace返回值为Object类型的方法，可自定义真正序列化的对象</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;实现Serializable接口就能把对象序列化反序列化出去，那么原理是什么呢？&lt;br&gt;带着以下问题一探究竟  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="基础" scheme="https://dongmaxiang.vercel.app/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="序列化" scheme="https://dongmaxiang.vercel.app/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="反序列化" scheme="https://dongmaxiang.vercel.app/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>mybatisPlus分析Lambda语法原理</title>
    <link href="https://dongmaxiang.vercel.app/posts/mybatisplus%E5%88%86%E6%9E%90lambda%E8%AF%AD%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <id>https://dongmaxiang.vercel.app/posts/mybatisplus%E5%88%86%E6%9E%90lambda%E8%AF%AD%E6%B3%95%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-24T23:17:00.000Z</published>
    <updated>2021-07-24T23:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>用lambda就不用写字符串了，这个对于开发业务来说，能减少很多的错误发生。尤其是字段写错了，数据库变更字段名了，等。<br>用法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq(FissionCoupon::getMid, mid)</span><br></pre></td></tr></table></figure><p>他会自动转换为mid，那他的原理是什么呢？<br>原来他接受的是一个可序列化的Function对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SFunction</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实用到了jdk自带的序列化。因为lambda是个特殊的实例，也是个特殊的class。<br>在序列化的时候lambda实例中有一个writeReplace方法。  </p><ul><li>可参考jdk的序列化 <a href="/posts/java%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96serializable%E5%8E%9F%E7%90%86">Serializable原理</a><br>该方法的返回值是一个lambda描述对象，<code>java.lang.invoke.SerializedLambda</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializedLambda</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8025925345765570181L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; capturingClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String functionalInterfaceClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String functionalInterfaceMethodName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String functionalInterfaceMethodSignature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String implClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String implMethodName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String implMethodSignature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> implMethodKind;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String instantiatedMethodType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] capturedArgs;</span><br><span class="line">    。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>通过此对象就能获取到对应的方法名，等信息了。通过方法名去掉get|set|is方法之后就得到字段名称了</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过调用可序列化的lambda实例中的writeReplace方法，获取到lambda对象及可获取到里面的各种信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用lambda就不用写字符串了，这个对于开发业务来说，能减少很多的错误发生。尤其是字段写错了，数据库变更字段名了，等。&lt;br&gt;用法如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="mybatis" scheme="https://dongmaxiang.vercel.app/categories/java/mybatis/"/>
    
    
    <category term="序列化" scheme="https://dongmaxiang.vercel.app/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="反序列化" scheme="https://dongmaxiang.vercel.app/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="mybatis" scheme="https://dongmaxiang.vercel.app/tags/mybatis/"/>
    
    <category term="lambda" scheme="https://dongmaxiang.vercel.app/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>枚举序列化和反序列化的代码</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E6%9E%9A%E4%B8%BE%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E6%9E%9A%E4%B8%BE%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%BB%A3%E7%A0%81/</id>
    <published>2021-07-24T04:20:00.000Z</published>
    <updated>2021-07-24T04:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在java或各种框架中，[反]序列化对枚举类型默认一般都是用的枚举的名称。<br>如果代码有魔法值，我们想改成枚举类型。但我们在改造、重构后端的时候不想对前端或者第三方有影响，可以用到此方法。</p><h1 id="必须用到的枚举工具类"><a href="#必须用到的枚举工具类" class="headerlink" title="必须用到的枚举工具类"></a>必须用到的枚举工具类</h1><ul><li>参考通用枚举 <a href="/posts/%E9%80%9A%E7%94%A8%E6%9E%9A%E4%B8%BE">通用枚举</a><br>所有的枚举想要实现(反)序列化比较要用到通用枚举，实现通用枚举的接口即可</li></ul><h1 id="代码（最初版本）"><a href="#代码（最初版本）" class="headerlink" title="代码（最初版本）"></a>代码（最初版本）</h1><p>1.可反序列化的枚举  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可反序列化的枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DeserializableEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DBEnum是MybatisPlus枚举的adapter，增加了getDoc的方法。MybatisPlus是直接支持数据库[反]序列化的。但是还不支持和前端的[反]序列化的交互，所以在此配置即可。</span></span><br><span class="line">    DB_Enum(DBEnum.class, DBEnum::getValue, DB_Enum::getDoc),</span><br><span class="line">    <span class="comment">// 一个枚举对应单个标识</span></span><br><span class="line">    I_Enum(IEnum.class, IEnum::getIdentity, IEnum::getDoc),</span><br><span class="line">    <span class="comment">// 一个枚举对应多个标识</span></span><br><span class="line">    I_Enums(IEnums.class, IEnums::getIdentities, IEnums::getDoc),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; enumInterface;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;Object, Serializable&gt; getIdentityFunction;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;Object, String&gt; getDocFunction;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; DeserializableEnum(Class&lt;T&gt; enumInterface, Function&lt;T, Serializable&gt; getIdentityFunction, Function&lt;T, String&gt; getDocFunction) &#123;</span><br><span class="line">        <span class="keyword">this</span>.enumInterface = enumInterface;</span><br><span class="line">        <span class="keyword">this</span>.getIdentityFunction = (Function&lt;Object, Serializable&gt;) getIdentityFunction;</span><br><span class="line">        <span class="keyword">this</span>.getDocFunction = (Function&lt;Object, String&gt;) getDocFunction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断class是否可以进行反序列化</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;DeserializableEnum&gt; <span class="title">getDeserializableEnum</span><span class="params">(Class&lt;?&gt; enumClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enumClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!enumClass.isEnum()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (DeserializableEnum deserializableEnum : DeserializableEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deserializableEnum.enumInterface.isAssignableFrom(enumClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Optional.of(deserializableEnum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Enum&lt;?&gt; deserializeEnum(Class&lt;Enum&lt;?&gt;&gt; enumClass, Object rawValue) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Enum&lt;?&gt; enumConstant : enumClass.getEnumConstants()) &#123;</span><br><span class="line">            Serializable identity = <span class="keyword">this</span>.getGetIdentityFunction.apply(enumConstant);</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(identity, rawValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> enumConstant;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (identity <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object i : (Object[]) identity) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Objects.equals(i, rawValue)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> enumConstant;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后值为空则返回null</span></span><br><span class="line">        <span class="keyword">if</span> (rawValue == <span class="keyword">null</span> || StringUtils.isBlank(rawValue.toString())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换失败一律抛异常，后期可根据注解进行动态的抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EnumDeserializeException(MessageFormat.format(<span class="string">&quot;参数错误，无法匹配对应的类型,value:&#123;0&#125;, type:&#123;1&#125;&quot;</span>, rawValue, enumClass.getSimpleName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.枚举[反]序列化的各种框架配置如jackson,fastjson,springConvert等  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDeserializerImpls</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个常量为spring converter 组件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> GenericConverter ENUM_DESERIALIZER_CONVERTER = <span class="keyword">new</span> GenericConverter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Set&lt;ConvertiblePair&gt; cpSet = Sets.newHashSet();</span><br><span class="line">            <span class="keyword">for</span> (DeserializableEnum deserializableEnum : DeserializableEnum.values()) &#123;</span><br><span class="line">                <span class="comment">/* convert匹配逻辑：</span></span><br><span class="line"><span class="comment">                 先循环 sourceType 水平class</span></span><br><span class="line"><span class="comment">                 然后内嵌 targetType 水平class 进行内嵌循环</span></span><br><span class="line"><span class="comment">                 找对对应的ConvertiblePair为止</span></span><br><span class="line"><span class="comment">                 所以sourceType必须比较精确不然覆盖不了defaultConvertor</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                cpSet.add(<span class="keyword">new</span> ConvertiblePair(String.class, deserializableEnum.enumInterface));</span><br><span class="line">                cpSet.add(<span class="keyword">new</span> ConvertiblePair(Number.class, deserializableEnum.enumInterface));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cpSet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">            ResolvableType targetResolvableType = targetType.getResolvableType();</span><br><span class="line">            Class&lt;?&gt; valueRawClass = getValueRawClass(targetResolvableType);</span><br><span class="line">            <span class="keyword">if</span> (valueRawClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> source;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;Enum&lt;?&gt;&gt; enumClass = (Class&lt;Enum&lt;?&gt;&gt;) targetResolvableType.resolve();</span><br><span class="line"></span><br><span class="line">            DeserializableEnum deserializableEnum = DeserializableEnum.getDeserializableEnum(enumClass).orElse(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (deserializableEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> source;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把source转换成枚举真实值的类型</span></span><br><span class="line">            Object rawValue = DefaultConversionService.getSharedInstance().convert(source, valueRawClass);</span><br><span class="line">            <span class="keyword">return</span> deserializableEnum.deserializeEnum(enumClass, rawValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个常量为jacksonModule 组件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleModule ENUM_MODULE = <span class="keyword">new</span> SimpleModule() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupModule</span><span class="params">(SetupContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加枚举反序列化</span></span><br><span class="line">            context.addDeserializers(<span class="keyword">new</span> Deserializers.Base() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> JsonDeserializer&lt;?&gt; findEnumDeserializer(Class&lt;?&gt; type, DeserializationConfig config, BeanDescription beanDesc) &#123;</span><br><span class="line">                    Class&lt;?&gt; valueRawClass = getValueRawClass(ResolvableType.forClass(type));</span><br><span class="line">                    <span class="keyword">if</span> (valueRawClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> DeserializableEnum.getDeserializableEnum(type)</span><br><span class="line">                            .map(deserializableEnum -&gt; <span class="keyword">new</span> JsonDeserializer&lt;Enum&lt;?&gt;&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> Enum&lt;?&gt; deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                                    Object value = DefaultConversionService.getSharedInstance().convert(jsonParser.getValueAsString(), valueRawClass);</span><br><span class="line">                                    <span class="keyword">return</span> deserializableEnum.deserializeEnum((Class&lt;Enum&lt;?&gt;&gt;) type, value);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).orElse(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 定义一个常量为fastJson 组件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Module FASTJSON_MODULE = <span class="keyword">new</span> Module() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ObjectDeserializer <span class="title">createDeserializer</span><span class="params">(ParserConfig config, Class type)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; valueRawClass = getValueRawClass(ResolvableType.forClass(type));</span><br><span class="line">            <span class="keyword">if</span> (valueRawClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> DeserializableEnum.getDeserializableEnum(type)</span><br><span class="line">                    .map(deserializableEnum -&gt; <span class="keyword">new</span> ObjectDeserializer() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> </span>&#123;</span><br><span class="line">                            Object value = parser.parse();</span><br><span class="line"></span><br><span class="line">                            Object rawValue = DefaultConversionService.getSharedInstance().convert(value, valueRawClass);</span><br><span class="line">                            <span class="keyword">return</span> (T) deserializableEnum.deserializeEnum((Class&lt;Enum&lt;?&gt;&gt;) type, rawValue);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFastMatchToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> JSONToken.LITERAL_STRING;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).orElse(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ObjectSerializer <span class="title">createSerializer</span><span class="params">(SerializeConfig config, Class type)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取接口上的泛型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getValueRawClass(ResolvableType realClassResolvedType) &#123;</span><br><span class="line">        ResolvableType[] enumInterfaces = realClassResolvedType.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isEmpty(enumInterfaces)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ResolvableType valueResolvableType = enumInterfaces[<span class="number">0</span>].getGeneric(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (valueResolvableType == ResolvableType.NONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valueResolvableType.getRawClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>1：目前不支持序列化😝<br>2：获取枚举identity类型的方法比较愚钝，一刀切了  </p><blockquote><p>如果是间接实现的枚举或者泛型的位置不在第一个位置，那就有问题喽。  </p></blockquote><p>3：反序列化和序列化只能单层序列和反序列，什么意思呢？</p><blockquote><p>枚举的标识可以获取到枚举对吧？如果枚举的标识还是一个枚举呢？目前只支持序列化和反序列化最外一层的value。太抽象？</p></blockquote><ul><li><p>用户类型1  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserType1</span> <span class="keyword">implements</span> <span class="title">IEnum</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  NEW_USER(<span class="number">1</span>, <span class="string">&quot;新用户&quot;</span>),</span><br><span class="line"></span><br><span class="line">  OLD_USER(<span class="number">0</span>, <span class="string">&quot;老用户&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String doc;</span><br><span class="line"></span><br><span class="line">  UserType1(<span class="keyword">int</span> code, String doc) &#123;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">    <span class="keyword">this</span>.doc = doc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getIdentity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用户类型2  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserType2</span> <span class="keyword">implements</span> <span class="title">IEnum</span>&lt;<span class="title">UserType1</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  NEW_USER(UserType1.NEW_USER, <span class="string">&quot;新用户2&quot;</span>),</span><br><span class="line"></span><br><span class="line">  OLD_USER(UserType1.OLD_USER, <span class="string">&quot;旧用户2&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> UserType1 userType1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String doc;</span><br><span class="line"></span><br><span class="line">  UserType2(UserType1 userType1, String doc) &#123;</span><br><span class="line">    <span class="keyword">this</span>.userType1 = userType1;</span><br><span class="line">    <span class="keyword">this</span>.doc = doc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前枚举的标识是userType1枚举类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserType1 <span class="title">getIdentity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userType1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDoc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用UserType2枚举的话，反序列化或者序列化就会出现缺陷。因为不支持内嵌套一个枚举当做当前枚举的标识。<br>所以有了以下的新代码。</p></li></ul><h1 id="代码（新版本）"><a href="#代码（新版本）" class="headerlink" title="代码（新版本）"></a>代码（新版本）</h1><ul><li>支持序列化啦</li><li>支持枚举内嵌的标识序列化和反序列化</li><li>更精准的获取泛型上的标识</li></ul><p>1.可反序列化的枚举  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可反序列化的枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DeserializableEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DBEnum是MybatisPlus枚举的adapter，增加了getDoc的方法。MybatisPlus是直接支持数据库[反]序列化的。但是还不支持和前端的[反]序列化的交互，所以在此配置即可。</span></span><br><span class="line">    DB_Enum(DBEnum.class, <span class="number">0</span>, DBEnum::getValue, DBEnum::getDoc),</span><br><span class="line">    I_Enum(IEnum.class, <span class="number">0</span>, IEnum::getIdentity, IEnum::getDoc),</span><br><span class="line">    I_Enums(IEnums.class, <span class="number">0</span>, IEnums::getIdentities, IEnums::getDoc),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可反序列化枚举的接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Class&lt;?&gt; enumInterface;</span><br><span class="line">    <span class="comment">// 接口对应的identity(枚举的标识)泛型的下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> identityGenericIndex;</span><br><span class="line">    <span class="comment">// 获取枚举的identity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;Enum&lt;?&gt;, Serializable&gt; getIdentityFunction;</span><br><span class="line">    <span class="comment">// 获取枚举的doc(文档)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Function&lt;Enum&lt;?&gt;, String&gt; getDocFunction;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; DeserializableEnum(Class&lt;T&gt; enumInterface, <span class="keyword">int</span> identityGenericIndex, Function&lt;T, Serializable&gt; getIdentityFunction, Function&lt;T, String&gt; getDocFunction) &#123;</span><br><span class="line">        <span class="keyword">this</span>.enumInterface = enumInterface;</span><br><span class="line">        <span class="keyword">this</span>.identityGenericIndex = identityGenericIndex;</span><br><span class="line">        <span class="keyword">this</span>.getIdentityFunction = (Function&lt;Enum&lt;?&gt;, Serializable&gt;) getIdentityFunction;</span><br><span class="line">        <span class="keyword">this</span>.getDocFunction = (Function&lt;Enum&lt;?&gt;, String&gt;) getDocFunction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Enum&lt;?&gt; deserializeEnum(Class&lt;Enum&lt;?&gt;&gt; enumClass, Object rawValue) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Enum&lt;?&gt; enumConstant : enumClass.getEnumConstants()) &#123;</span><br><span class="line">            Object identity = getIdentity(enumConstant);</span><br><span class="line">            <span class="keyword">if</span> (identity <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object i : (Object[]) identity) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Objects.equals(i, rawValue)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> enumConstant;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(identity, rawValue)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> enumConstant;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后值为空则返回null</span></span><br><span class="line">        <span class="keyword">if</span> (rawValue == <span class="keyword">null</span> || StringUtils.isBlank(rawValue.toString())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换失败一律抛异常，后期可根据注解进行动态的抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EnumDeserializeException(MessageFormat.format(<span class="string">&quot;参数错误，无法匹配对应的类型,value:&#123;0&#125;, type:&#123;1&#125;&quot;</span>, rawValue, enumClass.getSimpleName()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getIdentity</span><span class="params">(Enum&lt;?&gt; enumConstant)</span> </span>&#123;</span><br><span class="line">        Serializable identity = <span class="keyword">this</span>.getIdentityFunction.apply(enumConstant);</span><br><span class="line">        <span class="keyword">if</span> (identity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; identityType;</span><br><span class="line">        <span class="keyword">if</span> (identity <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">            identityType = identity.getClass().getComponentType();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            identityType = identity.getClass();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归判断</span></span><br><span class="line">        DeserializableEnum deserializableEnum = getDeserializableEnumAndIdentityClass(identityType)</span><br><span class="line">                .map(Map.Entry::getKey)</span><br><span class="line">                .orElse(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (deserializableEnum == <span class="keyword">null</span> || !(identity <span class="keyword">instanceof</span> Enum&lt;?&gt;)) &#123;</span><br><span class="line">            <span class="keyword">return</span> identity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserializableEnum.getIdentity((Enum&lt;?&gt;) identity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取接口上标识枚举值的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; getValueRawClass(Class&lt;?&gt; enumInterface) &#123;</span><br><span class="line">        ResolvableType resolvableType = ResolvableType.forClass(enumInterface).as(<span class="keyword">this</span>.enumInterface);</span><br><span class="line">        Class&lt;?&gt; valueRawClass = resolvableType.getGeneric(<span class="keyword">this</span>.identityGenericIndex).resolve();</span><br><span class="line">        <span class="comment">// 判断递归获取</span></span><br><span class="line">        DeserializableEnum deserializableEnum = DeserializableEnum.getDeserializableEnumAndIdentityClass(valueRawClass)</span><br><span class="line">                .map(Map.Entry::getKey)</span><br><span class="line">                .orElse(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (deserializableEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> valueRawClass;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deserializableEnum.getValueRawClass(valueRawClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Map.Entry&lt;DeserializableEnum, Class&lt;?&gt;&gt;&gt; getDeserializableEnumAndIdentityClass(Class&lt;?&gt; enumClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (enumClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!enumClass.isEnum()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (DeserializableEnum deserializableEnum : DeserializableEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deserializableEnum.enumInterface.isAssignableFrom(enumClass)) &#123;</span><br><span class="line">                Class&lt;?&gt; identityValueRawClass = deserializableEnum.getValueRawClass(enumClass);</span><br><span class="line">                <span class="keyword">return</span> Optional.of(Pair.of(deserializableEnum, identityValueRawClass));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.枚举[反]序列化的各种框架配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDeserializerImpls</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * spring converter反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> GenericConverter ENUM_DESERIALIZER_CONVERTER = <span class="keyword">new</span> GenericConverter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Set&lt;ConvertiblePair&gt; cpSet = Sets.newHashSet();</span><br><span class="line">            <span class="keyword">for</span> (DeserializableEnum deserializableEnum : DeserializableEnum.values()) &#123;</span><br><span class="line">                <span class="comment">/* 匹配逻辑：</span></span><br><span class="line"><span class="comment">                 先循环 sourceType 水平class</span></span><br><span class="line"><span class="comment">                 然后内嵌 targetType 水平class 进行内嵌循环</span></span><br><span class="line"><span class="comment">                 找对对应的ConvertiblePair为止</span></span><br><span class="line"><span class="comment">                 所以sourceType必须比较精确不然覆盖不了defaultConvertor</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                cpSet.add(<span class="keyword">new</span> ConvertiblePair(String.class, deserializableEnum.enumInterface));</span><br><span class="line">                cpSet.add(<span class="keyword">new</span> ConvertiblePair(Number.class, deserializableEnum.enumInterface));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cpSet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = targetType.getResolvableType().resolve();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> DeserializableEnum.getDeserializableEnumAndIdentityClass(targetClass)</span><br><span class="line">                    .map((Function&lt;Map.Entry&lt;DeserializableEnum, Class&lt;?&gt;&gt;, Object&gt;) entry -&gt; &#123;</span><br><span class="line">                        Object rawValue = DefaultConversionService.getSharedInstance().convert(source, entry.getValue());</span><br><span class="line">                        <span class="keyword">return</span> entry.getKey().deserializeEnum((Class&lt;Enum&lt;?&gt;&gt;) targetClass, rawValue);</span><br><span class="line">                    &#125;).orElse(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jacksonModule序列化和反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleModule ENUM_MODULE = <span class="keyword">new</span> SimpleModule() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupModule</span><span class="params">(SetupContext context)</span> </span>&#123;</span><br><span class="line">            context.addSerializers(<span class="keyword">new</span> Serializers.Base() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> JsonSerializer&lt;?&gt; findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) &#123;</span><br><span class="line">                    <span class="keyword">return</span> DeserializableEnum.getDeserializableEnumAndIdentityClass(type.getRawClass())</span><br><span class="line">                            .map(Map.Entry::getKey)</span><br><span class="line">                            .map(deserializableEnum -&gt; <span class="keyword">new</span> JsonSerializer&lt;Enum&lt;?&gt;&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Enum&lt;?&gt; o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                                    jsonGenerator.writeObject(deserializableEnum.getIdentity(o));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).orElse(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            context.addDeserializers(<span class="keyword">new</span> Deserializers.Base() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> JsonDeserializer&lt;?&gt; findEnumDeserializer(Class&lt;?&gt; type, DeserializationConfig config, BeanDescription beanDesc) &#123;</span><br><span class="line">                    <span class="keyword">return</span> DeserializableEnum.getDeserializableEnumAndIdentityClass(type)</span><br><span class="line">                            .map(entry -&gt; <span class="keyword">new</span> JsonDeserializer&lt;Enum&lt;?&gt;&gt;() &#123;</span><br><span class="line">                                <span class="keyword">public</span> Enum&lt;?&gt; deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                                    Object value = DefaultConversionService.getSharedInstance().convert(jsonParser.getValueAsString(), entry.getValue());</span><br><span class="line">                                    <span class="keyword">return</span> entry.getKey().deserializeEnum((Class&lt;Enum&lt;?&gt;&gt;) type, value);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).orElse(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * fastJson 枚举序列化和反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Module FASTJSON_MODULE = <span class="keyword">new</span> Module() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ObjectDeserializer <span class="title">createDeserializer</span><span class="params">(ParserConfig config, Class type)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DeserializableEnum.getDeserializableEnumAndIdentityClass(type)</span><br><span class="line">                    .map(entry -&gt; <span class="keyword">new</span> ObjectDeserializer() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> </span>&#123;</span><br><span class="line">                            Object rawValue = DefaultConversionService.getSharedInstance().convert(parser.parse(), entry.getValue());</span><br><span class="line">                            <span class="keyword">return</span> (T) entry.getKey().deserializeEnum((Class&lt;Enum&lt;?&gt;&gt;) type, rawValue);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFastMatchToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> JSONToken.LITERAL_STRING;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).orElse(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ObjectSerializer <span class="title">createSerializer</span><span class="params">(SerializeConfig config, Class type)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DeserializableEnum.getDeserializableEnumAndIdentityClass(type)</span><br><span class="line">                    .map(entry -&gt; <span class="keyword">new</span> ObjectSerializer() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, <span class="keyword">int</span> features)</span> </span>&#123;</span><br><span class="line">                            serializer.write(entry.getKey().getIdentity((Enum&lt;?&gt;) object));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).orElse(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本实现以及各种框架的组件都已经定义出来了，可以参考<a href="/posts/mvc%E6%9E%9A%E4%B8%BE%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%85%8D%E7%BD%AE">springMvc枚举序列化和反序列化</a>，把这些实现应用到实际的项目当中。<br>然后我们用各种枚举什么的，后端可以安心的进行重构（使用）了</p><blockquote><p>新代码用到了递归，如果不理解旧代码的话阅读起来比较复杂。建议先理解旧代码在阅读新代码</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在java或各种框架中，[反]序列化对枚举类型默认一般都是用的枚举的名称。&lt;br&gt;如果代码有魔法值，我们想改成枚举类型。但我们在改造、重构后端的时候不想对前端或者第三方有影响，可以用到此方法。&lt;/p&gt;
&lt;h1 id=&quot;必须用到的枚举工具类&quot;&gt;&lt;a href=&quot;#必须用到的枚</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="枚举" scheme="https://dongmaxiang.vercel.app/categories/java/%E6%9E%9A%E4%B8%BE/"/>
    
    
    <category term="效率" scheme="https://dongmaxiang.vercel.app/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="枚举" scheme="https://dongmaxiang.vercel.app/tags/%E6%9E%9A%E4%B8%BE/"/>
    
    <category term="序列化" scheme="https://dongmaxiang.vercel.app/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="反序列化" scheme="https://dongmaxiang.vercel.app/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>mvc枚举序列化和反序列化的配置</title>
    <link href="https://dongmaxiang.vercel.app/posts/mvc%E6%9E%9A%E4%B8%BE%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://dongmaxiang.vercel.app/posts/mvc%E6%9E%9A%E4%B8%BE%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2021-07-12T18:49:00.000Z</published>
    <updated>2021-07-12T18:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="必须用到的枚举工具类"><a href="#必须用到的枚举工具类" class="headerlink" title="必须用到的枚举工具类"></a>必须用到的枚举工具类</h1><ul><li>参考通用枚举 <a href="/posts/%E9%80%9A%E7%94%A8%E6%9E%9A%E4%B8%BE">通用枚举</a></li></ul><h1 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h1><p>spring mvc 接收或者序列化枚举类型时，默认是根据枚举的名称(string)进行序列化或者反序列化。<br>但是在实际开发当中，我们一般用枚举代表某一个数值，数据库存储值。同时我们也希望和前端交互用数值交互，而不是string名称。因此用到这个工具类<br>支持以下几个组件的反序列化和序列化</p><ul><li>spring convert<br>@RequestParam<br>@PathVariable<br>...  </li><li>jackson<br>@ResponseBody</li><li>fastjson<br>JSON.parseObject(...)</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul><li>枚举序列化和反序列化的代码 <a href="/posts/%E6%9E%9A%E4%B8%BE%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%BB%A3%E7%A0%81">枚举序列化和反序列化的代码</a></li></ul><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><span id="springconverter组件的使用"></span><h2 id="springConverter组件的使用"><a href="#springConverter组件的使用" class="headerlink" title="springConverter组件的使用"></a>springConverter组件的使用</h2><p>spring 接收参数为form表单请求时，默认用的converter组件进行转换对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEnumConverter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addConverter(EnumDeserializerImpls.ENUM_DESERIALIZER_CONVERTER);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jackson序列化和反序列化的使用"><a href="#jackson序列化和反序列化的使用" class="headerlink" title="jackson序列化和反序列化的使用"></a>jackson序列化和反序列化的使用</h2><p>spring的@RequestBody,@ResponseBody 默认使用jackson进行反序列化和序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEnumJacksonModule</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : converters) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(converter <span class="keyword">instanceof</span> MappingJackson2HttpMessageConverter)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ((MappingJackson2HttpMessageConverter) converter).getObjectMapper()</span><br><span class="line">              .registerModule(EnumDeserializerImpls.ENUM_MODULE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="fastjson的使用"></span><h2 id="fastJson的使用"><a href="#fastJson的使用" class="headerlink" title="fastJson的使用"></a>fastJson的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ParserConfig.getGlobalInstance().register(EnumDeserializerImpls.FASTJSON_MODULE);</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">SerializeConfig.getGlobalInstance().register(EnumDeserializerImpls.FASTJSON_MODULE);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们定义好通用枚举之后，所有枚举实现通用枚举的接口。在定义枚举的序列化实现，然后在定义各自(反)序列化框架的实现<br>最后我们把各种(反)序列化枚举的实现配置到spring容器中，最终才生效。<br>这样配置好之后呢，可以直接用枚举当做接收参数和返回参数了。前端交互用的还是数值类型哦。<br>这样针对老项目重构的时候可以在不影响前端的情况下，后端全部可以改成枚举哦。  </p><p>数据库枚举的序列化和反序列化-mybatisPlus目前是直接支持的。参考mybatisPlus的文档即可。但是前端交互用数值的话需要配合此代码才行哦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;必须用到的枚举工具类&quot;&gt;&lt;a href=&quot;#必须用到的枚举工具类&quot; class=&quot;headerlink&quot; title=&quot;必须用到的枚举工具类&quot;&gt;&lt;/a&gt;必须用到的枚举工具类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;参考通用枚举 &lt;a href=&quot;/posts/%E9%80%9A</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="枚举" scheme="https://dongmaxiang.vercel.app/categories/java/%E6%9E%9A%E4%B8%BE/"/>
    
    
    <category term="效率" scheme="https://dongmaxiang.vercel.app/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="枚举" scheme="https://dongmaxiang.vercel.app/tags/%E6%9E%9A%E4%B8%BE/"/>
    
    <category term="序列化" scheme="https://dongmaxiang.vercel.app/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="反序列化" scheme="https://dongmaxiang.vercel.app/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="mvc" scheme="https://dongmaxiang.vercel.app/tags/mvc/"/>
    
  </entry>
  
  <entry>
    <title>业务开发如何优雅的编写代码</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81/</id>
    <published>2021-07-12T07:29:00.000Z</published>
    <updated>2021-07-12T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们开发人员，基本都是从搬砖的码农做起，但也有非常优秀的人，一直在做中间件或其他底层通用的逻辑。显然，我们大多数都不够优秀。那针对业务开发的我们也需要提升自己的技能，而不是每天的CURD，为了提升我们自己，所以在我们的日常开发工作中不仅仅完成任务作为目标，至少还有一些目标之外的思维，如</p><ul><li>代码阅读性高吗？</li><li>代码便于维护或协作吗？</li><li>代码会不会冗余？</li><li>怎样用更精简的方法实现它呢？</li><li>自己有没有重复造轮子呢？</li><li>...  </li></ul><p>如果缺少了这些思维的话，那你适合做管理层。<br>本文是个总结文，就拿我常在开发中用到的技术展开交流。需要读者点开其他文章依次观看😂</p><blockquote><p>springboot + mvc + mybatisPlus + dubbo + Saas业务</p></blockquote><h2 id="定义通用枚举"><a href="#定义通用枚举" class="headerlink" title="定义通用枚举"></a>定义通用枚举</h2><ul><li><p><a href="/posts/%E9%80%9A%E7%94%A8%E6%9E%9A%E4%B8%BE">通用枚举</a><br>避免魔法值、统一枚举的<strong>获取方式</strong></p></li><li><p><a href="/posts/mvc%E6%9E%9A%E4%B8%BE%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%85%8D%E7%BD%AE">springMvc枚举(反)序列化配置</a><br>定义好通用枚举之后也要配置好(反)序列化，mybatisPlus也支持枚举，结合起来。项目当中能够完全避免魔法值的产生</p></li><li><p>定义一个<a href="/posts/%E8%8E%B7%E5%8F%96spring%E5%90%AF%E5%8A%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB">获取当前环境的枚举的工具类</a><br>这个很有必要，在复杂业务的情况下，不同业务，不同环境下逻辑也不一样。比如说swagger不能在线上开启，热部署禁止在线上使用等  </p></li></ul><span id="重新加装mybatis-plus-业务开发必备"></span><h2 id="重新加装Mybatis-plus-业务开发必备"><a href="#重新加装Mybatis-plus-业务开发必备" class="headerlink" title="重新加装Mybatis-plus(业务开发必备)"></a>重新加装Mybatis-plus(业务开发必备)</h2><ul><li><p><a href="/posts/%E9%87%8D%E6%96%B0%E5%8A%A0%E8%A3%85mybatisplus">重新加装MybatisPlus</a><br>字段填充器、软删除使字段填充器生效、查询软删除的数据、避免字符串编程、避免空指针等等</p></li><li><p><a href="/posts/mybatisplus%E9%92%88%E5%AF%B9saas%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%8F%92%E4%BB%B6">MybatisPlus针对Saas系统的动态多租户插件</a><br>针对多租户Saas系统，这个插件可以极大的提高我们开发人员的工作效率，不用关心多租户的业务</p></li></ul><h2 id="定义代码校验（协作开发必备）"><a href="#定义代码校验（协作开发必备）" class="headerlink" title="定义代码校验（协作开发必备）"></a>定义代码校验（协作开发必备）</h2><p>虽然我们有代码分层的设计，但是还是会写出林乱不堪的代码。<br>如何让别人写出可阅读的代码、可维护的代码呢？如何强制实现代码规范？  </p><ul><li><a href="/posts/mybatisplus%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E6%A0%A1%E9%AA%8C">MybatisPlus语法糖的校验</a><br>我们用mybatisPlus语法糖可代替很多sql。但是保证不了会在别的地方出现。那么如何保证我们sql语法糖的规范统一呢，那就用sql语法糖的校验。  </li><li><a href="/posts/%E5%9F%BA%E4%BA%8Espring%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E6%A0%A1%E9%AA%8C">基于Spring的代码分层校验</a><br>领域驱动DDD你应该听过吧？DDD过于抽象，实际项目当中用好DDD并不容易。<strong>这样分层更合理，且更容易维护</strong>(吸取了DDD的精髓)。</li></ul><h2 id="定义统一异常拦截处理类"><a href="#定义统一异常拦截处理类" class="headerlink" title="定义统一异常拦截处理类"></a>定义统一异常拦截处理类</h2><ul><li><a href="/posts/springmvc%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">springMvc统一异常处理</a>  </li><li><a href="/posts/spring%E4%BA%8B%E5%8A%A1%E5%92%8Caop%E7%9A%84%E5%8E%9F%E7%90%86#%E8%AE%BE%E7%BD%AE%E4%BA%8B%E5%8A%A1%E5%AF%B9%E6%89%80%E6%9C%89%E7%9A%84%E5%BC%82%E5%B8%B8%E8%BF%9B%E8%A1%8C%E5%9B%9E%E6%BB%9A">设置事务对所有的异常进行回滚</a><br>事务回滚默认为RuntimeException和Error<br>如捕获异常也需要事务回滚，但是还不想修改注解的话可以用这种方式，这种方法是全局生效的  </li></ul><h2 id="定义日志打印帮助问题排查"><a href="#定义日志打印帮助问题排查" class="headerlink" title="定义日志打印帮助问题排查"></a>定义日志打印帮助问题排查</h2><p><a href="">http日志链路追踪</a><br><a href="">request记录请求体中的数据</a><br><a href="">dubbo日志链路追踪</a>  </p><h2 id="定义统一响应包装类"><a href="#定义统一响应包装类" class="headerlink" title="定义统一响应包装类"></a>定义统一响应包装类</h2><ul><li><p><a href="/posts/mvc%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E5%8C%85%E8%A3%85">mvc对外提供统一响应包装</a>  </p></li><li><p><a href="">强制后端的提示信息实现的in18国际化</a>  </p></li></ul><h2 id="定义swagger通用接口文档"><a href="#定义swagger通用接口文档" class="headerlink" title="定义swagger通用接口文档"></a>定义swagger通用接口文档</h2><ul><li><a href="/posts/%E5%AE%9A%E4%B9%89swagger%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3">定义swagger通用接口文档</a>我们用的swagger版本为</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>由于swagger的分组在配置文件中不支持中文，所以我们给他改成中文  </li><li>由于我们统一了http最外层的响应包装，swagger是检测不出来的，所以我们要给他加上最外层的响应包装  </li><li>由于我们统一了枚举，swagger也是检测不出来的，所以我们要给他加上枚举的注释以及对应的value  </li></ol><h2 id="危险，集成热部署工具（线上禁止使用）"><a href="#危险，集成热部署工具（线上禁止使用）" class="headerlink" title="危险，集成热部署工具（线上禁止使用）"></a>危险，集成热部署工具（线上禁止使用）</h2><ul><li><a href="/posts/%E8%A7%A3%E5%86%B3springremoterestart%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8#%E4%BC%98%E5%8C%96%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%87%8F%E5%B0%91%E9%83%A8%E7%BD%B2%E6%97%B6%E9%97%B4">springDevTools+jdkInstruments实现热部署</a><br>自己编写的简单热部署工具，不用运维、不用第三方庞大的插件。只需要有http服务的接口即可,非常简易</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;我们开发人员，基本都是从搬砖的码农做起，但也有非常优秀的人，一直在做中间件或其他底层通用的逻辑。显然，我们大多数都不够优秀。
那针对业务开发</summary>
      
    
    
    
    <category term="效率" scheme="https://dongmaxiang.vercel.app/categories/%E6%95%88%E7%8E%87/"/>
    
    <category term="java开发" scheme="https://dongmaxiang.vercel.app/categories/%E6%95%88%E7%8E%87/java%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="效率" scheme="https://dongmaxiang.vercel.app/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>奇葩说-刘秦vs薛兆丰</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E5%A5%87%E8%91%A9%E8%AF%B4-%E5%88%98%E7%A7%A6vs%E8%96%9B%E5%85%86%E4%B8%B0/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E5%A5%87%E8%91%A9%E8%AF%B4-%E5%88%98%E7%A7%A6vs%E8%96%9B%E5%85%86%E4%B8%B0/</id>
    <published>2021-07-05T22:24:00.000Z</published>
    <updated>2021-07-05T22:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>总感觉我一个文盲谈论一个权威极高的教授实在是没有资格。但也确实这样（没有资格）。但我观察这两个教授的言行并总结下来能够对我有很大帮助</p><h1 id="第7季"><a href="#第7季" class="headerlink" title="第7季"></a>第7季</h1><p>宋丹丹来的那一季<del>因为我只看了20分钟，印象不深，但是薛老师的观点我特别赞同，所以印象特别深</del></p><h2 id="薛兆丰"><a href="#薛兆丰" class="headerlink" title="薛兆丰"></a>薛兆丰</h2><ul><li><p>痛苦不是成本，损失一个机会才是成本  </p><blockquote><p>痛苦是可以磨炼人的意志力的。对你来说并没有损失什么，只是心情上的落差。但是在现有的社会中没有人会关心你的心情，人毕竟是自私自利的。所以在三观正常、态度正确的情况下你应该为你争取更多的机会。而不是胆怯和懦弱</p></blockquote></li><li><p>做难做的工作，谈简单的恋爱  </p><blockquote><p>人是琢磨不透的，月有阴晴圆缺，人有阴晴不定，如果你谈难谈的恋爱，很有可能结果是一场空。但是你做难做的工作，对你来说都是阅历、知识和经验、对以后事业是有帮助的（毕竟人还是要独立的）。虽然你谈复杂的恋爱也有经历和经验，也能傍大款，但是一但你换对象（换工作）会给人的感觉你不忠，能天天傍大款吗？再说傍大款也需要你有内在的谈吐（就是你肚子里有没有墨水）。更何况不忠映射到工作上来呢（Boss会录用一个不忠的人吗）？所以一定要做做难做的工作，谈简单的恋爱</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总感觉我一个文盲谈论一个权威极高的教授实在是没有资格。但也确实这样（没有资格）。但我观察这两个教授的言行并总结下来能够对我有很大帮助&lt;/p&gt;
&lt;h1 id=&quot;第7季&quot;&gt;&lt;a href=&quot;#第7季&quot; class=&quot;headerlink&quot; title=&quot;第7季&quot;&gt;&lt;/a&gt;第7季</summary>
      
    
    
    
    <category term="生活" scheme="https://dongmaxiang.vercel.app/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="感想" scheme="https://dongmaxiang.vercel.app/categories/%E7%94%9F%E6%B4%BB/%E6%84%9F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>js-copy</title>
    <link href="https://dongmaxiang.vercel.app/posts/js-copy/"/>
    <id>https://dongmaxiang.vercel.app/posts/js-copy/</id>
    <published>2021-07-05T22:24:00.000Z</published>
    <updated>2021-07-05T22:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>觉得手动copy麻烦的话，写一个小脚本，执行即可copy  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取val</span></span><br><span class="line"><span class="keyword">let</span> val = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 这段代码是我们在confluence 维护的sql代码片段。执行即可获取全部的sql</span></span><br><span class="line">$(<span class="string">&#x27;.code .container div&#x27;</span>).each(<span class="function">(<span class="params">i,e</span>)=&gt;</span>val+= $(e).text() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行copy</span></span><br><span class="line"><span class="keyword">let</span> input = <span class="built_in">document</span>.createElement(<span class="string">&#x27;textarea&#x27;</span>);</span><br><span class="line">input.value = val;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(input);</span><br><span class="line">input.select();</span><br><span class="line"><span class="built_in">document</span>.execCommand(<span class="string">&#x27;copy&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(input);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;觉得手动copy麻烦的话，写一个小脚本，执行即可copy  &lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br</summary>
      
    
    
    
    <category term="js" scheme="https://dongmaxiang.vercel.app/categories/js/"/>
    
    
    <category term="js" scheme="https://dongmaxiang.vercel.app/tags/js/"/>
    
    <category term="开发工具类" scheme="https://dongmaxiang.vercel.app/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>我的第一本人生规划手册</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%BA%BA%E7%94%9F%E8%A7%84%E5%88%92%E6%89%8B%E5%86%8C/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%BA%BA%E7%94%9F%E8%A7%84%E5%88%92%E6%89%8B%E5%86%8C/</id>
    <published>2021-07-04T21:07:00.000Z</published>
    <updated>2021-07-04T21:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的第一本人生规划手册"><a href="#我的第一本人生规划手册" class="headerlink" title="我的第一本人生规划手册"></a>我的第一本人生规划手册</h1><ul><li>小孩子为什么会情绪崩溃大哭？因为当脑子中的词汇量无法精准表达自己情绪的时候，只能情绪大哭。<blockquote><p>我理解一旦有失落的时候，情绪不好的时候，一定要找人倾诉，表达出来。其实就是释放出来，但不一定倾听者是人。主要就是不能憋着。</p></blockquote></li></ul><h2 id="5w2h1e"><a href="#5w2h1e" class="headerlink" title="5w2h1e"></a>5w2h1e</h2><ul><li><p>why、what、who、when、where<br>为什么要干什么，谁，何时何地  </p></li><li><p>how、how much<br>怎么做，需要多少资源？  </p></li><li><p>effect<br>预测结果，有什么样的效果？</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的第一本人生规划手册&quot;&gt;&lt;a href=&quot;#我的第一本人生规划手册&quot; class=&quot;headerlink&quot; title=&quot;我的第一本人生规划手册&quot;&gt;&lt;/a&gt;我的第一本人生规划手册&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;小孩子为什么会情绪崩溃大哭？因为当脑子中的词汇量无法精准</summary>
      
    
    
    
    <category term="生活" scheme="https://dongmaxiang.vercel.app/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="书籍" scheme="https://dongmaxiang.vercel.app/categories/%E7%94%9F%E6%B4%BB/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="书籍" scheme="https://dongmaxiang.vercel.app/tags/%E4%B9%A6%E7%B1%8D/"/>
    
    <category term="读书笔记" scheme="https://dongmaxiang.vercel.app/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>通用枚举</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E9%80%9A%E7%94%A8%E6%9E%9A%E4%B8%BE/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E9%80%9A%E7%94%A8%E6%9E%9A%E4%B8%BE/</id>
    <published>2021-07-01T23:15:00.000Z</published>
    <updated>2021-07-01T23:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>我们一般用枚举来代表数字或者字符串，避免魔法值的产生。有时需要根据数字或字符串获取到对应的枚举。虽然可以在枚举里面写静态方法根据int获取对应的枚举也可以做到，但是你需要在一个枚举写一个方法，如果有N多个枚举则会非常的冗余<br>类似于这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">  ONCE(<span class="number">0</span>, <span class="string">&quot;满&quot;</span>),</span><br><span class="line">  EACH_TIMES(<span class="number">1</span>, <span class="string">&quot;每满&quot;</span>),</span><br><span class="line">  LADDERED(<span class="number">2</span>, <span class="string">&quot;阶梯满&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">  Condition(<span class="keyword">int</span> code, String name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似于这段代码</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Condition <span class="title">getTypeByCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Condition value : Condition.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value.getCode() == code) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免<strong>冗余代码</strong>，所以用到此工具类，用法就是所有的枚举需要实现此类即可进行使用</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="一个枚举可以有多个标识"><a href="#一个枚举可以有多个标识" class="headerlink" title="一个枚举可以有多个标识"></a><span id='一个枚举对应多个标识'>一个枚举可以有多个标识</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IdentityIEnums</span></span><br><span class="line"><span class="comment"> * 可以有多个标识的枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> anyOne</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEnums</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取枚举的标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T[] getIdentities();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举对应的文档，描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getDoc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入指定的枚举class，和指定的identity(变量标识)</span></span><br><span class="line"><span class="comment">     * 如果枚举的identity和传入的相等则返回对应的枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T extends Serializable, E extends IEnums&lt;T&gt;&gt; <span class="function">E <span class="title">mustGetEnum</span><span class="params">(Class&lt;E&gt; enumClass, T identity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEnum(enumClass, identity)</span><br><span class="line">                .orElseThrow(NullPointerException::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T extends Serializable, E extends IEnums&lt;T&gt;&gt; <span class="function">Optional&lt;E&gt; <span class="title">getEnum</span><span class="params">(Class&lt;E&gt; enumClass, T identity)</span> </span>&#123;</span><br><span class="line">        E e = getEnum(enumClass, identity, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T extends Serializable, E extends IEnums&lt;T&gt;&gt; <span class="function">E <span class="title">getEnum</span><span class="params">(Class&lt;E&gt; enumClass, T identity, E defaultValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (E enumConstant : enumClass.getEnumConstants()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : enumConstant.getIdentities()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(t, identity)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> enumConstant;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个枚举对应一个标识"><a href="#一个枚举对应一个标识" class="headerlink" title="一个枚举对应一个标识"></a>一个枚举对应一个标识</h3><ul><li><p>util  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">// 单个变成数组util</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectUtils</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">commons</span>.<span class="title">lang3</span>.<span class="title">ObjectUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; T[] array(T... t) &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码复用、继承即可，最终还是调用<a href="#%E4%B8%80%E4%B8%AA%E6%9E%9A%E4%B8%BE%E5%AF%B9%E5%BA%94%E5%A4%9A%E4%B8%AA%E6%A0%87%E8%AF%86">一个枚举对应多个标识</a>那个工具类  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ObjectUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEnum</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">IEnums</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取枚举的标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">getIdentity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认实现获取多个标识 </span></span><br><span class="line">    <span class="keyword">default</span> T[] getIdentities() &#123;</span><br><span class="line">        <span class="keyword">return</span> ObjectUtils.array(getIdentity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用例子一"><a href="#使用例子一" class="headerlink" title="使用例子一"></a>使用例子一</h2><ul><li><p>工具类  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ENV</span> <span class="keyword">implements</span> <span class="title">IEnums</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    RELEASE(<span class="string">&quot;release&quot;</span>, <span class="string">&quot;prod&quot;</span>),</span><br><span class="line">    PRE(<span class="string">&quot;pre&quot;</span>),</span><br><span class="line">    TEST(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test1&quot;</span>, <span class="string">&quot;test2&quot;</span>, <span class="string">&quot;test3&quot;</span>),</span><br><span class="line">    DEV(<span class="string">&quot;dev&quot;</span>),</span><br><span class="line">    LOCAL(<span class="string">&quot;local&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] envs;</span><br><span class="line"></span><br><span class="line">    ENV(String... envs) &#123;</span><br><span class="line">        <span class="keyword">this</span>.envs = envs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要实现此方法即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getIdentities() &#123;</span><br><span class="line">        <span class="keyword">return</span> envs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用详情  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV env = IEnums.getEnum(ENV.class, <span class="string">&quot;dev&quot;</span>, RELEASE);</span><br><span class="line">ENV test1 = IEnums.getEnum(ENV.class, <span class="string">&quot;test1&quot;</span>, RELEASE);</span><br><span class="line">ENV test2 = IEnums.getEnum(ENV.class, <span class="string">&quot;test2&quot;</span>, RELEASE);</span><br><span class="line"><span class="keyword">assert</span> test1 == test2;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用例子二"><a href="#使用例子二" class="headerlink" title="使用例子二"></a>使用例子二</h2><ul><li><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserType</span> <span class="keyword">implements</span> <span class="title">IEnum</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  NEW_USER(<span class="number">1</span>, <span class="string">&quot;新用户&quot;</span>),</span><br><span class="line"></span><br><span class="line">  OLD_USER(<span class="number">0</span>, <span class="string">&quot;老用户&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String doc;</span><br><span class="line"></span><br><span class="line">  UserType(<span class="keyword">int</span> code, String doc) &#123;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">    <span class="keyword">this</span>.doc = doc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getIdentity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDoc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用详情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;UserType&gt; type = IEnums.getEnum(UserType.class, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在项目中，把我们的枚举统一归纳起来，所有的枚举实现此类接口。这样就可以直接爽快的使用了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h1&gt;&lt;p&gt;我们一般用枚举来代表数字或者字符串，避免魔法值的产生。
有时需要根据数字或字符串获取到对应的枚举。
虽然可以在枚举里面写静态</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="枚举" scheme="https://dongmaxiang.vercel.app/categories/java/%E6%9E%9A%E4%B8%BE/"/>
    
    
    <category term="开发工具类" scheme="https://dongmaxiang.vercel.app/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/tags/java/"/>
    
    <category term="枚举" scheme="https://dongmaxiang.vercel.app/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>javaUtil动态代理</title>
    <link href="https://dongmaxiang.vercel.app/posts/javautil%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://dongmaxiang.vercel.app/posts/javautil%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2021-07-01T02:58:55.000Z</published>
    <updated>2021-07-01T02:58:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>动态代理有很多使用的场景，比如  </p><ul><li>springAOP切入</li><li>spring事务、缓存</li><li>自定义业务场景等</li></ul><p>本文就是一个动态代理util。为了使用起来更加的方便。之后的文章也有可能用得到。  </p><blockquote><p>后续用新文章来分析动态代理的原理</p></blockquote><p><a href="#%E6%9C%AC%E6%96%87%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">本文的使用场景（点我）</a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ClassUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ReflectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> anyOne</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/4/30 12:19 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ignoreObjectMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] arguments;</span><br><span class="line">    <span class="keyword">private</span> CallBack&lt;T&gt; callBack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(T proxyTarget, Object... arguments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(proxyTarget, <span class="keyword">true</span>, arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(T proxyTarget, <span class="keyword">boolean</span> ignoreObjectMethod, Object... arguments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = proxyTarget;</span><br><span class="line">        <span class="keyword">this</span>.ignoreObjectMethod = ignoreObjectMethod;</span><br><span class="line">        <span class="keyword">this</span>.targetClass = proxyTarget.getClass();</span><br><span class="line">        <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略所有的set方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getProxyWithWriteMethod</span><span class="params">(CallBack&lt;T&gt; callBack)</span> </span>&#123;</span><br><span class="line">        Set&lt;Method&gt; ignoreMethodNames = Stream.of(BeanUtils.getPropertyDescriptors(targetClass))</span><br><span class="line">                .map(PropertyDescriptor::getWriteMethod)</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.callBack = (obj, proxyMethod, args, originMethod) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ignoreMethodNames.contains(originMethod)) &#123;</span><br><span class="line">                <span class="keyword">return</span> callBack.call(target, proxyMethod, args, originMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> proxyMethod.invoke(target, args);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> getT();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getProxy</span><span class="params">(CallBack&lt;T&gt; callBack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callBack = callBack;</span><br><span class="line">        <span class="keyword">return</span> getT();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(targetClass);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> create(enhancer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果针对class创建失败，则只针对接口创建代理</span></span><br><span class="line">            enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            Class&lt;?&gt;[] allInterfacesForClass = ClassUtils.getAllInterfacesForClass(targetClass);</span><br><span class="line">            enhancer.setInterfaces(allInterfacesForClass);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> create(enhancer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">create</span><span class="params">(Enhancer enhancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arguments == <span class="keyword">null</span> || arguments.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class&lt;?&gt;[] classes = Stream.of(arguments)</span><br><span class="line">                    .map(Object::getClass)</span><br><span class="line">                    .toArray(Class[]::<span class="keyword">new</span>);</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="keyword">return</span> (T) enhancer.create(classes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method originMethod, Object[] args, MethodProxy proxyMethod)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ignoreObjectMethod &amp;&amp; ReflectionUtils.isObjectMethod(originMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> proxyMethod.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> callBack.call(target, proxyMethod, args, originMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 代理拦截的方法，需要用户自己实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">Object <span class="title">call</span><span class="params">(T target, MethodProxy proxyMethod, Object[] args, Method originMethod)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方式之一"><a href="#使用方式之一" class="headerlink" title="使用方式之一"></a><span id='本文的使用场景'>使用方式之一</span></h2><p>分页查询只想查询一个，但是每次new对象在去赋值，非常浪费时间。并且还会出遗漏的问题<br>所以建一个全局的对象，但是这个全局的对象，他又是多线程共享，不能保证他的安全，比如我只想保证他的变量page=1,别的线程set就会影响其他线程。<br>所以如果我建立一个全局的变量，大家共享，也不怕被set而影响其他的线程，那么可以用到此动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pageable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Pageable ONLY_ONE = <span class="keyword">new</span> DynamicProxy&lt;&gt;(newOnlyOne(), <span class="keyword">true</span>)</span><br><span class="line">            .getProxyWithWriteMethod((target, proxyMethod, args, originMethod) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 此处抛出异常，也可以return null，但我建议还是把问题暴露出去，避免留坑</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Throwable(<span class="string">&quot;禁止修改全局的类&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pageable <span class="title">newOnlyOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Pageable onlyOne = <span class="keyword">new</span> Pageable();</span><br><span class="line">        onlyOne.setSearchCount(<span class="keyword">false</span>);</span><br><span class="line">        onlyOne.setPage(<span class="number">1</span>);</span><br><span class="line">        onlyOne.setPageSize(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> onlyOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> page = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> pageSize = DEFAULT_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isSearchCount = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个动态代理只是一个工具类，其他需要用到的地方用起来贼方便。基本上3两行代码即可搞定。<br>比如说这篇文章 <a href="/posts/%E9%87%8D%E6%96%B0%E5%8A%A0%E8%A3%85mybatisplus#%E7%84%B6%E5%90%8E%E5%AE%9A%E4%B9%89%E8%BF%99%E4%BA%9B%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">MybatisPlus查询软删除的数据</a>  </p><p>后续源码原理什么的，等我有时间了在分析😁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;动态代理有很多使用的场景，比如  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;springAOP切入&lt;/li&gt;
&lt;li&gt;spring事务、缓存&lt;/li&gt;
&lt;li&gt;自定义业务场景等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文就是一个动态代理util。为了使用起来更加的方便。之后的文章也有可能用得到。 </summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="动态代理" scheme="https://dongmaxiang.vercel.app/categories/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    
    <category term="开发工具类" scheme="https://dongmaxiang.vercel.app/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>环境变量</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2021-07-01T02:46:50.000Z</published>
    <updated>2021-07-01T02:46:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="main方法参数"><a href="#main方法参数" class="headerlink" title="main方法参数"></a>main方法参数</h2><p>使用：java  类名   【参数1】 【参数2】 【参数3】 .。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="system-getenv"></span><h2 id="System-getenv"><a href="#System-getenv" class="headerlink" title="System.getenv"></a>System.getenv</h2><p>获取系统环境变量<br>同 linux 下 <code>export</code></p><span id="system-getproperty"></span><h2 id="System-getProperty"><a href="#System-getProperty" class="headerlink" title="System.getProperty"></a>System.getProperty</h2><p>获取java程序变量<br>通过 java -Dk=v配置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;main方法参数&quot;&gt;&lt;a href=&quot;#main方法参数&quot; class=&quot;headerlink&quot; title=&quot;main方法参数&quot;&gt;&lt;/a&gt;main方法参数&lt;/h2&gt;&lt;p&gt;使用：java  类名   【参数1】 【参数2】 【参数3】 .。。。&lt;/p&gt;
&lt;figu</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="基础" scheme="https://dongmaxiang.vercel.app/categories/java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>dubbo-spi</title>
    <link href="https://dongmaxiang.vercel.app/posts/dubbo-spi/"/>
    <id>https://dongmaxiang.vercel.app/posts/dubbo-spi/</id>
    <published>2021-06-30T19:29:53.000Z</published>
    <updated>2021-06-30T19:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>java有spi机制为什么dubbo还要自创一套？<ul><li>javaSpi没有key value机制，全部都是实现类。没有顺序之分</li><li>javaSpi 如果有多个实现类，只能依次加载，不能精准加载</li><li>...等</li></ul></li></ul><span id="dubbospi的特性"></span><h1 id="dubboSPI的特性"><a href="#dubboSPI的特性" class="headerlink" title="dubboSPI的特性"></a>dubboSPI的特性</h1><ul><li>可根据key获取指定的SPI实现  </li><li>可根据@Activate注解进行分类，获取指定的SPI实现  </li><li>多个实现可排序<br>实现排序接口org.apache.dubbo.common.lang.Prioritized</li><li>可包装(静态代理)<br>对原有的spi实现直接编码进行静态的代理，spi的实现类只留一个有参构造，参数为SPI接口的类型即可变为wrapper</li><li>可注入<br>对spi的实现类中如果有set方法，且没有DisableInject注解，那么以此方法的第一个参数的类型+名称，再次从dubboSPI容器中寻找对应的实例。并set</li><li>spi无实现者的情况下，可自适应实现(一般开发者用不到)<br>方法：<code>getAdaptiveExtension()</code><br>如果spi配置文件中有配置实现类并且类上有Adaptive注解，则直接用此类。<br>如果没有实现类，但是spi接口中个别方法上有Adaptive注解，并且参数有URL的类型（或者可从参数上获取到url），那么在调用的时候会根据adaptive注解的value,作为key从url中获取对应的value。然后在从SPI容器获取对应的实例，进行动态的调用</li><li>...等其他特性</li></ul><h1 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;ABC&gt; LOADER = ExtensionLoader.getExtensionLoader(ABC.class);</span><br><span class="line"><span class="comment">// 用法1：通过@SPI注解获取默认的实现（有可能为空）</span></span><br><span class="line">ABC defaultImpl = LOADER.getDefaultExtension();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法2: spi其他的实现（可根据配置文件中的key精准获取）</span></span><br><span class="line">ABC instance = LOADER.getExtension(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法3：获取自适应实现。（这个一般开发人员用不到）</span></span><br><span class="line">ABC adaptiveExtension = LOADER.getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法4：根据@Activate注解的配置，获取有效的spi实例</span></span><br><span class="line"><span class="comment">// 比如注解@Active(value=&quot;key1:value1, key2:value2&quot;, group=&quot;consumer&quot;)</span></span><br><span class="line">List&lt;T&gt; activeExtension = LOADER.getActivateExtension(URL url, String[] values); <span class="comment">//  从spi从起找对应的名称：values 为spi实现类的key。</span></span><br><span class="line">activeExtension = LOADER.getActivateExtension(URL url, String key, String group); <span class="comment">// 与上面类似。只不过value是以key从url中取。 group 参数：过滤掉和注解@activate中group不一样的</span></span><br><span class="line">activeExtension = LOADER.getActivateExtension(URL url, String[] values, String group); <span class="comment">// 结合上面两个</span></span><br></pre></td></tr></table></figure><span id="activate"></span><h1 id="Activate"><a href="#Activate" class="headerlink" title="Activate"></a>Activate</h1><p>dubbo-spi中有3个方法，用来进行分类获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values)</span></span>;</span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String key, String group)</span></span>;</span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span></span>;</span><br></pre></td></tr></table></figure><p>注解  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activate &#123;</span><br><span class="line">    String[] group() <span class="keyword">default</span> &#123;&#125;;<span class="comment">// 分组</span></span><br><span class="line"></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;<span class="comment">// &quot;key1:value1, key2:value2&quot;,会从url中匹配对应的</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当dubbo-spi在加载实现类时，会判断实现类是否有该注解，如果有的话则会把这些实现类(带有注解的)缓存起来。这样调用getActivateExtension时就会过滤条件并获取到对应的实现</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="/img/posts/2021/07/dubbo-filter.png" alt="配置图"></p><h1 id="wrapper"><a href="#wrapper" class="headerlink" title="wrapper"></a>wrapper</h1><p>对原有对象的包装，类似于静态代理。可以拦截做很多事情。如果spi实现类没有空构造方法并且有一个有参的构造函数，且类型是当前实现的接口。那么在最终暴露的对象为此wrapper。</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>使用图同Activate，不同点是，不需要加注解。并且需要一个有参的构造方法，参数类型是接口。同样配置在配置文件里面。即可完成配置</p><h1 id="简单分析dubbo-spi的初始化"><a href="#简单分析dubbo-spi的初始化" class="headerlink" title="简单分析dubbo-spi的初始化"></a>简单分析dubbo-spi的初始化</h1><p>通过<a href="/posts/java-spi">java-spi</a>来找到dubboSpi配置的目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadingStrategy</span> <span class="keyword">extends</span> <span class="title">Prioritized</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">directory</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是dubbo的默认加载路径，<em>咱们也可以通过<a href="/posts/java-spi">javaSpi</a>，扩展一个新的加载路径</em><img src="/img/posts/2021/07/dubbo-spi.png" alt="原理图"></p><blockquote><p>dubboSpi配置目录下的文件和javaSPI的规范一样，都是以spi全类名作为文件名，不同之处就是内容。<br>dubboSpi配置文件的内容为key=value,key是一个名称，value为实现的class全类名，可以为多行<br>javaSpi配置文件的内容为多行，每行代表一个实现类的全类名名称。<br>dubbo用<code>ExtensionLoader.getExtensionLoader(ABC.class).getExtension(&quot;key&quot;)</code>即可获取到对应的实例</p></blockquote><h2 id="加载并初始化的代码分析"><a href="#加载并初始化的代码分析" class="headerlink" title="加载并初始化的代码分析"></a>加载并初始化的代码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensionLoader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 加载路径，如上图的通过javaSPI寻找默认的实现</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LoadingStrategy[] strategies = stream(ServiceLoader.load(LoadingStrategy.class).spliterator(), <span class="keyword">false</span>)</span><br><span class="line">          .sorted()</span><br><span class="line">          .toArray(LoadingStrategy[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析spi所有的配置文件</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    cacheDefaultExtensionName();<span class="comment">// 根据@SPI注解获取到默认的实现名称，可以为空</span></span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载路径，如上图的默认实现</span></span><br><span class="line">    <span class="keyword">for</span> (LoadingStrategy strategy : strategies) &#123;</span><br><span class="line">      <span class="comment">// 例如：ExtensionLoader.getExtensionLoader(ABC.class)</span></span><br><span class="line">      <span class="comment">// type为当前的SPI接口,即ABC.class</span></span><br><span class="line">      loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">      <span class="comment">// alibaba变为apache，兼容之前老的实现</span></span><br><span class="line">      loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">      <span class="comment">// loadDirectory 通过解析配置文件里面的内容，最终会调用loadClass，</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置文件中的value字符转为class，并分类管理</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name, <span class="keyword">boolean</span> overridden)</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">      cacheAdaptiveClass(clazz, overridden);<span class="comment">// 缓存自适应的实现，如果有多个overridden用来控制是否可覆盖，不能覆盖则直接报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123; <span class="comment">// 如过有一个有参构造，参数类型是spi的接口，那么就是wrapper</span></span><br><span class="line">      cacheWrapperClass(clazz); <span class="comment">// 缓存包装类，可以有多个。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      String[] names = Pattern.compile(<span class="string">&quot;\\s*[,]+\\s*&quot;</span>).split(name);</span><br><span class="line">      cacheActivateClass(clazz, names[<span class="number">0</span>]);<span class="comment">// 进行分类如果有@Activate注解的话</span></span><br><span class="line">      <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">        cacheName(clazz, n); <span class="comment">// 缓存class与对应的名称,不能覆盖。</span></span><br><span class="line">        saveInExtensionClass(extensionClasses, clazz, n, overridden);<span class="comment">// 保存到 extensionClasses 中，如果name已经存在，overridden用来控制是否可覆盖，否则抛异常</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据name获取实例（初始化）</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 实例化，忽略缓存的逻辑，只会初始化，一次</span></span><br><span class="line">    T instance = clazz.newInstance();</span><br><span class="line">    injectExtension(instance); <span class="comment">// 注入操作，对当前实体中如果有set方法，且没有DisableInject注解，那么以此方法的第一个参数的类型+名称，再次从dubboSPI容器中寻找对应的实例。并set</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果wrap为true</span></span><br><span class="line">    <span class="keyword">if</span> (wrap) &#123;</span><br><span class="line"></span><br><span class="line">      List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      wrapperClassesList.addAll(cachedWrapperClasses);</span><br><span class="line">      wrapperClassesList.sort(WrapperComparator.COMPARATOR);</span><br><span class="line">      Collections.reverse(wrapperClassesList);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;</span><br><span class="line">          Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);</span><br><span class="line">          <span class="comment">// 如果有@Wrapper注解，则根据注解判断是否符合要求</span></span><br><span class="line">          <span class="keyword">if</span> (wrapper == <span class="keyword">null</span> || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;</span><br><span class="line">            <span class="comment">// 进行包装</span></span><br><span class="line">            instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    initExtension(instance); <span class="comment">// 如果实现了Lifecycle接口，则调用其生命周期的方法</span></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>dubboSPI比javaSPI多处好几个功能，我们一般都用不到，但是如果想要了解dubbo工作的整体流程。dubboSPI的代码是必须要掌握的。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;java有spi机制为什么dubbo还要自创一套？&lt;ul&gt;
&lt;li&gt;javaSpi没有key value机制，全部都是实现类。没有顺序之分&lt;/li&gt;
&lt;li&gt;javaSpi 如果有多个实现类，只能依次加载，不能精准加载&lt;/li&gt;
&lt;li&gt;...等&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="dubbo" scheme="https://dongmaxiang.vercel.app/categories/java/dubbo/"/>
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/tags/java/"/>
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo-spi" scheme="https://dongmaxiang.vercel.app/tags/dubbo-spi/"/>
    
  </entry>
  
  <entry>
    <title>java-spi</title>
    <link href="https://dongmaxiang.vercel.app/posts/java-spi/"/>
    <id>https://dongmaxiang.vercel.app/posts/java-spi/</id>
    <published>2021-06-29T19:40:17.000Z</published>
    <updated>2021-06-29T19:40:17.000Z</updated>
    
    <content type="html"><![CDATA[<span id="javaspi机制"></span><h2 id="javaSPI机制"><a href="#javaSPI机制" class="headerlink" title="javaSPI机制"></a>javaSPI机制</h2><p>service provider interface</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过遍历即可获取到对应的class,那么原理是什么呢？</span></span><br><span class="line">Iterator&lt;ABC&gt; iterator = ServiceLoader.load(ABC.class).iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    ABC next = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>java规定spi的配置文件都在这个目录<code>META-INF/services/</code><br>该目录下可以有多个文件，文件的名称必须以class全类名命名。通过ServiceLoader类，读取名字为spi类的全名称的文件<br>内容为多行，一行为一个class的全类名。该class为spi的实现类。</p><span id="serviceloader入口"></span><h2 id="ServiceLoader入口"><a href="#ServiceLoader入口" class="headerlink" title="ServiceLoader入口"></a>ServiceLoader入口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">&quot;META-INF/services/&quot;</span>; <span class="comment">// 扫描的目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service; <span class="comment">// spi 要加载的class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;<span class="comment">// classLoader，默认为当前线程的classLoader</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(); <span class="comment">// 已加载过的SPI都会缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator; <span class="comment">// 真正加载的class</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">        lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); <span class="comment">// 缓存</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())<span class="comment">// 先用缓存</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> knownProviders.next().getValue(); <span class="comment">// 先用缓存</span></span><br><span class="line">                <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="lazyiterator-真正的加载类"></span><h2 id="LazyIterator-真正的加载类"><a href="#LazyIterator-真正的加载类" class="headerlink" title="LazyIterator 真正的加载类"></a>LazyIterator 真正的加载类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Class&lt;S&gt; service;</span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;<span class="comment">// 已扫描的url</span></span><br><span class="line">    Iterator&lt;String&gt; pending = <span class="keyword">null</span>; <span class="comment">// 当前扫描的url资源中的spi文本（className为多行）</span></span><br><span class="line">    String nextName = <span class="keyword">null</span>; <span class="comment">//下一个spi实现类的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">        <span class="keyword">this</span>.loader = loader;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 迭代器的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        configs = configs != <span class="keyword">null</span> ? configs : loader.getResources(<span class="string">&quot;META-INF/services/&quot;</span> + service.getName());</span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pending = parse(service, configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接返回</span></span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        String cn = nextName;</span><br><span class="line">        nextName = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该不是spi接口的实现，乱配置的就直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            S p = service.cast(c.newInstance());</span><br><span class="line">            providers.put(cn, p);<span class="comment">// 缓存一下</span></span><br><span class="line">            <span class="keyword">return</span> p;<span class="comment">// 反射创建对象，直接返回</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文以jdk1.8来分析，其他版本略有不同。总的来说就是获取资源<code>META-INF/services/</code>目录下的文件名与spi的class名称一致的文件。读取里面的实现类，然后通过反射按需实例化并缓存。<br>但是缓存有局限性哦，只能针对同一个ServiceLoader对象多次产生的迭代器有效哦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;javaspi机制&quot;&gt;&lt;/span&gt;&lt;h2 id=&quot;javaSPI机制&quot;&gt;&lt;a href=&quot;#javaSPI机制&quot; class=&quot;headerlink&quot; title=&quot;javaSPI机制&quot;&gt;&lt;/a&gt;javaSPI机制&lt;/h2&gt;&lt;p&gt;service provid</summary>
      
    
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/categories/java/"/>
    
    <category term="spi" scheme="https://dongmaxiang.vercel.app/categories/java/spi/"/>
    
    
    <category term="java" scheme="https://dongmaxiang.vercel.app/tags/java/"/>
    
    <category term="源码" scheme="https://dongmaxiang.vercel.app/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>代码高亮</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</id>
    <published>2021-06-28T12:13:00.000Z</published>
    <updated>2021-06-28T12:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>测试代码高亮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetInjectedBean</span><span class="params">(AnnotationAttributes attributes, Object bean, String beanName, Class&lt;?&gt; injectedType,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   InjectionMetadata.InjectedElement injectedElement)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of bean that annotated Dubbo&#x27;s &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125; in local Spring &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String referencedBeanName = buildReferencedBeanName(attributes, injectedType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of bean that is declared by &#123;<span class="doctag">@link</span> Reference <span class="doctag">@Reference</span>&#125; annotation injection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String referenceBeanName = getReferenceBeanName(attributes, injectedType);</span><br><span class="line"></span><br><span class="line">    ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referenceBeanName, attributes, injectedType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> localServiceBean = isLocalServiceBean(referencedBeanName, referenceBean, attributes);</span><br><span class="line"></span><br><span class="line">    prepareReferenceBean(referencedBeanName, referenceBean, localServiceBean);</span><br><span class="line"></span><br><span class="line">    registerReferenceBean(referencedBeanName, referenceBean, attributes, localServiceBean, injectedType);</span><br><span class="line"></span><br><span class="line">    cacheInjectedReferenceBean(referenceBean, injectedElement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referenceBean.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;测试代码高亮&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="生活" scheme="https://dongmaxiang.vercel.app/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="琐碎" scheme="https://dongmaxiang.vercel.app/tags/%E7%90%90%E7%A2%8E/"/>
    
    <category term="博客" scheme="https://dongmaxiang.vercel.app/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>博客</title>
    <link href="https://dongmaxiang.vercel.app/posts/%E5%8D%9A%E5%AE%A2/"/>
    <id>https://dongmaxiang.vercel.app/posts/%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-06-23T01:15:35.000Z</published>
    <updated>2021-06-23T01:15:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>测试部署</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;测试部署&lt;/p&gt;
</summary>
      
    
    
    
    <category term="生活" scheme="https://dongmaxiang.vercel.app/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="琐碎" scheme="https://dongmaxiang.vercel.app/tags/%E7%90%90%E7%A2%8E/"/>
    
    <category term="博客" scheme="https://dongmaxiang.vercel.app/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
