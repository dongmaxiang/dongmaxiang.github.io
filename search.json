[{"title":"学习nodeJs","url":"/posts/学习nodejs/","content":"\n> 参考：[从浏览器到js到nodejs](/posts/从浏览器到js到nodejs)  \n*** \n\n[comment]: <> (nodeJs作为服务端的语言，除了)","tags":["js","脚本语言"],"categories":["脚本语言","js"]},{"title":"你真的知道js的语法吗","url":"/posts/你真的知道js的语法吗/","content":"## 作用域\n\n### 问题\n先看这段代码   \n```javascript\n{\n    a = 1;\n    function a() { };\n    a = 2;\n    console.log(a); // 输出：2\n}\nconsole.log(a); // 输出：1\n```\n是不是很不解？？？常规思路都是输出2啊。  \n没关系，在了解了JS块级作用域之后你就懂了  \n\n### 全局作用域和function\n在[Ecma5](/posts/从浏览器到js到nodejs#js)之前只有函数和全局作用域，也就是全局`window`或者`function(){...}`函数之内，而且var和function，在未声明之前可以访问，原因是js有内部变量提前的特性  \n**在同一作用域下`function`函数和`var`声明的变量都会被提至当前作用域的顶层，var优先声明，function其次，其中function提升的同时，函数体的实现也定义了出来**  \n```javascript\nfunction test() {\n    b();\n    console.log('我是函数');\n    var num = 1;\n\n    function b() {\n        console.log('我是内嵌函数b,num:', num);\n    }\n}\ntest(); // 输出：1.我是内嵌函数b,num:undefined  2.我是函数 \n\n// 解释器解释代码之后会变成如下这个样子\n\nfunction test() {\n    var num = undefined;\n    var b = function () { // function提升的同时，方法实现也定义了出来\n        console.log('我是内嵌函数b,num:', num);\n    }\n    b();\n    console.log('我是函数');\n    num = 1;\n}\ntest();\n```\n\n### 块级作用域\nEcma6新增了块级作用域，增加了两个变量修饰符：`let`(值可变，不可二次声明)和`const`(常量、值不可变，可二次声明)，未声明之前访问会报错，而且`var`和`let`以及`const`声明的变量不能互换  \n理解了函数和变量提升之后，那么问题来了，如果块级作用域和块外作用域共有一个同名的变量，而function函数写在块中，该函数引用到同名变量，那么该函数到底是用块内还是块外变量呢？如下  \n```javascript\nvar a = 1;\n{\n    let a = 2;\n    function test() {\n        console.log(a);\n    }\n}\ntest();\n    \n// 按照上面的函数和变量的提升思路，那么这就是解释器解释后的代码样子\nvar a = undefined;\nvar test = function () {\n    console.log(a);\n}\na = 1;\n{\n    let a = 2;\n}\ntest();\n```\n\n很明显，按照变量和函数提升至顶层之后的思路，解释之后会输出1，可我们实际想要的是2呀。输出为1就违背了块级作用域的概念，那么该如何解决呢？毕竟变量和函数的提升是老的特性，新设计的特性肯定要兼容旧的。没办法，js制定者只能在做一些取舍了  \n取舍如下：  \n1. 函数如果在块中，那么`funtion`和`var`照样提升至前，只不过function的实现不允许提前定义，这样可以避免块中的内容溢出到块外，即块的内容只在块里面  \n2. 解释器在解释到块级作用域时，如果块中有函数，那么会在块中的最初位置用`let`以及新的变量名，重新定义一下这个函数，因为`funtion`被`let`定义在块中了，那么该function肯定可以访问到块中的变量\n   - 为什么会在块中用新的变量从新定义呢，因为一个变量不能从`var`和`let`以及`const`相互转换  \n3. 因为块内的函数的名称变了，所以块内涉及到的老的函数名称时，也要随着变。不然用`let`修饰的新变量名称也没有任何意义啊~  \n4. 然后又因为函数的作用域不仅仅在块内，块外也可以访问（要兼容之前的特性），所以在执行到函数原有声明的位置时，他会用`var`以及原有的变量名再次声明一下  \n这样就解决了块外和块内的变量名一样的问题了。代码如下\n```javascript\nvar a = 1;\n{\n    let a = 2;\n    function test() {\n        console.log(a);\n    }\n}\ntest();\n    \n// 解释器解释后的代码的样子\n\nvar a = undefined; // 变量提升\nvar test = undefined; // 块内的函数提升，舍弃方法体的定义\na = 1;\n{\n    let new_test = function () { // 块内的函数，用let以及新的变量名定义，并在此定义出函数实现体\n        console.log(a);\n    }\n    let a = 2;\n    var test = new_test; // 用var把原有的变量名声明一下，执行完该代码块时，函数也可以在外部访问\n}\ntest();\n```\n> 但是也有问题，比如在块中定义的函数，必须执行完块时，函数才可以访问\n> ```javascript\n> // test();   //执行会报错，找不到方法\n> {\n>   function test() {\n>       console.log(123);\n>   } \n> }\n> test(); //执行完块时才可访问\n> ```\n> 世界上没有任何东西是十全十美的，在一件大事件上要尽量争取最好的度，做出最大的兼容(成本最小，接受面最广)\n\n### 答案\n回到最初的问题，我们以新解释器的角度重新审视一下代码，就能彻底的理解作用域的概念啦\n\n#### 例子1\n```javascript\n{\n    a = 1;\n    function a() { };\n    a = 2;\n    console.log(a); // 输出：2\n}\nconsole.log(a); // 输出：1\n\n// 解释器解释之后的代码\n\nvar a = undefined; // 函数和变量提升至前，不给其函数实现的定义，以免块内污染块外  \n{\n    let new_a = function () { }; // 新变量名称用let进行修饰，并给出原有函数体的定义，使其函数在块内生效，在这个块中，涉及到原有变量名的都用新的变量名'new_a'\n    new_a = 1;\n    var a = new_a; // 执行到原有代码时，需要把函数用原有的名称用'var'重新修饰一下，使其块外能访问到\n    new_a = 2;\n    console.log(new_a); // 输出：2\n}\nconsole.log(a); // 输出：1\n```\n\n#### 例子2\n\n```javascript\na = 1;\n{\n    function a() { };\n    a = 2;\n    console.log(a); // 输出：2\n}\nconsole.log(a); // 输出：function\n\n// 解释器解释之后的代码\n\nvar a = undefined;  // 变量提升\na = 1;\n{\n    let new_a = function () { }; // 块内的方法用'let'以及新的变量名修饰， 在这个块中，涉及到原有变量名的都用新的变量名'new_a'\n    var a = new_a; // 执行到原有代码时，用var把原有的函数重新修饰，使其块外能访问到\n    new_a = 2;\n    console.log(new_a); // 输出：2\n}\nconsole.log(a); // 输出：function\n```\n\n### 闭包\n在块级作用域出现之前，只有函数作用域和全局作用域，为了解决变量的污染，就有了闭包，何为闭包？我理解的就是立即调用一个没有名字的函数，使其变量都在该函数中  \n\n`(function(arg){console.log('我是闭包,arg:', arg)})(123/*把外部变量从这里传进去*/);`这样就把变量锁死在大括号中了，可以理解为对一个匿名方法的调用  \n\n也还有其他的写法如:  \n`!function(arg){console.log('我是闭包,arg:', arg)}(123/*把外部变量从这里传进去*/);`  \n> 为什么前面必须有运算符呢？可以理解为一元运算符对后面匿名变量的运算，如果把感叹号`!`去掉的话，执行器就不知道后面到底是什么语法了  \n\n可以理解为只要是一元运算符后面都可以接匿名变量，`+`或者`-`运算符都可以都可以\n> 为什么大多数都用!感叹号呢，因为运算时占用的cpu和空间比较少，他就是一个取反的运算：非真即假，其次因为编写也方便  \n\n\n## 对象\n谈到对象，最熟悉的莫过于`this`，this为当前对象，咱们都知道对象都是`new`出来的，那么js中的`this`到底该怎么用呢？  \n`window`为全局对象，在任何一个地方，如果一个变量`a = 1`(没有任何修饰，如var、let、const)，那么也可以理解为`window.a = 1`  \n`var`声明的变量的作用域在`funtion`中，否则在上层的function，若上层没有function，那么就会延伸到`window`中  \n\n### 设计对象的结构\nEcma6之前，对象同方法，只需要new即可，至于对象的结构(包含的字段)，在函数中用this，指定即可  \n```javascript\nfunction test(arg1, arg2) {\n   this.arg1 = arg1;\n   this.arg2 = arg2;\n   arg3 = arguments;\n   // 本方法名称\n   this.functionName = arguments.callee.name;\n   // 本方法的调用者，为空为window\n   this.caller = arguments.callee.caller;\n}\n\n\nvar o = new test(1, 2); // 对象创建\nconsole.log(o.arg1); // 输出：1\nconsole.log(window.arg1); // 输出：undefined\n\ntest(3, 4); // 方法调用\nconsole.log(window.arg2); // 输出：4\nconsole.log(window.arg3); // 输出：[3,4]\n\n// 一句话描述this，谁调用的我，这个this就是谁的\n```\n\n> 每个方法都有隐含的参数`arguments`类型为数组，该属性包含了该方法的所有参数，这个特性也就确定了js方法是没有重载的  \n> JS方法中的this是可以改变的\n> - `test.apply(this, arguments)`;\n> - `test.call(this, ...arguments)`;  \n> \n> apply和call都可以改变方法中的this，区别就是apply的参数必须传递数组，call只能把参数拆开，而`...`语法就是用来拆参数的(就是用来脱衣服的)\n\n### 原型链\n\n## 异步","tags":["js","脚本语言"],"categories":["脚本语言","js"]},{"title":"从浏览器到js到nodejs","url":"/posts/从浏览器到js到nodejs/","content":"  \n# 浏览器背景\n浏览器的历程\n![浏览器历史](/img/posts/2022/browserHistory.svg)\n\n---\n\n# js\n\n[js二十年的历程](https://cn.history.js.org/)\n\njavaScript大家最熟悉不过啦，他是通用的浏览器脚本语言，简称js，不过还有一个名词叫EcmaScript，他们之间是什么关系呢？  \n原来EcmaScript是制定规范，javaScript是实现，ecma全称为 europe computer manufactures association即欧洲电脑制造商协会  \n自从浏览器诞生到现在,浏览器脚本语言一直是Js的天下-如上图的js诞生历程,从诞生之日起就确定了他是前端开发的唯一标准，这一切都得归功于**布兰登·艾奇**，js发明时吸收了以下几个语言的特点  \n- 基本语法、数据结构\n  - java、C\n- 函数的用法\n  - scheme\n- 原型链继承\n  - self语言\n\n而且js是单线程模型，在任何时刻js的代码只有一处在执行，这也为后面的异步通信服务端的语言nodeJs奠定了语法的基础\n\n> js = ecma规范 + webApi(dom + bom)   \n> DOM（document object model）：文档对象模型，提供操作页面元素的方法和属性，如新增文字、图片，编辑文字，图片等  \n> BOM（browser object model）；浏览器对象模型，提供一些属性和方法可以操作浏览器，如关闭页面、刷新页面、前进后退等  \n\n[js语法](/posts/你真的知道js的语法吗)\n\n*** \n\n# js包管理---模块化\n\n> 因为js没有模块的功能，更没有一个广泛能应用的标准库，所以诞生了诸多的js模块管理工具  \n> 由于js是前端语言，运行在客户端，不像服务端语言一样，服务端的模块化都在本地计算机缓存、文件系统中，而浏览器客户端都是在网络中，所以前端js的模块化比起后端模块的设计要考虑的更多  \n\ncommonjs、requireJS(AMD)、seaJS(CMD)、webpack、ES6(Module)等，他们之前的关系是什么呢？哪种才是大众主流的呢？  \n\n## commonJs\n\n比较著名的实现者：nodeJs  \n\n> 最早的模块规范定制者，这个规范已经有很多版本和具体实现  \n> commonJs前身叫serverJs，初衷是为了打破js只能在浏览器中运行的局面，构建JavaScript能在桌面环境、服务端运行的生态系统  \n> 这个项目最开始是由 Mozilla 的工程师 Kevin Dangoor 在2009年1月创建的，当时的名字是 ServerJS  \n> 2009年8月，这个项目改名为 CommonJS，以显示其 API 的更广泛实用性  \n\n该规范的主要内容是，模块必须通过`module.exports`导出对外的变量或接口，使用者通过`require('模块名')`来导入其他模块的输出到当前模块作用域中  \n\n规范例子  \n```javascript\n// moduleA.js\nmodule.exports = function( value ){\n  return value * 2;\n}\n\n// moduleB.js\nvar multiplyBy2 = require('./moduleA');\nvar result = multiplyBy2(4);\n```\n\n由于commonJs的规范在服务端大方光彩，但是到了客户端浏览器的表现就很一般了，因为commonJs是同步加载，对于服务端加载的资源都是在缓存或者本地文件中，耗时基本可忽略  \n但是在浏览器端可能会造成阻塞(取决于网络的好坏)白屏时间过长，用户体验不好，所以产生了AMD和CMD  \n\n## AMD-requireJS\n客户端-浏览器专用的包管理  \n异步模块定义Asynchronous Module Definition，使浏览器避免假死长时间白屏的出现  \n比较著名的实现着： requireJS  ，其他如curl 、Dojo 、Nodules等。。。  \n\n使用方式如下\n```javascript\n// 三个参数，第一个为模块名(可选，不指定默认为文件名称)，\n// 第二个参数为当前模块依赖的模块(可选，不指定默认为[\"require\", \"exports\", \"module\"])\n// 第三个参数为当前模块的定义，参数为依赖的模块(如有有依赖其他模块的话)  \n// define(id?, dependencies?, factory);  \ndefine('myModule', ['jquery'], function($) {\n  // $ 是 jquery 模块的输出\n  $('body').text('hello world');\n});\n\n// 使用，等模块加载完时，会进行回调\nrequire(['myModule'], function(myModule) {\n    //...\n});\n```\n\nAMD的规范中，如果要依赖其他模块则必须先等待其他模块加载完，才会进行回调\n\n## CMD-seaJS\n客户端-浏览器专用的包管理\nCMD为通用模块定义Common Module Definition，是国内阿里团队发展出来的，区别于AMD不同之处就是尽可能的懒加载其他模块\n比较著名的实现着： seaJS\n\n使用方式如下  \n```javascript\n// 定义模块  myModule.js\ndefine(function(require, exports, module) {\n  var $ = require('jquery.js'); // 同步\n  $('div').addClass('active');\n  \n  // 也可以写成异步加载\n  require.async('jquery.js', function ($) {\n    $('div').addClass('active');\n  });\n});\n\n// 加载模块\nseajs.use(['myModule.js'], function(my){\n    // ...\n});\n```\n\nCMD兼容AMD的语法所以大体使用上大差不大，只不过CMD推崇的是as lazy as possible\n\n\n## ES6-Module\n在ES6之前，JavaScript中并没有在语言标准中提供模块定义规范，而在非语言层面，开源社区制定了模块定义规范，主要有CommonJS和AMD以及CMD，而这些模块的引入还不能做到静态化的引入，\n什么意思呢？比如需要引入某个模块当中的其中一个方法，那么就得需要加载完该模块后才能引入其中的方法， 而且模块越来越多的情况下，ecma规范也应该统一这种局面了  \n\n在ES6中，定义了import和export两个关键字语法  \n* export   \n  关键字定义导出对象，这个关键字可以无限次使用\n* import  \n  关键字引入导入对象，这个关键字可导入任意数量的模块\n\n模块结构可以做静态分析。这使得在编译时就能确定模块的依赖关系，以及输入和输出的变量\n每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取\nimport 是静态执行，所以无关写在哪个位置，为了可读性，规范写在文件开头  \n\n具体使用如下\n```javascript\n// test.js\nlet myName = \"Tom\";\nlet myfn = function(){\n    return \"My name is\" + myName + \"! I'm '\" + myAge + \"years old.\"\n}\nlet myClass =  class myClass {\n    static a = \"yeah!\";\n}\nexport { myName, myAge, myfn, myClass }\n \n// import use.js\nimport { myName as mmmyName, myfn, myClass } from \"./test.js\";\nconsole.log(myfn());// 输出： My name is Tom! I'm 20 years old.\nconsole.log(mmmyName);// 自定义导入的别名\nconsole.log(myClass.a );// yeah!\n```\n\nexport default 命令\n该命令只能在一个文件(模块)中，使用一次  \n\n```javascript\n// xxx.js\nvar a = \"123\";\nexport default a; // 仅有一个\n \nimport b from \"./xxx.js\"; // 使用任意变量接收\nconsole.log(b); // 输出 123\n```\n\n## webpack\n由于es6语法的横空出世，有些浏览器还没有普及，为了广泛的兼容做适配，webpack又出现了  \n> 德国人Tobias，一个写java不写web页面的程序员，2013年3月10号，发明了当代 web 开发的基石  \n> 灵感来自于Google当时的项目GWT(Google Web Toolkit)把java转换成javascript的项目，GWT里面有个feature叫 code splitting(就是webpack的主要特性)\n> > Code Splitting 是什么以及为什么   \n> > 在以前，为了减少 HTTP 请求，通常地，我们都会把所有的代码都打包成一个单独的 JS 文件。但是，如果这个 JS 文件体积很大的话，那就得不偿失了  \n> > 这时，我们不妨把所有代码分成一块一块，需要某块代码的时候再去加载它；还可以利用浏览器的缓存，下次用到它的话，直接从缓存中读取。很显然，这种做法可以加快我们网页的加载速度，美滋滋！  \n> > 所以说，Code Splitting 其实就是把代码分成很多很多块（ chunk ）咯  \n> \n> 于是，他给当时用nodeJs做前端的项目库modules-webmake(同commonjs的规范)提了一个[issue](https://github.com/medikoo/modules-webmake/issues/7)  \n> 但是由于没有采用，于是他自己fork了一份modules-webmake代码，起名叫webpack，便开始了新框架的研发  \n> 具体诞生细节可看[知乎文章](https://zhuanlan.zhihu.com/p/71640308)  \n\n\nwebpack做的事情很多，不仅仅适配代码，还可以节省资源压缩代码，解析项目中的扩展语言如less,sass，输出浏览器可以识别的语言以及压缩图片文字等。。。    \n总计webpack就是一系列的前端代码构建工具，webpack基于nodeJs  \n\n\n***\n\n# nodejs\n\n作为服务端语言，主要的要求是性能高，延迟低，尤其是io方面的，因为服务端主要面向的是提供服务，避免不了流量的冲击，而面向高性能服务端的开发，需要对内核、\nio、\n多路复用、\nselect、\npull、\nepoll等技术肯定要了如指掌\n\n在2009年，Ryan Dahl(**瑞安·达尔**)用C++工作时，发现这些技术组合搞起来简直麻烦的要死，于是在想办法提高工作效率的驱动下，开发出了nodeJs，但是为什么nodeJs和javaScript语法那么的像呢？  \n\n因为本身就不是一个从0到1的过程，本身就是想解决io高性能方面的问题，如果要设计一门语言，不仅有投入成本、学习成本、就连推广成本也无法估量，所以Ryan Dahl想，有没有是\n单线程的、用的比较广的、学习成本低的语言呢，改造起来又不是特别大，扩展性比较高的语言呢？  \n\nJavaScript是单线程模型，浏览器发起的ajax又是非阻塞的，这就导致了js的io只能是异步，而其他语言有同步io，大家写同步io习惯了改异步io又懒得改，所以**瑞安·达尔**这时候和javaScript就不谋而合了，打算把他改造为一个异步非阻塞的io的服务端语言  \n\n这样会前端js的程序员稍微加以学习NodeJs，就是名副其实的全栈程序员了  \n> NPM（node package manage）实践了CommonJS的包规范---全球最大的模块仓库   \n> 因为nodeJs的npm包管理的出现，开源的、第三方的、框架等都聚集到了一块，规范了代码的生产  \n> 前端框架形形色色、琳琅满目，因为node和js语法大差不差，所以前端开发者都会用到npm包管理，使其前端大规模协作开发成为可能  \n> 你也可以去npm官方注册一个账号并发布自己的代码，供大家使用  \n\n*** \n\nnodeJs主要帮助开发着在无需关系io、内核等方面的技术问题时，能简单的开发出一套高性能io的代码。减少开发者工作量的同时，大大提高服务端的性能  \n\n他的原理主要就是用回调+函数式的编程(事件驱动)构成便捷的异步的io，提供便捷的同时也带来了回调地狱的痛点(debug时很头疼)  \n> nodejs = io.js，io是2014年由于内部分叉，所独立出来的项目，后期内部和解又合并到一起了\n\n[具体可参考nodeJs学习](/posts/学习nodeJs)","tags":["nodejs","js"],"categories":["脚本语言"]},{"title":"hexo博客原理与实战","url":"/posts/hexo博客原理与实战/","content":"\n## 原理\nhexo 是基于[nodejs](/posts/从浏览器到js到nodejs#nodejs)\n\n通过执行`node hexo s`就会生成可访问的静态文件，那么他的原理是什么呢？\n> 本博客是基于hexo框架，主题[butterfly](https://github.com/jerryc127/hexo-theme-butterfly)构建完成的\n","tags":["博客"],"categories":["博客"]},{"title":"java安全点safePoint以及JIT","url":"/posts/java安全点safepoint以及jit/","content":"\n# 什么是JIT\nJust In Time(即时编译)  \n一般程序遵循90-10原则，即运行时的90%时间里计算机是在处理其中10%的代码,java也是，jvm频繁的解释字节码也挺累的，因为还要翻译成机器码\n，所以JIT的宗旨就是在运行过程当中找出热点代码并编译成二进制的机器语言(深度优化)，这样就能很好的提高java的执行效率  \n> 假如Java的某个方法有1M次调用，通过jit优化此方法之后前后差100个指令，那么1M次调用，你就节省了0.1G个指令(1GHZ=10^3MHZ=10^6KHZ=10^9HZ)  \n> 假设cpu处理频率为2.5GHz,优化后变为2.6GHz，相当于提升了4%的性能。如果优化的更多或者调用次数更多则性能提升的空间越大\n\n## 一般都会优化哪些内容？  \n1. 死代码删除  \n  如下代码，变量i是无任何意义的\n  ```java\npublic static void main(String[] args) {\n    int i = 1;\n    System.out.println(\"hello world\");\n}\n```\n\n2. 方法内联  \n   jit中非常重要的一环\n   将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段  \n   大白话就是a调用b，为了减少入栈、出栈，直接把b的代码编译在a中\n\n3. 逃逸分析  \n   在栈中new的对象是否出栈之后就再无引用，那么就可以在栈上分配，出栈即刻销毁  \n   锁消除--编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除，比上面栈上分配的技术难度更大一些(基于逃逸分析的锁消除实际上并不多见)\n\n4. 循环展开  \n   循环展开通过减少或消除控制程序循环的指令，争取在一次循环就把所有任务做完  \n   ```java\n    for (int i = 0; i < 5; i++) {\n        System.out.println(i);\n    }\n   // 优化后\n    for (;;) {\n        System.out.println(1);\n        System.out.println(2);\n        System.out.println(3);\n        System.out.println(4);\n        System.out.println(5);\n        break;\n    }\n   ```\n\n5. 窥孔优化与寄存器分配  \n   `y1=x1*3`  经过优化后得到  `y1=(x1<<1)+x1`  \n   寄存器分配指的是把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度\n\n\n## 优化引擎\nhotspot jvm 内置了两个jit编译器，分别是client compiler（C1编译器）和server compiler（C2编译器）  \n\n* c1=-client  \n  方法内联、死代码删除\n  \n* c2=-server  \n  几乎会执行所有经典的优化工作，如：无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序、Java语言紧密相关的优化技术(范围检查消除、空值检查消除)、分支频率预测等  \n\nGraal VM比c2编译优化的还更高级，具体可以参考其他资料 \n\n---\n\n# safePoint\nGC的时候会暂停JVM所有的线程，此时jvm状态为STW(stop the world)。那么和安全点有什么关系呢？  \n安全点的主要作用就是代表当前的线程可以安全的暂停，恢复之后还可以正常执行  \n如果没有在安全点暂停的话，GC回收垃圾时，对象的实际地址会有变动，如果不在安全点暂停，那么持有的对象的地址可能因此而错乱，所以必须要在安全点暂停  \n安全点是由各个线程主动中断的(自己说了算)，主动中断是设置一个中断标志，各个线程运行到SafePoint的时候主动轮询这个标志，一旦发现中断标志为 True，就会在自己最近的“安全点”上主动中断挂起  \n\n---\n## 安全点都有哪些呢？\n\n不同JVM安全点的位置也不同，安全点放置过多也会性能，JIT编译的代码里会在所有方法的\n1. 临返回之前  \n2. 所有非counted loop的循环的回跳之前放置安全点  \n  > counted loop意思是for循环数字且有明确的数量(边界)，使用启动参数-XX:+UseCountedLoopSafepoints，可以在CountedLoop回跳之前放置安全点  \n\n安全点位置的选取基本上是以“超长时间执行的特征”为标准进行选定的\n“长时间执行”的最明显特征就是指令序列的复用(包含一系列的指令)，例如  \n3. 方法调用  \n4. 循环跳转  \n5. 异常跳转  \n\n所有能够修改JVM执行状态的JNI函数在入口处都有安全点检查，如果中断标志为 True，则会进入安全点并阻塞等待  \n其余正在执行的JNI函数可以在安全点上运行，因为它们只使用句柄，但在返回之前会主动检查安全点状态，如果中断标志为 True，则会进入安全点并阻塞等待    \n> 在SafePoint上不代表被阻塞（比如：JNI方法就可以在SafePoint上运行），但是被阻塞一定发生在SafePoint上\n\n---\n## 什么时候会用到安全点？\n1. GC时需要全局安全点，需要注意，如果有一个线程没有进入到安全点时(安全区的线程除外)，GC无法展开工作，导致停顿时间延长  \n   > 能够确保在某一段代码片段之中，引用关系不会发生变化称之为安全区  \n   > 在执行到安全区域里面的代码时，首先会标识自己在安全区(比如Sleep或Blocked的线程)，GC时会忽略此线程，离开安全区之前必须要接收到JVM可以离开的信号，比如GC未完成则不允许离开安全区  \n2. jit逆优化([重新修改方法体redefineClass](/posts/java-agent#agent实现热更新))  \n3. [偏向锁升级为轻量级锁时](/posts/java内存模型和GC以及锁#轻量级锁)","tags":["jvm"],"categories":["java","jvm"]},{"title":"java内存模型和GC以及锁","url":"/posts/java内存模型和gc以及锁/","content":"\n让我们带着问题一探究竟  \n一个Object对象占用几个字节，里面内容都是什么(对象占用大小)？在哪里分布呢(内存模型)？什么时候会销毁(GC)？  \n> klass是java中，类的元信息在jvm中的表现形式，就是在c++中，类的元信息是通过klass来表示的\n\n# 对象占用大小\n\n`new Object();`会占用多少内存呢？答案是16字节=128比特位=128bits  \n\n## 为什么是16字节呢？而不是17或者15？  \n  这是因为8个字节=1byte,所以只能是8的倍数，那么是8，要么是16、24、32  \n  那为什么是16，而不是24、32？因为这得取决于里面的内容是什么  \n\n## 里面内容是什么呢？  \n\n对象头和数据体两大部分  \n### 1. 对象头\n1. 前面8个字节为markword，记录对象被上锁的各种状态或者垃圾回收和hashcode相关的信息  \n  默认无锁的情况如下，有锁的情况参考[java锁](#synchronized)  \n   \n  * 64位系统中(64bit)  \n    未使用：25位  \n    hashcode:  31位存储对象的System.identityHashCode()，采用延迟加载技术  \n    未使用：1位  \n    gc分带年龄: 4位  \n    偏向锁的标记：1位  \n    当前对象的锁的状态：2位  \n    25+31+1+4+1+2=64  \n    \n  * 32位系统中(也是有64bit,只不过java只用32bit)  \n    hashcode:  25位存储对象的System.identityHashCode()，采用延迟加载技术  \n    gc分带年龄: 4位  \n    偏向锁的标记：1位  \n    当前对象的锁的状态：2位  \n    25+4+1+2 = 32  \n\n\n2. 接下来4个字节(也有可能是8个字节)是Klass Point(类型指针)  \n 为什么有可能是4有可能是8呢，取决于是否开启了[classPointer指针压缩](/posts/JVM所有的参数配置详解#4--xxusecompressedclasspointers)  \n 虚拟机通过这个指针来确定这个对象是哪个类的实例 \n 一个对象里面的数据都是紧挨着的，因为是紧挨着，无法区分数据断点在哪里，所以必须有class对象的指针，通过对象起始地址和字段的偏移地址(从class获取)读取字段的数据  \n\n3. 如果是数组类型的话对象头还得再加4个或8个字节([取决于是否开启压缩指针](/posts/JVM所有的参数配置详解#3--xxusecompressedoops))表示数组的长度  \n   只有当本对象是一个数组对象时才会有这个部分\n\n### 2. 对象数据体\n对象的里面的数据  \n如果是基本类型则是对应的值占用的空间，如果是引用类型那么大小有可能是8bit或者4bit[取决于是否开启压缩指针](/posts/JVM所有的参数配置详解#3--xxusecompressedoops)  \n   \n### 3. 对齐填充数据(可选)  \n[根据对象对齐空间进行对齐，默认为8bit](/posts/JVM所有的参数配置详解#5--xxobjectalignmentinbytes8)  \n因为必须是8的倍数，不是8的倍数剩下的将要补齐  \n   \n\n所以一个`new Object()`为16字节，8字节为对象头，后面8字节为class对象的指针和数据填充  \n1G内存大约可以存1024 * 1024 * 1024 / 16 = 67108864(约等于6千7百万多个对象)  \n\n---\n\n# java锁\n* java都有哪些锁呢？  \n   1. 是否阻塞  \n      悲观(阻塞其他线程-synchronized)、乐观(不阻塞其他线程-ReentrantLock和ReentrantReadWriteLock)\n      \n   2. 是否公平  \n      非公平(synchronized)、公平(ReentrantLock和ReentrantReadWriteLock)\n\n   3. 二次是否能获取  \n     不可重入锁(jdk没有自带的)、可重入锁(jdk自带的锁都可以重入)  \n      \n   4. 是否共享  \n      共享锁(ReentrantReadWriteLock)、排他锁\n\n* 大体分为synchronized、ReentrantLock和ReentrantReadWriteLock3个阵营  \n\n## synchronized\n* 特性：阻塞、非公平、可重入、排他锁  \n* 原理  \n  jdk1.6引入了偏向锁和轻量级锁，1.6之前都是重量级锁，意思就是互斥等待都需要内核态完成（操作系统），开销非常的大，所以优化之后的synchronized可以进行锁升级  \n  每一个Java对象就有一把看不见的锁，存放在对象头中叫markword，占用8个字节(动态的内容)  \n  当创建一个对象时，会通过Klass的prototype_header来初始化该对象的markword，prototype_header包含了lock(锁标识-适用于所有的实例)、epoch(偏向时间戳-用来控制锁是否失效的版本号)  \n  [无锁的情况下里面存放默认的数据](#1-对象头)  \n  偏向锁、轻量级锁、重量级锁都是根据markword里面的数据来标识当前锁的状态(所以markword里面的内容都是动态的)，一个对象锁升级之后不可回退  \n  在32位jvm中占用空间如下所示(4\\*8=32bit)  \n  ![如图](/img/posts/2021/markword.png)  \n  在64位中占用(8\\*8=64bit)如下所示  \n  ```  \n  |------------------------------------------------------------------------------|--------------------|  \n  |                                  Mark Word (64 bits)                         |       State        |  \n  |------------------------------------------------------------------------------|--------------------|  \n  | unused:25 |  identity_hashcode:31  |unused:1|  age:4  |biased_lock:1| lock:2 |       Normal       |  \n  |------------------------------------------------------------------------------|--------------------|  \n  |       threadId:54      |  epoch:2  |unused:1|  age:4  |biased_lock:1| lock:2 |       Biased       |  \n  |------------------------------------------------------------------------------|--------------------|  \n  |                       ptr_to_lock_record:62                         | lock:2 | Lightweight Locked |  \n  |------------------------------------------------------------------------------|--------------------|  \n  |                     ptr_to_heavyweight_monitor:62                   | lock:2 | Heavyweight Locked |  \n  |------------------------------------------------------------------------------|--------------------|  \n  |                                                                     | lock:2 |    Marked for GC   |  \n  |------------------------------------------------------------------------------|--------------------|  \n  ```  \n  无锁、偏向锁、轻量级锁、重量级锁、gc标记，这5种状态都是通过锁标志位(lock)来判断的，但是2bit只能表示4种状态，如上图  \n  所以无锁和偏向锁的锁标志位都为01，然后在通过额外的1bit(biased_lock)用来区分当前对象是否为偏向锁  \n  只有匿名偏向时(lock=01,biased_lock=1,threadId=null)才可以使用偏向锁,否则从轻量级锁开始  \n  \n  ### 无锁 \n    锁标志位为lock=01，偏向锁标识为biased_lock=0  \n    对于无锁状态的锁对象，如果有竞争，会直接进入到轻量级锁，所以如果没有关闭偏向锁那么JVM在启动4秒之后([-XX:BiasedLockingStartupDelay=4000](/posts/JVM所有的参数配置详解#-xxbiasedlockingstartupdelay4000))，会将所有加载的Klass的prototype_header修改为匿名偏向锁  \n    > 为什么要延迟之后修改呢？  \n    > JVM启动时必不可免会有大量sync的操作，而偏向锁竞争时会STW并升级为轻量级锁，锁升级不可回退。如果开启了偏向锁，会发生大量锁撤销和锁升级操作，大大降低JVM启动效率  \n    \n  ### 偏向锁  \n    因为偏向锁会占用hashcode空间，如果该对象已被产生hashcode则不能使用偏向锁，如果在偏向时产生hashcode,那么会升级为轻量级锁   \n    > JVM默认的计算identity hash code的方式得到的是一个随机数，[如果不想为随机数可参考](/posts/JVM所有的参数配置详解#设置默认的hashcode), 因而我们必须要保证一个对象的identity hash code只能被底层JVM计算一次  \n    > Identity hash code是未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值  \n    \n    只有匿名偏向时才可以使用偏向锁  \n    匿名偏向：锁标志位为lock=01，偏向锁标识为biased_lock=1, 且threadId为空(未偏向任何线程)，代表当前为匿名偏向    \n    markword里面有54(64位jvm)或者23(32位jvm)bit表示偏向锁偏向的线程id，未偏向时此值为空，上锁时依赖一次CAS原子指令，设置对应的线程的id，默认情况下已上锁的threadId不会自动释放(减少CAS指令的调用)，如果上锁失败或已偏向其他线程，则会进行重偏或竞争升级为轻量级锁  \n    epoch的作用是记录偏向锁的版本号，用来判断偏向锁是否失效(实例的epoch != klass的epoch)，epoch默认是有效的，如果失效可以重偏，什么时候会失效呢？参考[-XX:BiasedLockingBulkRebiasThreshold=20](/posts/JVM所有的参数配置详解#-xxbiasedlockingbulkrebiasthreshold20)  \n    > 偏向锁上锁大致过程为：  \n    > 在匿名偏向状态才可以上锁，CAS设置threadId成功代表上锁成功，失败则会进行锁升级为轻量级锁  \n    > 如果epoch失效，则会重偏(非重偏的逻辑只要有竞争就会升级为轻量级锁)，CAS设置threadId和epoch最新值，失败则会进行锁升级  \n    > 每次上锁或者重入时只需要检查epoch和threadId是否有效即可，并且会在当前的栈侦添加一条锁记录LockRecord(记录被锁对象的地址和被锁对象的markword)，用来计算重入的次数(偏向锁LockRecord的MarkWord为空,称之为Displaced MarkWord)，执行完同步代码块之后会销毁LockRecord   \n    > > 偏向锁锁升级为轻量级锁的大致流程为:  \n    > > 其他线程请求锁,以被锁对象和新线程作为参数构造一个VM_Operation vo，新线程被挂起，在[全局安全点(STW)时](/posts/java安全点safePoint以及JIT#什么时候会用到安全点)，VM_Thread去执行vo  \n    > > vo内部逻辑是去检查持有偏向锁的线程状态，如果对应线程已经销毁则或者对应线程执行的代码在同步块之外(通过遍历持有锁的线程的栈，判断是否有指向被锁对象的lockRecord)，则设置对象为无锁状态(无锁上锁会升级为轻量级锁)\n    > ，如果还在同步块之内则把当前偏向锁升级为轻量级锁，然后让新线程以轻量级锁的状态去竞争  \n    > 至此偏向锁流程解析完毕\n    \n  ### 轻量级锁  \n    锁标志位为lock=00  \n    偏向锁失效(超过-XX:BiasedLockingBulkRevokeThreshold=40默认的次数)或偏向锁竞争时，就会使用轻量级锁\n    \n\n---\n\n## ReentrantLock\n特性：非阻塞和阻塞、非公平和公平、可重入、排他锁\n\n## ReentrantReadWriteLock\n特性：非阻塞和阻塞、非公平和公平、可重入、共享锁","tags":["jvm"],"categories":["java","jvm"]},{"title":"jvmClassLoader过程及原理","url":"/posts/jvmclassloader过程及原理/","content":"\n# classLoader加载class过程\n都是通过classLoader加载的class，如果已经加载过则不可以再次加载，但是可以通过不同的classLoader加载同一个class\n\n##  都有哪些类加载器呢\n\n1. 引导类加载器=BootstrapClassloader  \n   是使用C++语言实现的，负责加载JVM虚拟机运行时所需的基本系统级别的类，如java.lang.String, java.lang.Object等等  \n   由于是C++实现的所以通过Object.class.getClassLoader() == null,无法访问\n   \n2. 扩展类加载器=ExtClassLoader  \n   是由Bootstrap加载的此类  \n   此类加载器默认加载JAVA_HOME/jre/lib/ext/目录下的所有jar包，当然也可以加载由java.ext.dirs系统属性指定的jar包,用来加载java的扩展库，用户也可以直接使用此类加载器\n   \n3. 应用类加载器=AppClassLoader  \n   是由AppClassLoader加载的此类  \n   此类加载器默认加载用户编写的class\n   \n\n## 双亲委派\n意思是多个亲戚，将加载class的任务委任给多个亲戚。以上三个类加载是都是有对应的加载关系的。如果加载某个class时，他会把任务交给上层处理，上层处理不了在交给上层处理，直到上层加载不了，然后在自己加载。  \n为什么这样设计呢？比如说String.class，在运行时就已经加载了，我们能重新覆盖吗？并不能，双亲委派机制就是要保证class正常只加载一次    \n<font color='red'>上层加载的class不能引用下层加载的class</font>\n\n## URLClassLoader  \n扩展类加载器ExtClassLoader和应用类加载器AppClassLoader，都继承`URLClassLoader`，在加载class时根据所在的路径读取class内容加载的。  \n如果我们从新写一个String.class，包名和jdk的String一模一样，是加载不了的。因为上层的classLoader已经加载过了。  \n如果自己写一个没有加载过的class，同时依赖的第三方包中也有这个class，那么可以加载自己写的吗，答案是：和启动时的classPath参数有关\n\n\nAppClassLoader初始化的代码  \n```java\nstatic class AppClassLoader extends URLClassLoader {\n   ... \n   public static ClassLoader getAppClassLoader(final ClassLoader var0) throws IOException {\n       // 获取classPath\n      final String var1 = System.getProperty(\"java.class.path\");\n      final File[] var2 = var1 == null ? new File[0] : Launcher.getClassPath(var1);\n      return (ClassLoader) AccessController.doPrivileged(new PrivilegedAction<Launcher.AppClassLoader>() {\n         public Launcher.AppClassLoader run() {\n            URL[] var1x = var1 == null ? new URL[0] : Launcher.pathToURLs(var2);\n            // 转换成URL数组，注意当加载class的时候会从此URL寻找，是通过遍历的方式，如果classPath参数中的class靠前，那么就能加载咱们自己写的。\n            return new Launcher.AppClassLoader(var1x, var0);\n         }\n      });\n   }\n   ...\n}\n```\n\n---\n\n# class加载过程\n\n## 1 加载class\n读取class的二进制字节流,默认通过`URLClassLoader#findClass`读取内容  \n\n## 2 连接class  \n此步骤由C++实现\n\n### 2.1 验证  \n   验证JVM是否支持对应的字节码语法  \n   \n### 2.2 准备  \n\n静态变量分配内存空间，并将其赋予默认值（0，false，null等）  \n如：`static int num = 50;`则此步骤为变量num分配空间，并赋值为0  \n如：`static Object obj = 1;`则此步骤为变量obj分配空间，并赋值为null  \n分配内存空间，到底要分配多少呢？详情请看[java内存模型和GC](/posts/java内存模型和GC以及锁)  \n如下代码，你猜会输出几？答案是0(默认值)，为什么呢？  \n\n```java\nstatic class Test {\n   static final Test t = new Test();\n   static int eight = 8;\n   private int num = eight;\n   \n   public static void main(String[] args) {\n      System.out.println(Test.t.num);\n   }\n}\n```\n\n为什么输出是0，而不是8？看完初始化你就明白了\n\n            \n### 2.3 解析  \n将类中的符号引用转换为直接引用  \n编译的class字节码都是符号引用，符号的意思就是占位符，因为在实际运行当中要知道明确的地址才能调用  \n所以在这个解析的阶段，如果有引用其他的class就会加载其他的class到内存中，然后才能得到对应的内存地址    \n知道内存地址意味着可以直接调用（也就是直接引用）  \n\n\n## 3 初始化class  \n```java\nimport lombok.SneakyThrows;\n\npublic class Test {\n\n    static class A {\n        static {\n            System.out.println(\"class A initialize \");\n        }\n        A() {\n            System.out.println(\"A constructor\");\n        }\n        static B b = new B();\n        static {\n            System.out.println(\"A static after new B(), f_o_12:\" + B.f_o_12);\n            System.out.println(\"A static after new B(), b.num:\" + b.num);\n        }\n    }\n    static class B extends A {\n        static {\n            System.out.println(\"class B initialize \");\n        }\n        public static final int psf_1 = 1;\n        static final int f_2 = 2;\n        // ---------------------------\n        public static final Object f_o_12 = 12;\n        // ---------------------------\n        static B b = new B();\n        static int num_constant = 999999999;\n        public int num = num_constant;\n        static {\n            System.out.println(\"B  static after new B(), f_o_12:\" + B.f_o_12);\n        }\n        B() {\n            System.out.println(\"B constructor\");\n        }\n    }\n\n    @SneakyThrows\n    public static void main(String[] args) {\n        System.out.println(B.psf_1);\n        System.out.println(B.f_2);\n        System.out.println(B.f_o_12);\n    }\n}\n```\n\n运行main方法，如果不看答案的话你能准确的说出他的输出内容及顺序吗？  \n即使你看过网上一大堆的初始化文章之后，98%的人都答不对,先透露一下总共输出12个，最后几个输出的是  \n第11个输出: B  static after new B(), f_o_12:12  \n第12输出: 12\n\n\n<select>\n<option>点我查看答案</option>\n<option>1. 1 </option>\n<option>2. 2 </option>\n<option>3. class A initialize </option>\n<option>4. A constructor </option>\n<option>5. B constructor </option>\n<option>6. A static after new B(), f_o_12:null </option>\n<option>7. A static after new B(), b.num:0 </option>\n<option>8. class B initialize </option>\n<option>9. A constructor </option>\n<option>10. B constructor </option>\n<option>11. B  static after new B(), f_o_12:12 </option>\n<option>12. 12 </option>\n</select>\n\n\n### 总结初始化顺序\n\n1. 优先级最高的：如果是<font color='red'>static final 修饰的Java 基本类型</font>则不会初始化class，可以直接访问，称之为常量  \n   \n2. 如果是访问static的变量或者是new对象，优先初始化顶级父类的 static 修饰的静态字段或静态块，按照声明的顺序初始化，然后是子类，依次到当前的class  \n  如果static声明的字段或者方法块引用到其他的class，则会初始化其对应的class，如果已经或正在初始化，可以直接使用  \n  注意：[<font color='red'>如果正在初始化，则class的内容只做了准备的阶段，所以class里面的属性都是null或者都是默认值</font>](#22-准备)  \n   \n3. 如果是创建对象的实例，则上面的静态块初始化完毕之后，在初始化代码块（从顶级的父类开始，按照声明的顺序，然后是子类，依次到当前的class），最后是构造方法初始化\n\n","tags":["jvm"],"categories":["java","jvm"]},{"title":"定义swagger通用接口文档","url":"/posts/定义swagger通用接口文档/","content":"\n我们用的swagger版本为\n```xml\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger2</artifactId>\n    <version>2.9.2</version>\n</dependency>\n\n<dependency>\n    <groupId>com.github.xiaoymin</groupId>\n    <artifactId>swagger-bootstrap-ui</artifactId>\n    <version>1.9.6</version>\n</dependency>\n\n<dependency>\n    <groupId>com.spring4all</groupId>\n    <artifactId>swagger-spring-boot-starter</artifactId>\n    <version>1.9.1.RELEASE</version>\n    <exclusions>\n        <exclusion>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger-ui</artifactId>\n        </exclusion>\n        <exclusion>\n            <groupId>io.swagger</groupId>\n            <artifactId>swagger-models</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n```\n\n1. 由于swagger的分组在配置文件中不支持中文，所以我们给他改成中文  \n   yml配置swagger文档的分组不支持中文作为key，所以我给该他改成中文，这样对前端提示友好些 \n1. 由于我们[统一了http最外层的响应包装](/posts/mvc对外提供统一响应包装)，swagger是检测不出来的，所以我们要给他加上最外层的响应包装  \n   Result为http外层的响应包装\n1. 由于我们[统一了枚举](/posts/mvc枚举序列化和反序列化的配置)，swagger也是检测不出来的，所以我们要给他加上枚举的注释以及对应的value\n\n代码如下  \n\n`@ConditionalOnExpression(\"#{!T(com.wuyi.mkt.common.emnus.ENV).isProd()}\")`[非正式环境下才生效](/posts/获取spring启动环境的工具类)\n\n\n```java\n@Slf4j\n@Component\n@EnableSwagger2Doc\n@ConditionalOnWebApplication\n@MyConditionalOnWebApplication\n@EnableSwaggerBootstrapUI\n@ConditionalOnExpression(\"#{!T(com.wuyi.mkt.common.emnus.ENV).isProd()}\")// 非正式环境下才生效\npublic class SwaggerConfiguration implements ApplicationListener<ApplicationReadyEvent>, BeanPostProcessor, ExpandedParameterBuilderPlugin, ParameterBuilderPlugin, ModelPropertyBuilderPlugin, OperationBuilderPlugin, OperationModelsProviderPlugin {\n\n    @Autowired\n    private ServerProperties serverProperties;\n    @Autowired\n    private TypeNameExtractor typeNameExtractor;\n    @Autowired\n    private TypeResolver resolver;\n\n    @Override\n    public void onApplicationEvent(ApplicationReadyEvent event) {\n        String ipAddress = IpUtils.getLocalHostInfo().getIpAddress();\n        Integer port = serverProperties.getPort();\n        String contextPath = serverProperties.getServlet().getContextPath();\n        log.info(\"接口文档地址:{}\", String.format(\"http://%s:%s%s/doc.html\", ipAddress, port, ObjectUtils.defaultIfNull(contextPath, \"\")));\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        // docket分组名使用中文的title\n        if (bean instanceof SwaggerProperties) {\n            Map<String, SwaggerProperties.DocketInfo> newDocket = Maps.newHashMap();\n            ((SwaggerProperties) bean).getDocket().forEach((k, v) -> newDocket.put(v.getTitle(), v));\n            ((SwaggerProperties) bean).setDocket(newDocket);\n        }\n        return bean;\n    }\n\n    @Override\n    public boolean supports(DocumentationType delimiter) {\n        return true;\n    }\n\n    /**\n     * 非Model的参数\n     * 实体里面的字段如果是枚举则增加文档\n     * 比如枚举作为实体中的成员，而实体则直接写在方法上作为参数\n     */\n    @Override\n    public void apply(ParameterExpansionContext context) {\n        try {\n            ParameterBuilder parameterBuilder = context.getParameterBuilder();\n            parameterBuilder.required(false);\n            Class<?> erasedType = context.getFieldType().getErasedType();\n            addDocForEnum(parameterBuilder, erasedType, false);\n\n            if (erasedType.isArray()) {\n                addDocForEnum(parameterBuilder, erasedType.getComponentType(), true);\n            } else if (List.class.isAssignableFrom(erasedType)) {\n                TypeBindings typeBindings = context.getFieldType().getTypeBindings();\n                erasedType = typeBindings.getTypeParameters().get(0).getErasedType();\n                addDocForEnum(parameterBuilder, erasedType, true);\n            }\n        } catch (Exception e) {\n            log.info(\"ParameterExpansionContext apply\", e);\n        }\n    }\n\n    /**\n     * 非Model的参数如果是枚举则增加文档\n     * 比如枚举作为参数直接写在方法上\n     */\n    @Override\n    public void apply(ParameterContext context) {\n        try {\n            ParameterBuilder parameterBuilder = context.parameterBuilder();\n            parameterBuilder.required(false);\n            Class<?> erasedType = context.resolvedMethodParameter().getParameterType().getErasedType();\n            addDocForEnum(parameterBuilder, erasedType, false);\n\n            if (erasedType.isArray()) {\n                addDocForEnum(parameterBuilder, erasedType.getComponentType(), true);\n            } else if (List.class.isAssignableFrom(erasedType)) {\n                TypeBindings typeBindings = context.resolvedMethodParameter().getParameterType().getTypeBindings();\n                erasedType = typeBindings.getTypeParameters().get(0).getErasedType();\n                addDocForEnum(parameterBuilder, erasedType, true);\n            }\n        } catch (Exception e) {\n            log.info(\"ParameterContext apply\", e);\n        }\n    }\n\n    /**\n     * 给一个model内的EnumProperty增加文档\n     */\n    @Override\n    public void apply(ModelPropertyContext context) {\n        try {\n            ModelPropertyBuilder builder = context.getBuilder();\n            builder.required(false);\n\n            Class<?> fieldType = context.getBeanPropertyDefinition()\n                    .transform(BeanPropertyDefinition::getRawPrimaryType)\n                    .orNull();\n\n            if (fieldType == null || !fieldType.isEnum()) {\n                return;\n            }\n\n            // 为了复用代码先这样搞，毕竟就是个文档\n            addDocForEnum(new ParameterBuilder() {\n\n                private final String description = (String) FieldUtils.readDeclaredField(builder, \"description\", true);\n                private final String name = (String) FieldUtils.readDeclaredField(builder, \"name\", true);\n\n                public ParameterBuilder description(String description) {\n                    builder.description(description);\n                    return this;\n                }\n\n                public ParameterBuilder allowableValues(AllowableValues allowableValues) {\n                    builder.allowableValues(allowableValues);\n                    return this;\n                }\n            }, fieldType, false);\n\n        } catch (Exception e) {\n            log.info(\"ModelPropertyContext apply\", e);\n        }\n    }\n\n\n    /**\n     * 给当前的param增加文档，如果是枚举的话\n     *\n     * @see DeserializableEnum\n     */\n    private void addDocForEnum(ParameterBuilder parameterBuilder, Class<?> erasedType, boolean coverageModel) throws IllegalAccessException {\n        DeserializableEnum deserializableEnum = DeserializableEnum.getDeserializableEnumAndIdentityClass(erasedType)\n                .map(Map.Entry::getKey)\n                .orElse(null);\n        if (deserializableEnum == null) {\n            return;\n        }\n        // 枚举\n        Object[] enumConstants = erasedType.getEnumConstants();\n\n        // 获取所有枚举的可用值\n        List<String> values = Arrays.stream(enumConstants)\n                .map(Enum.class::cast)\n                .map(deserializableEnum::getIdentity)\n                .flatMap(identity -> {\n                    if (identity instanceof Object[]) {\n                        return Stream.of((Object[]) identity);\n                    }\n                    return Stream.of(identity);\n                }).map(String::valueOf)\n                .collect(Collectors.toList());\n\n        /*\n         * 默认值：\n         * 让前端在调试的时候可以不选，或者选择一个错误的值\n         */\n        values.add(0, \"\");\n        values.add(\"这是个错误的值\");\n\n        /*\n         * 可用值描述：\n         * 枚举的doc和identity，拼成字符串\n         */\n        String description = Arrays.stream(enumConstants)\n                .map(Enum.class::cast)\n                .map(t -> {\n                    Object identity = deserializableEnum.getIdentity(t);\n                    if (!(identity instanceof Object[])) {\n                        identity = ObjectUtils.array(identity);\n                    }\n                    return Arrays.toString((Object[]) identity) + \"=\" + deserializableEnum.getDocFunction.apply(t);\n                }).collect(Collectors.joining(\";\"));\n\n        /*\n         * 如果没有description，则取ApiModel的注解\n         * 当做前缀，拼接可用值描述\n         */\n        String oldDescription = (String) FieldUtils.readDeclaredField(parameterBuilder, \"description\", true);\n        String name = (String) FieldUtils.readDeclaredField(parameterBuilder, \"name\", true);\n        if (StringUtils.isNotBlank(oldDescription) && !oldDescription.equals(name)) {\n            oldDescription += \":\";\n        } else {\n            oldDescription = Optional.ofNullable(AnnotationUtils.findAnnotation(erasedType, ApiModel.class))\n                    .map(ApiModel::value)\n                    .map(t -> t + \":\")\n                    .orElse(\"\");\n        }\n\n        parameterBuilder.description(oldDescription + description)\n                .allowableValues(new AllowableListValues(values, \"LIST\"));\n        if (coverageModel) {\n            parameterBuilder.modelRef(new ModelRef(\"List\", new AllowableListValues(values, \"LIST\")));\n        }\n    }\n\n    /**\n     * 添加响应包装的model，为了能够和responseMessages映射\n     *\n     * @see SwaggerConfiguration#apply(springfox.documentation.spi.service.contexts.OperationContext)\n     */\n    @Override\n    public void apply(RequestMappingContext context) {\n        if (Result.class.equals(context.getReturnType().getErasedType())) {\n            return;\n        }\n        ResolvedType returnType = resolver.resolve(Result.class, context.alternateFor(context.getReturnType()));\n        context.operationModelsBuilder().addReturn(returnType);\n    }\n\n    /**\n     * 由于配置了spring的bodyAdvice，swagger是检测不出来最外层的包装。\n     * 所以此配置增加最外层响应的包装\n     */\n    @Override\n    public void apply(OperationContext context) {\n        if (Result.class.equals(context.getReturnType().getErasedType())) {\n            return;\n        }\n        ResolvedType returnType = resolver.resolve(Result.class, context.alternateFor(context.getReturnType()));\n\n        ModelContext modelContext = ModelContext.returnValue(\n                context.getGroupName(),\n                returnType,\n                context.getDocumentationType(),\n                context.getAlternateTypeProvider(),\n                context.getGenericsNamingStrategy(),\n                context.getIgnorableParameterTypes());\n\n        ResponseMessage built = new ResponseMessageBuilder()\n                .code(ResponseMessagesReader.httpStatusCode(context))\n                .message(ResponseMessagesReader.message(context))\n                .responseModel(modelRefFactory(modelContext, typeNameExtractor).apply(returnType))\n                .build();\n\n        context.operationBuilder().responseMessages(newHashSet(built));\n    }\n}\n```","tags":["swagger"],"categories":["java","swagger"]},{"title":"java-agent","url":"/posts/java-agent/","content":"\n# 简介\n* 什么是java-agent、作用是什么、怎么用、原理是什么?   \n  java-agent可以理解为是一个代理程序，非主程序，代理程序可以做的事情就很多了，取决于你想写什么逻辑  \n  比如说[Alibaba开源的Java诊断工具](https://arthas.aliyun.com/doc/)  \n  也可以动态的替换字节码，实现代码热更新的效果  \n\n---\n\n# 原理\n通过java-agent程序我们可以获取到`Instrumentation`实例，得到此实例之后可以干的事情就很多了，比如说aop字节码增强，或者重新定义class等  \n> 具体原理可参考   \n> 1：[美团的技术分享-agent原理](https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html)  \n> 2：[美团的技术分享-字节码增强原理](https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html)\n\n1. agent程序可以在主程序启动之前启动，做你想做的操作,需要编写逻辑代码并封装成Jar包，并在jvm 启动命令添加 -\\[javaagent|agentlib]:agentJar包的路径，jdk1.5之后才可以   \n  jar包中的class方法signature必须为 `public static void premain(String agentArgs, Instrumentation inst)`\n\n2. 也可以在主程序运行过程中启动，通过jdk自带的方法`VirtualMachine#attach.loadAgent(\"你封装的agentJar包路径\")`，jdk1.6之后才可以  \n  jar包中的class方法signature必须为 `public static void agentmain(String agentArgs, Instrumentation inst)`\n\nInstrumentation简称JVMTI（JVM Tool Interface）  \n```java\npublic interface Instrumentation {\n    // 添加class转换器，在class加载的时候可以修改class字节码\n    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);\n\n    boolean removeTransformer(ClassFileTransformer transformer);\n\n    boolean isRetransformClassesSupported();\n\n    void retransformClasses(Class<?>... classes) throws UnmodifiableClassException;\n\n    boolean isRedefineClassesSupported();\n\n    // 重新定义class\n    void redefineClasses(ClassDefinition... definitions) throws  ClassNotFoundException, UnmodifiableClassException;\n\n    boolean isModifiableClass(Class<?> theClass);\n\n    Class[] getAllLoadedClasses();\n\n    Class[] getInitiatedClasses(ClassLoader loader);\n\n    long getObjectSize(Object objectToSize);\n\n    void appendToBootstrapClassLoaderSearch(JarFile jarfile);\n\n    void appendToSystemClassLoaderSearch(JarFile jarfile);\n\n    boolean isNativeMethodPrefixSupported();\n\n    void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix);\n}\n```\n\n## 具体使用  \n\n* java代码  \n  ```java\n  public final class DynamicInstrumentationAgent {\n  \n      private DynamicInstrumentationAgent() {\n      }\n  \n      public static void premain(final String args, final Instrumentation inst) throws Exception {\n          ...\n          // 拿着inst可以干很多事情，比如说替换字节码等\n      }\n  \n      public static void agentmain(final String args, final Instrumentation inst) throws Exception {\n          premain(args, inst);\n      }\n  \n  }\n  ```\n\n* MANIFEST.MF  \n  ```manifest\n  \n  Manifest-Version: 1.0\n  Premain-Class: DynamicInstrumentationAgent\n  Agent-Class: DynamicInstrumentationAgent\n  Can-Redefine-Classes: true\n  Can-Retransform-Classes: true\n  \n  ```\n\n* 打成jar包  \n把java代码和MANIFEST.MF打成jar包，并把MANIFEST.MF放在META-INF目录下即可\n\n\n---\n\n# agent实现热更新\n* 获取到`Instrumentation`实例之后调用`redefineClasses(ClassDefinition definition)`重新定义class字节码实现热更新  \n  如果新的class转换错误，则此方法将引发异常，且不会重新转换任何类  \n  redefineClasses只能修改方法体，并且替换时会等待safePoint，STW，JIT逆优化等\n  如果修改的方法有活动的堆栈帧，那么这些活动的帧将继续运行原方法的字节码。修改后的方法将用于新的调用  \n  热更新底层原理可[参考其他文章-美团的技术分享-agent原理](https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html)  \n  > ClassDefinition包含了老的class和新的class字节码\n\n\n\n不是说class一旦加载之后就不能修改吗？为什么agent却可以啊  \n原来是部分不能修改，不能增删改字段成员和方法的signature，只能修改方法体的内容  \n如果觉得只能修改方法体太局限  \n1. [可以参考快速集成springRemoteRestart](/posts/解决springRemoteRestart不起作用#重新启动)  \n2. [其他热部署利器](https://www.cnblogs.com/zyl2016/p/13666945.html)  \n\n> 为什么只能修改方法体呢？  \n> 比如说如果对Class增加/修改/删除field，由于class加载后，对象实例化后，就会在heap上占据一片（连续）区域  \n> 动态修改区域，不可避免会遇到冲突（比如下一片区域已经被分配了）  \n> 所以这种方法目前只能支持修改方法体\n\n\n# 在运行时获取到`Instrumentation`实例  \n\n配置第三方jar包  \n  ```xml\n  <dependency>\n    <groupId>de.invesdwin</groupId>\n    <artifactId>invesdwin-instrument</artifactId>\n    <version>1.0.14</version>\n  </dependency>\n  \n  <repositories>\n    <repository>\n      <id>de.invesdwin</id>\n      <url>https://invesdwin.de/repo/invesdwin-oss-remote/</url>\n    </repository>\n  </repositories>\n```\n\n使用方式如下    \n  ```java\n  DynamicInstrumentationLoader.waitForInitialized();\n  Instrumentation instrumentation = InstrumentationSavingAgent.getInstrumentation();\n```\n\n原理就是通过`VirtualMachine#attach`方法attach自己，然后把instrumentation变为自己的静态变量","tags":["jvm","热部署"],"categories":["java","jvm"]},{"title":"解决springRemoteRestart不起作用","url":"/posts/解决springremoterestart不起作用/","content":"\nspringDevTools提供了热部署的工具，按照网上的教程本地可以完美的支持热部署，但是一用到remoteRestart远程热部署就失效，热部署失败，抛ClassCastException异常    \n为了解决这个问题，咱们今天分析一下他的原理，为什么本地修改的可以热部署，远程remoteRestart就会失效(热部署时为什么会报异常)  \n技术栈：springBoot + MVC + DUBBO + NACOS + maven打包插件spring-boot-maven-plugin  \n\n\n# 热部署原理分析\n当我们修改class时，springDevTools利用了不同的classLoader重新加载class，并重新启动spring，使其生效  \n优点就是已经加载过的class并不会重新加载以便节省性能，只针对动态修改的class重新加载即可\n> 已加载的class无法在线卸载，只能用新的classLoader去加载，这样就起到了热部署的效果  \n> 旧的classLoader以及对应加载过的class会被GC回收  \n\n1. 在[springBoot启动的时候，监听启动时的事件](/posts/springBoot容器启动流程)，然后用自己的热部署classLoader去重新启动spring（通过反射再次调用main）  \n2. [自己classLoader并没有遵循双亲委派机制](/posts/jvmClassLoader过程及原理)，而且优先用最新的class  \n3. 最新的class是由spring实时监听class文件的变化，如果有修改则会上传到最新的class中，并让devTools重新启动spring    \n   如果要达到热部署的目的，必须能把老的class卸载，所以必须是老的classLoader加载的这些类才行，这样当老的classLoader回收时所对应老的class也会一并销毁  \n   如果采用双亲委派机制由JDK加载的话那就无法卸载\n4. 在重新启动的过程中如果有最新的class就用，没有就遵循双亲委派去加载class，以此达到热部署的目的  \n\n## 分析本地热部署  \n引入devTools的jar包，直接启动即可\n\n```java\n@Lazy(false)\n@Configuration(proxyBeanMethods = false)\n// 如果没有配置，只要引入了jar包，默认就是开启的状态\n@ConditionalOnProperty(prefix = \"spring.devtools.restart\", name = \"enabled\", matchIfMissing = true)\nstatic class RestartConfiguration {\n\n    // restart配置文件\n    private final DevToolsProperties properties;\n\n    RestartConfiguration(DevToolsProperties properties) {\n        this.properties = properties;\n    }\n\n    // 监听文件变动的工厂\n    @Bean\n    FileSystemWatcherFactory fileSystemWatcherFactory() {\n        return this::newFileSystemWatcher;\n    }\n    ...\n    private FileSystemWatcher newFileSystemWatcher() {\n        // 监听文件变动的实现\n        Restart restartProperties = this.properties.getRestart();\n        FileSystemWatcher watcher = new FileSystemWatcher(true, restartProperties.getPollInterval(), restartProperties.getQuietPeriod());\n        String triggerFile = restartProperties.getTriggerFile();\n        if (StringUtils.hasLength(triggerFile)) {\n            watcher.setTriggerFilter(new TriggerFileFilter(triggerFile));\n        }\n        List<File> additionalPaths = restartProperties.getAdditionalPaths();\n        for (File path : additionalPaths) {\n            watcher.addSourceDirectory(path.getAbsoluteFile());\n        }\n        return watcher;\n    }\n\n    // 此实例可以监听到文件变动的事件，当事件来临时重启服务，达到热部署的效果\n    @Bean\n    ApplicationListener<ClassPathChangedEvent> restartingClassPathChangedEventListener(FileSystemWatcherFactory fileSystemWatcherFactory) {\n        return (event) -> {\n            if (event.isRestartRequired()) {\n                //Restarter实例，在spring启动的时候已经初始化了\n                Restarter.getInstance().restart(new FileWatchingFailureHandler(fileSystemWatcherFactory));\n            }\n        };\n    }\n\n\n    // 获取监听文件变动的工厂，从工厂获取监听文件变化的实例，注册到beanFactory之后，监听文件的实例开始工作，文件有变化，则以事件的方式广播出去，不关心具体实现\n    @Bean\n    @ConditionalOnMissingBean\n    ClassPathFileSystemWatcher classPathFileSystemWatcher(FileSystemWatcherFactory fileSystemWatcherFactory, ClassPathRestartStrategy classPathRestartStrategy) {\n        URL[] urls = Restarter.getInstance().getInitialUrls();\n        ClassPathFileSystemWatcher watcher = new ClassPathFileSystemWatcher(fileSystemWatcherFactory, classPathRestartStrategy, urls);\n        watcher.setStopWatcherOnRestart(true);\n        return watcher;\n    }\n    ...\n}\n```\n\n## 分析远程热部署\n1. 用springBoot打包需要maven打包时包含devTools  \n    ```xml\n    <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n        <configuration>\n            <excludeDevtools>false</excludeDevtools>\n        </configuration>\n    </plugin>\n    ```\n\n2. 配置文件中必须要配置secret  \n   spring.devtools.remote.secret=mysecret\n\n3. 启动远端服务器\n\n4. 启动本地代码，并把远端服务器的地址配置即可使用  \n   指定Main Class为org.springframework.boot.devtools.RemoteSpringApplication  \n   指定Program arguments为http://127.0.0.1:8081 即远端服务的地址\n   \n* server端(remote)代码原理解析  \n    ```java\n    @Configuration(proxyBeanMethods = false)\n    // 如果没有配置，只要引入了jar包，默认就是开启的状态\n    @ConditionalOnProperty(prefix = \"spring.devtools.remote.restart\", name = \"enabled\", matchIfMissing = true)\n    static class RemoteRestartConfiguration {\n    \n        // 筛选需要用restartClassLoader加载的class\n        @Bean\n        @ConditionalOnMissingBean\n        SourceDirectoryUrlFilter remoteRestartSourceDirectoryUrlFilter() {\n            return new DefaultSourceDirectoryUrlFilter();\n        }\n    \n        // 处理http的请求，接收参数，调用Restarter重启服务\n        @Bean\n        @ConditionalOnMissingBean\n        HttpRestartServer remoteRestartHttpRestartServer(SourceDirectoryUrlFilter sourceDirectoryUrlFilter) {\n            return new HttpRestartServer(sourceDirectoryUrlFilter);\n        }\n    \n        // 配置http地址的映射，相当于配置一个servlet,暴露一个接口，这样client通过此接口和server进行交互\n        @Bean\n        @ConditionalOnMissingBean(name = \"remoteRestartHandlerMapper\")\n        UrlHandlerMapper remoteRestartHandlerMapper(HttpRestartServer server, ServerProperties serverProperties, DevToolsProperties properties) {\n            Servlet servlet = serverProperties.getServlet();\n            String servletContextPath = (servlet.getContextPath() != null) ? servlet.getContextPath() : \"\";\n            \n            String url = servletContextPath + properties.getRemote().getContextPath() + \"/restart\";\n            \n            return new UrlHandlerMapper(url, new HttpRestartServerHandler(server));\n        }\n    \n    }\n    ```\n\n* client端代码原理解析  \n  client负责监听文件的变化，然后上传到服务端，服务端接收到文件之后会用新的classLoader重新加载class达到热部署的目的  \n  同[分析本地热部署](#分析本地热部署)原理一样，因为文件变化会有事件通知，只不过此监听器是用来和remoteServer的http接口打交道的，会把修改后的class字节码上传到服务端  \n\n\n## restartClassLoader只加载部分class的源码  \ndevTools的热部署classLoader只会加载部分的class，其余的class归JDK加载，JDK加载的class无法实现热部署，那么他是如何只加载部分的class呢？\n\n```java\nfinal class ChangeableUrls implements Iterable<URL> {\n    ...\n    private final List<URL> urls;\n    \n    // 该参数是JDK的classLoader对应的URLS(也就是所有的class路径)\n    private ChangeableUrls(URL... urls) {\n        DevToolsSettings settings = DevToolsSettings.get();\n        List<URL> reloadableUrls = new ArrayList<>(urls.length);\n        for (URL url : urls) {\n            if ((settings.isRestartInclude(url) || isDirectoryUrl(url.toString())) && !settings.isRestartExclude(url)) {\n                reloadableUrls.add(url);\n            }\n        }\n        this.urls = Collections.unmodifiableList(reloadableUrls);\n        ...\n    }\n\n    // 也就是说restart本地启动的时候(非remoteRestart)，只会加载自己项目的class，因为自己项目的class在Idea中就是以文件的方式存在\n    private boolean isDirectoryUrl(String urlString) {\n        return urlString.startsWith(\"file:\") && urlString.endsWith(\"/\");\n    }\n\t...\n\n    @Override\n    public Iterator<URL> iterator() {\n        return this.urls.iterator();\n    }\n}\n```\n\n---\n\n# 解决远程热部署不生效的问题\n我们已经知道了他的原理是用不同的classLoader去加载最新的class，只有老的classLoader加载的class才能卸载，这样新的class才会重新加载热部署才会生效  \n根据网上的教程配置好remote远程热部署之后发现修改class上传部署启动时就会报ClassNotFondException或者会报ClassCastException\n\n* ClassNotFondException   \n  配置热部署检测文件改动的时间间隔就行  \n  因为class编译后会重新覆盖，覆盖过程中会先把老的文件给删除，因为有时间差，所以spring误以为是删除而不是更新，这样导致重新启动的时候spring就找不到class了。  \n  > 那为什么本地的就不会有这个问题，或者有这个问题之后不一会就好了呢？  \n  因为remote是通过http协议传输新class的。在重新启动的过程中http会停止服务，一旦启动不起来就无法和cline交互了，也就永远起不来了  \n  而本地没有通过http，它是在本地内存中直接执行热部署的代码逻辑，所以即使启动失败了也没关系，不一会他能检测到新文件的到来并且会触发事件重新启动，这样就不会报ClassNotFondException异常了  \n\n  但是因为时间差的原因，还会有几率出现这样的问题，那么只能从源码中下手改代码了，或者用triggerFile触发更新也可以\n\n* ClassCastException  \n    原来是maven打包插件spring-boot-maven-plugin惹的祸，通过此插件会把我们的项目打包成jar包。[这样spring无法识别是file文件](#restartclassloader只加载部分class的源码)，class就被JDK的classLoader加载了  \n    当新的classLoader加载修改过的class时，由于没有采用双亲委派机制，导致父子classLoader都会加载这个class，但是会优先用子classLoader加载的class，导致class在连接的时候出现了ClassCastException异常  \n  \n    > 解决办法是在devTools的classLoader加载class的时候，把我们的jar包给指定上就可以了  \n\n\n## remoteRestart-ClassCastException异常解决  \n1. 项目编译时设置特定的标识  \n   maven配置如下插件，在打包后的MANIFEST.MF中添加自定义的属性    \n   ```xml\n   <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <reload>true</reload>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n   ```\n2. 编写代码，覆盖spring的`getInitialUrls`，指定返回要热加载的jar包  \n\n注意通过编写一模一样的包名，放在自己的项目中，当启动的时候会优先用自己编写的，为什么会优先用自己编写的呢？[这个和classPath有关](/posts/jvmClassLoader过程及原理)  \n\n```java\npackage org.springframework.boot.devtools.restart;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.devtools.logger.DevToolsLogFactory;\nimport org.springframework.boot.devtools.system.DevToolsEnablementDeducer;\n\nimport java.net.JarURLConnection;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * 重写获取URL的方法\n *\n * @author anyOne\n * @since 2021/8/15 1:49 PM\n */\n@Slf4j\npublic class DefaultRestartInitializer implements RestartInitializer {\n    @Override\n    public URL[] getInitialUrls(Thread thread) {\n        if (!thread.getName().equals(\"main\")) {\n            return null;\n        }\n        if (!DevToolsEnablementDeducer.shouldEnable(thread)) {\n            return null;\n        }\n        Collection<URL> urls = getUrls(thread);\n        DevToolsLogFactory.getLog(DefaultRestartInitializer.class).info(\"reload urls:\" + urls);\n        return urls.toArray(new URL[0]);\n    }\n\n    private Set<URL> getUrls(Thread thread) {\n\n        HashSet<URL> urls = new HashSet<>();\n        urls.addAll(ChangeableUrls.fromClassLoader(thread.getContextClassLoader()).toList());\n        // dubbo 销毁后无法重新注册，所以有关dubbo的class也一并加载\n        // nacos也一样，存有静态变量影响会重新启动 {@see com.alibaba.nacos.spring.core.env.NacosPropertySourcePostProcessor.beanFactory}\n        urls.addAll(Arrays.stream(((URLClassLoader) thread.getContextClassLoader()).getURLs())\n                .filter(t ->\n                        t.getPath().contains(\"dubbo\")\n                                || t.getPath().contains(\"nacos-spring-context\")\n                                || t.getPath().contains(\"nacos-config-spring-boot-autoconfigure\")\n                ).collect(Collectors.toSet()));\n\n        urls.addAll(Arrays.stream(((URLClassLoader) thread.getContextClassLoader()).getURLs())\n                .filter(t -> {\n                    try {\n                        JarURLConnection urlConnection = (JarURLConnection) t.openConnection();\n                        // 判断是自己的项目则返回\n                        return Boolean.parseBoolean(urlConnection.getMainAttributes().getValue(\"reload\"));\n                    } catch (Exception e) {\n                        return false;\n                    }\n                }).collect(Collectors.toSet()));\n        return urls;\n    }\n\n}\n```\n\n这样配置好之后，restartClassLoader会加载这些class，不然父的classLoader加载的class无法卸载。也就无法实现热部署的效果了\n    \n---\n\n\n# 优化热部署-减少部署时间\n\n优先用[agent替换字节码的方式实现热部署](/posts/java-agent#agent实现热更新)，秒级生效（如果不违反规范，且可以生效的话）  \n如果失败，则还跟之前是有的方式一模一样，需要注意的是，需要修改restart文件才会重启（类似triggerFile触发重启，可以避免ClassNotFondException）  \n> 使用方式不变，跟springDevToolsRestart一模一样，修改后文件后编译即可，不一样的是服务端做了手脚，增加一层优化\n\n```java\n@Slf4j\n@Configuration\n@ConditionalOnClass(HttpRestartServer.class)\npublic class DevToolsReloadConfig {\n\n    @Autowired\n    ResourceLoader resourceLoader;\n\n    @Bean\n    public HttpRestartServer remoteRestartHttpRestartServer() {\n        return new HttpRestartServer(getRestartServer(new DefaultSourceDirectoryUrlFilter()));\n    }\n\n    // 重写restartServer\n    private RestartServer getRestartServer(SourceDirectoryUrlFilter sourceDirectoryUrlFilter) {\n        return new RestartServer(sourceDirectoryUrlFilter) {\n            final ClassLoaderFiles newFile = new ClassLoaderFiles();\n            Set<String> waitingRestartFileNames = new HashSet<>();\n\n            /**\n             * 重载方法，接收新的class，优先用agent方式热更新，速度非常快\n             */\n            protected synchronized void restart(Set<URL> urls, ClassLoaderFiles newFiles) {\n                for (ClassLoaderFiles.SourceDirectory sourceDirectory : newFiles.getSourceDirectories()) {\n                    for (Map.Entry<String, ClassLoaderFile> fileEntry : sourceDirectory.getFilesEntrySet()) {\n                        newFile.addFile(sourceDirectory.getName(), fileEntry.getKey(), fileEntry.getValue());\n                        try {\n                            if (fileEntry.getKey().endsWith(\".class\") && fileEntry.getValue().getKind() != ClassLoaderFile.Kind.DELETED) {\n                                // 第三方开源的jar包，使当前的jvm能够获取到 JVMTI Instrumentation 实例\n                                DynamicInstrumentationLoader.waitForInitialized();\n\n                                String className = fileEntry.getKey()\n                                        .replace(\"/\", \".\")\n                                        .replace(\".class\", \"\");\n\n                                Class<?> oldClass = ClassUtils.forName(className, resourceLoader.getClassLoader());\n\n                                ClassDefinition classDefinition = new ClassDefinition(oldClass, fileEntry.getValue().getContents());\n                                // 重新定义\n                                InstrumentationSavingAgent.getInstrumentation().redefineClasses(classDefinition);\n                                // 替换成功则移除，\n                                waitingRestartFileNames.remove(fileEntry.getKey());\n                                log.info(\"class reload:{}\", fileEntry.getKey());\n                                continue;\n                            }\n                        } catch (Throwable e) {\n                            // 替换失败，只能通过热部署重启的方式啦。\n                            log.info(fileEntry.getKey() + \"reload failure，Modify the restart file for the restart to take effect:\" + e.getClass().getName() + \":\" + e.getMessage());\n                        }\n                        waitingRestartFileNames.add(fileEntry.getKey());\n\n                    }\n                }\n\n                // 指定的restart文件有变动则重启，相当于restart中的triggerFile。\n                if (waitingRestartFileNames.isEmpty() || !waitingRestartFileNames.contains(\"restart\")) {\n                    log.info(\"waitingRestartFileNames is empty or no restart file，waitingRestartFileNames:{}\", waitingRestartFileNames);\n                    return;\n                }\n\n                Restarter restarter = Restarter.getInstance();\n                // 指定urls后restart类加载器会生效\n                restarter.addUrls(urls);\n                // 新的文件\n                restarter.addClassLoaderFiles(newFile);\n\n                // 记录本次更新的文件，如果启动失败，说明本次的更新文件有问题，用来删除并重新启动\n                Set<String> persistentUpdatedFileNames = new HashSet<>(waitingRestartFileNames);\n                \n                waitingRestartFileNames = new HashSet<>();\n\n                log.warn(\"spring restart new files:{}\", persistentUpdatedFileNames);\n                restarter.restart(failure -> {\n                    if (persistentUpdatedFileNames.isEmpty()) {\n                        // 本次修改的文件为空，说明跟修改的文件没有关系，属于正常的启动失败\n                        return FailureHandler.Outcome.ABORT;\n                    }\n                    \n                    // 如果启动失败，则删除本次更新的文件，保证能正常启动，不然服务挂了，别让你这个热部署的插件 造成不好的影响\n                    try {\n                        // 由于是final只能通过反射来移除新增的class文件了\n                        ClassLoaderFiles classLoaderFiles = (ClassLoaderFiles) FieldUtils.readDeclaredField(restarter, \"classLoaderFiles\", true);\n                        \n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, ClassLoaderFiles.SourceDirectory> sourceDirectories = (Map<String, ClassLoaderFiles.SourceDirectory>) FieldUtils.readDeclaredField(classLoaderFiles, \"sourceDirectories\", true);\n                        \n                        for (Map.Entry<String, ClassLoaderFiles.SourceDirectory> directoryEntry : sourceDirectories.entrySet()) {\n                            \n                            @SuppressWarnings(\"unchecked\")\n                            Map<String, ClassLoaderFile> files = (Map<String, ClassLoaderFile>) FieldUtils.readDeclaredField(directoryEntry.getValue(), \"files\", true);\n                            \n                            for (String name : persistentUpdatedFileNames) {\n                                files.remove(name);\n                            }\n                        }\n\n                        log.warn(\"retry failure，Try to delete the new file and restart:{}\", persistentUpdatedFileNames);\n                        // 清空\n                        persistentUpdatedFileNames.clear();\n                        // 重新启动\n                        return FailureHandler.Outcome.RETRY;\n                    } catch (IllegalAccessException e) {\n                        throw new RuntimeException(e);\n                    }\n                });\n            }\n        };\n    }\n\n}\n```","tags":["spring","热部署"],"categories":["java","spring"]},{"title":"spring事务和aop的原理","url":"/posts/spring事务和aop的原理/","content":"\n# AOP\n\nspringAop大体分为两种技术方式，一种是基于动态代理的，一种是基于字节码增强的  \n\n* 动态代理的有基于\n  1. jdk的\n  2. 基于CGLIB的\n    \n\n\n  \n* 字节码增强的有\n  1. 在编译时做增强的\n  2. class加载的时候做增强的\n  \n```java\npublic enum AdviceMode {\n\n\t/**\n\t * JDK proxy-based advice.\n\t */\n\tPROXY,\n\n\t/**\n\t * AspectJ weaving-based advice.\n\t */\n\tASPECTJ\n\n}\n```\n\n\n## 基于动态代理-PROXY \n\n`AbstractAutoProxyCreator`它是个抽象类，并且是[bean的后置处理器，在bean创建的时候拦截，并寻找合适的切入点返回对应的proxy](/posts/beanPostProcessor的调用流程及各种实现#7-postprocessafterinitialization)    \n其中有3个实现类  \n\n1. InfrastructureAdvisorAutoProxyCreator  \n   如果只是开启事务则会用到此实现  \n   AOP生效规则：bean必须是`Advisor`类型，且role为`BeanDefinition.ROLE_INFRASTRUCTURE`才会生效  \n  \n2. AspectJAwareAdvisorAutoProxyCreator  \n  基于xml配置方式`<aop:config>...</aop:config>`  \n  AOP生效规则：只要是`Advisor`类型的bean就会生效，不关心role\n  \n  \n3. AnnotationAwareAspectJAutoProxyCreator  \n  继承上面那个类  \n  AOP生效规则：同上且支持注解表达式`@Aspect`\n\n> 优先级从上到下，只要注册了优先级比较高的class，低优先级的会自动失效\n\n不论是事务`@EnableTransactionManagement`，还是缓存`@EnableCaching`，或者自定义的AOP`@EnableAspectJAutoProxy`，只会往beanFactory注册一个`AbstractAutoProxyCreator`类型的bean  \nbeanName为`org.springframework.aop.config.internalAutoProxyCreator`\n\n```java\npublic abstract class AopConfigUtils {\n\n  /**\n   * The bean name of the internally managed auto-proxy creator.\n   */\n  public static final String AUTO_PROXY_CREATOR_BEAN_NAME =\n          \"org.springframework.aop.config.internalAutoProxyCreator\";\n\n  /**\n   * Stores the auto proxy creator classes in escalation order.\n   */\n  private static final List<Class<?>> APC_PRIORITY_LIST = new ArrayList<>(3);\n\n  static {\n    // Set up the escalation list...\n    APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);\n    APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);\n    APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);\n  }\n  ...\n\n  // 代理class\n  public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) {\n    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\n      BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\n      definition.getPropertyValues().add(\"proxyTargetClass\", Boolean.TRUE);\n    }\n  }\n\n  // 暴露proxy\n  public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) {\n    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\n      BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\n      definition.getPropertyValues().add(\"exposeProxy\", Boolean.TRUE);\n    }\n  }\n\n  // 往beanFactory注册拦截bean初始化的beanPostProcessor\n  private static BeanDefinition registerOrEscalateApcAsRequired(Class<?> cls, BeanDefinitionRegistry registry, @Nullable Object source) {\n      \n    Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\n    // 如果已经注册过则不会重新注册\n    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\n      BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\n      if (!cls.getName().equals(apcDefinition.getBeanClassName())) {\n        int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());\n        int requiredPriority = findPriorityForClass(cls);\n        if (currentPriority < requiredPriority) {\n          apcDefinition.setBeanClassName(cls.getName());\n        }\n      }\n      return null;\n    }\n\n    RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);\n    beanDefinition.setSource(source);\n    beanDefinition.getPropertyValues().add(\"order\", Ordered.HIGHEST_PRECEDENCE);\n    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);\n    return beanDefinition;\n  }\n}\n```\n\n* 注册完之后会在bean实例化的拦截，寻找能够切入的点，返回对应的proxy  \n```java\npublic abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware {\n    @Override\n    public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {\n        if (bean != null) {\n            Object cacheKey = getCacheKey(bean.getClass(), beanName);\n            // 如果没有提供过早期的引用(循环引用)，则可以进行proxy（早期的引用已经proxy了）\n            if (this.earlyProxyReferences.remove(cacheKey) != bean) {\n                return wrapIfNecessary(bean, beanName, cacheKey);\n            }\n        }\n        return bean;\n    }\n    \n    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n\t\tif (StringUtils.hasLength(beanName) && this.targetSourcedBeans.contains(beanName)) {\n\t\t\treturn bean;\n\t\t}\n\t\tif (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n\t\t\treturn bean;\n\t\t}\n\t\t//  过滤掉不必代理的类，\n        //  如果是这些接口的实现Advice、Pointcut、Advisor、AopInfrastructureBean，则不会代理\n\t\tif (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n\t\t\tthis.advisedBeans.put(cacheKey, Boolean.FALSE);\n\t\t\treturn bean;\n\t\t}\n\n\t\t// 根据当前的class寻找对应的AOP\n\t\tObject[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n\t\tif (specificInterceptors != DO_NOT_PROXY) {\n\t\t\tthis.advisedBeans.put(cacheKey, Boolean.TRUE);\n\t\t\t// 创建代理\n\t\t\tObject proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n\t\t\tthis.proxyTypes.put(cacheKey, proxy.getClass());\n\t\t\treturn proxy;\n\t\t}\n\n\t\tthis.advisedBeans.put(cacheKey, Boolean.FALSE);\n\t\treturn bean;\n\t}\n\t\n    protected Object createProxy(Class<?> beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) {\n\n        if (this.beanFactory instanceof ConfigurableListableBeanFactory) {\n            AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);\n        }\n\n        ProxyFactory proxyFactory = new ProxyFactory();\n        proxyFactory.copyFrom(this);\n\n        if (!proxyFactory.isProxyTargetClass()) {\n            if (shouldProxyTargetClass(beanClass, beanName)) {\n                proxyFactory.setProxyTargetClass(true);\n            }\n            else {\n                evaluateProxyInterfaces(beanClass, proxyFactory);\n            }\n        }\n\n        // 查找可以匹配的切入器\n        Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);\n        proxyFactory.addAdvisors(advisors);\n        proxyFactory.setTargetSource(targetSource);\n        customizeProxyFactory(proxyFactory);\n\n        proxyFactory.setFrozen(this.freezeProxy);\n        if (advisorsPreFiltered()) {\n            proxyFactory.setPreFiltered(true);\n        }\n\n        // 创建代理，动态判断是用cglib还是jdk\n        return proxyFactory.getProxy(getProxyClassLoader());\n    }\n\t...\n}\n```\n\n---\n\n## 基于字节码增强\n\n不同于proxy，字节码增强运行效率是比较快的，因为相当于我们手写的代码，且没有这么复杂的动态代理逻辑。更不会出现内嵌方法调用时aop不生效的情况  \n> 但这种技术为什么没有流行起来呢？原因有两个  \n> 1是需要通过运维支持在jvm 启动的时候添加 -javaagent:'jarPath' 命令，比较复杂(也可以通过技术手段在运行中获取到`Instrumentation`实例，不用运维配置)  \n> 2是配置起来复杂，需要在代码层面提前配置好切入的表达式和对应的逻辑，且要保证切入的class没有提前加载才行  \n\n1. 基于agent在class加载的时候进行动态的替换字节码  \n   [字节码增强](/posts/java-agent)技术-ASPECTJ     \n\n2. 基于编译阶段做切入操作  \n  [具体可google搜索class编译时做字节码切入](https://leon-wtf.github.io/springboot/2019/12/30/spring-aop-vs-aspectj/)\n\n\n---\n\n# 事务的原理\nspringBoot: `@EnableTransactionManagement`  \nspring.xml: `<tx:annotation-driven/>`  \n以上配置表明`@Transactional`注解即可生效，那么他的原理是什么呢？  \n\n## 基于PROXY  \n  注册一个aop实例，类型为`Advisor`，判断有@Transaction注解的就会自动动态代理  \n  > 在方法调用的时候，aop拦截方法并执行`TransactionAspectSupport#invokeWithinTransaction`，根据`@Transaction`的配置进行开始事务、隔离配置、回滚等操作\n\n* xml注册的代码  \n  `AnnotationDrivenBeanDefinitionParser#parse`\n\n* 注解注册的代码  \n  `TransactionManagementConfigurationSelector#selectImports`\n\n## 基于[字节码增强](/posts/java-agent)  \n字节码增强，spring兼容的不太好。因为字节码需要agent，并且需要class字节器转换器。  \n基于字节码的切入，即使不用配置事务的注解`@EnableTransactionManagement`，也会生效。    \n只要保证要切入的类在加载之前agent能正常运行且有class转换器`org.springframework.transaction.aspectj.AnnotationTransactionAspect`即可  \n\n---\n\n# 设置事务对所有的异常进行回滚\n\n默认为RuntimeException和Error的类型才会事务回滚  \n```java\n\npublic class DefaultTransactionAttribute extends DefaultTransactionDefinition implements TransactionAttribute {\n    ...\n    @Override\n    public boolean rollbackOn(Throwable ex) {\n        return (ex instanceof RuntimeException || ex instanceof Error);\n    }\n    ...\n}\n```\n\n通过分析事务的核心代码`TransactionAspectSupport#invokeWithinTransaction`(开启、回退、隔离级别等)，我们发现注解的配置由`TransactionAttributeSource`提供  \n我们只需要重写`TransactionAttributeSource`，并应用即可\n\n<font color='red'>但是要注意这种方式只支持Proxy方式的事务，如果是基于字节码那么修改源码了（字节码的切入不受spring管控）</font>\n\n## 代码\n\n```java\n@Slf4j\n@Configuration\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\npublic class TransactionRollbackSupport implements BeanDefinitionRegistryPostProcessor {\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        AbstractBeanDefinition transactionAttributeSource = (AbstractBeanDefinition) beanFactory.getBeanDefinition(\"transactionAttributeSource\");\n        transactionAttributeSource.setInstanceSupplier(AllRollback::new);\n    }\n\n    /**\n     * @see ProxyTransactionManagementConfiguration#transactionAttributeSource()\n     */\n    private static class AllRollback extends AnnotationTransactionAttributeSource {\n        @Override\n        protected TransactionAttribute computeTransactionAttribute(Method method, Class<?> targetClass) {\n            TransactionAttribute transactionAttribute = super.computeTransactionAttribute(method, targetClass);\n            if (!(transactionAttribute instanceof RuleBasedTransactionAttribute)) {\n                return transactionAttribute;\n            }\n\n            boolean hasRollbackRule = ((RuleBasedTransactionAttribute) transactionAttribute).getRollbackRules()\n                    .stream()\n                    .filter(t -> !(t instanceof NoRollbackRuleAttribute))\n                    .anyMatch(Objects::nonNull);\n            // 事务attributeRollback默认为Throwable,如果没有指定的话\n            if (hasRollbackRule) {\n                return transactionAttribute;\n            }\n            log.info(\"set Default transaction rollback exception as Throwable,class:{},method:{}\", targetClass.getSimpleName(), method.getName());\n            ((RuleBasedTransactionAttribute) transactionAttribute).getRollbackRules()\n                    .add(0, new RollbackRuleAttribute(Throwable.class));\n\n            return transactionAttribute;\n        }\n    }\n}\n```\n\n原理，[在spring注册完所有的beanDefinition之后](/posts/解析spring是如何向beanFactory注册bean的)，获取\"transactionAttributeSource\"的definition，并setInstanceSupplier，[这样在实例化的时候就会用自己的了](/posts/spring对bean实例化-初始化-流程#创建beanwrapper)","tags":["spring","动态代理"],"categories":["java","spring"]},{"title":"java实例化的几种方式","url":"/posts/java实例化的几种方式/","content":"\n1. 直接new  \n  调用了构造\n   \n2. 通过反射  \n  调用了构造\n   \n3. clone  \n  没有调用构造,但必须实现`Cloneable`接口，java通过native方法实现\n   \n4. 反序列化  \n  没有调用构造，通过调用`MethodAccessorGenerator#generateSerializationConstructor`生成一个新的构造对象，该构造对象不会调用构造方法  \n   \n5. 通过Unsafe类的allocateInstance()方法  \n   没有调用构造，只分配内存空间","tags":["java"],"categories":["java","基础"]},{"title":"beanPostProcessor的调用流程及各种实现","url":"/posts/beanpostprocessor的调用流程及各种实现/","content":"\n在[beanFactory初始化阶段会注册beanPostProcessor](/posts/springBeanFactory流程解析#5-注册拦截bean创建的bean处理器-beanpostprocessor)，它的作用就是在[bean实例化前、后，初始化前、后进行拦截操作](/posts/spring对bean实例化-初始化-流程#获取不到bean则创建)\n\n# BeanPostProcessor为最顶层的接口\n共有5种类型不同作用的间接接口（包含自己）\n如图![beanPostProcessor](/img/posts/2021/beanPostProcessor.png)\n\n\n---\n\n## **InstantiationAwareBeanPostProcessor**\n\n* postProcessBeforeInstantiation  \n可以拦截bean实例化之前（`不包含factoryBean#getObject`），如果返回不为空，则直接调用`BeanPostProcessor`的后置方法并直接返回，此时bean已创建完毕（很少用）\n\n* postProcessAfterInstantiation  \n返回值为Boolean类型，如果返回为false则不允许自动装配（很少用）\n\n* postProcessProperties  \n自动装配，<font color='red'>最重要的实现AutowiredAnnotationBeanPostProcessor实现自动装配</font>\n\n* postProcessPropertyValues  \n如果`postProcessProperties`返回值为null，则会调用此方法  <br/>\n    自动装配，<font color='red'>dubbo注解方式的自动装配：ReferenceAnnotationBeanPostProcessor</font>\n\n---\n\n## MergedBeanDefinitionPostProcessor\n* postProcessMergedBeanDefinition  \n在`postProcessBeforeInstantiation`之后，如果没有拦截实例化、则会通过[beanDefinition](/posts/springBeanFactory流程解析#4-beandefinitionregistry)准备实例化  \n实例化之前可以拦截beanDefinition做一些修改，或提取一些信息  \n比如说自动装配`@Autowired、@Resource`在这个阶段提取对应的字段或方法并缓存，然后再`postProcessProperties`阶段进行自动装配操作\n\n\n---\n\n## **BeanPostProcessor**\n\n* postProcessBeforeInitialization  \n可以替换或set对应的bean，<font color='red'>最重要的实现ApplicationContextAwareProcessor，各种Aware的处理</font>\n\n* postProcessAfterInitialization  \n可以替换或set对应的bean  <br/>\n  <font color='red'>最重要的实现AbstractAutoProxyCreator实现aop拦截</font>\n\n---\n\n## **SmartInstantiationAwareBeanPostProcessor**  \n\n* getEarlyBeanReference<br/>    \n  <font color='red'>提供早期的引用：如果是单例，并且是循环引用的情况下，最重要的实现InfrastructureAdvisorAutoProxyCreator实现事务aop拦截，且可以循环引用</font>\n\n* predictBeanType  \n通过beanName获取class的时候会调用此方法，可以重写此方法，返回bean的类型（返回可以为null）\n\n* determineCandidateConstructors  \nDetermine the candidate constructors to use for the given bean.(返回可以为null)\n\n---\n\n## DestructionAwareBeanPostProcessor\n* postProcessBeforeDestruction  \n  bean在销毁时会调用\n\n\n---\n\n# 鸟瞰各个方法的调用顺序\n\n## 1. postProcessBeforeInstantiation  \n> InstantiationAwareBeanPostProcessor  \n\n在bean实例化的时候调用此方法，如果返回不为空则会调用`postProcessAfterInitialization`并返回，至此后面的流程不在调用\n   \n## 2. MergedBeanDefinitionPostProcessor\n> InstantiationAwareBeanPostProcessor\n\n如果在`postProcessBeforeInstantiation`期间没有被提前实例化，则会调用此方法\n   \n## 3. getEarlyBeanReference\n> SmartInstantiationAwareBeanPostProcessor\n\n这个方法是在单例bean创建的时候通过调用此方法，包装成回调并[放入循环引用中的三级缓存中](/posts/spring对bean实例化-初始化-流程#三级缓存)，默认实现AOP:`AbstractAutoProxyCreator`\n\n## 4. postProcessAfterInstantiation  \n> InstantiationAwareBeanPostProcessor\n\n如果此方法如果返回false，则不允许自动装配了，换句话说就不会执行第5步了\n如果返回true，则要自动装配    \n通过`beanDefinition#getResolvedAutowireMode`返回值，可选择的执行spring内置的`autowireByType`或者`autowireByName`  \n> 装配的属性必须有set方法，并且只装配在beanFactory中存在的bean，不存在的并不会报错  \n\n## 5. postProcessProperties或postProcessPropertyValues\n> InstantiationAwareBeanPostProcessor\n\nspring实例化完bean之后调用`populateBean`进行自动装配  \n如果`postProcessProperties`返回为空，则会执行`postProcessPropertyValues`  \n默认实现IOC：`AutowiredAnnotationBeanPostProcessor`\n\n## 6. postProcessBeforeInitialization\n> BeanPostProcessor\n\n调用此方法之前会优先调用`BeanNameAware,BeanClassLoaderAware,BeanFactoryAware`接口的bean`set...`  \n\n此方法可以替换或set对应的bean，如各种Aware的处理进行set`ApplicationContextAwareProcessor`\n\n## 7. postProcessAfterInitialization\n> BeanPostProcessor\n\n调用此方法前优先会调用`InitializingBean`接口的bean`afterPropertiesSet`  \n可以替换或set对应的bean，如aop拦截返回代理的bean[`AbstractAutoProxyCreator`](/posts/spring事务和aop的原理)\n\n---\n\npostProcessBeforeDestruction\nbean在销毁的时候会调用，比如说当`spring#close`或者手动destroy时\n\n# 总结\nBeanPostProcessor为bean的后置处理器，共有5种不同的后置处理类型，每种后置类型有n多个方法  \nIOC`AutowiredAnnotationBeanPostProcessor`和AOP`AbstractAutoProxyCreator`都是通过后置处理完成的实现","tags":["源码","spring"],"categories":["java","spring"]},{"title":"spring对bean实例化-初始化-流程","url":"/posts/spring对bean实例化-初始化-流程/","content":"## 前言\n\n获取一个bean时`AbstractBeanFactory#doGetBean`，除非bean已经存在，否则会通过beanDefinition自动创建  \n\n创建时，[如果没有beanDefinition就会报错，所以beanDefinition是一个很重要的存在](/posts/springBeanFactory流程解析#4-beandefinitionregistry)\n\n**创建流程很复杂，必须要先了解bean的各种后置处理器[`BeanPostProcessor`](/posts/beanPostProcessor的调用流程及各种实现)**  \n\nspring获取bean时,底层是通过beanName获取的，如果是根据类型，那么他会先根据类型先获取name，然后根据name在获取bean  \n> beanName可以自定义，如果非自定义默认则是classSimpleName，且第一个字母小写  \n> FactoryBean类型的beanName也是同上,如果要获取FactoryBean类型的实例话，则beanName要以\"&\"为前缀。否则获取的就是factoryBean对应的实际bean\n\n以下为获取(创建)bean的大体流程\n\n---\n\n## 通过class类型或注解类型获取beanName\n**不管怎样，spring底层是[通过name获取对应的bean](#根据beanname优先获取单列的bean)**  \n如果是根据注解获取bean，底层则会遍历所有的beanNames，通过beanNames获取到对应的class，然后然后判断class上是否有相对应的注解  \n那么咱们只需要关注如何根据beanName获取到对应class，以及如何根据class获取到对应的beanNames就行  \n\n---\n\n### 通过beanName获取class流程  \n1. 从已初始化的单例bean`singletonObjects`中获取(不允许早期初始化-非循环依赖的方式获取)，没有就返回null，有就用返回实例对应的class  \n   > 如果是`FactoryBean`则使用`Factory#getObjectType`，否则用`obj.getClass()`直接返回\n\n2. 如果上一步未满足，并且本地不包含beanDefinition，则尝试从[parentBeanFactory中获取](#通过beanname获取class流程)，否则执行下一步  \n\n3. 获取beanDefinition  \n  如果不包含beanDefinition则就直接报错  \n  通过definition优先获取被包装的definition`getDecoratedDefinition`  \n  >  因为有可能目标类将要被代理，在创建beanDefinition的时候就做了手脚,比如说`ScopedProxyUtils#createScopedProxy`：bean的作用域通过代理实现  \n\n5. [获取beanDefinition对应的class](#通过rootbeandefinition获取真实的class)  \n最后通过[`SmartInstantiationAwareBeanPostProcessor#predictBeanType`](/posts/beanPostProcessor的调用流程及各种实现#smartinstantiationawarebeanpostprocessor)返回对应的beanType\n\n6. 执行factoryBean的转换  \n  如果参数beanName是以\"&\"为前缀，代表要获取FactoryBean类型的class，如果上一步获取到的class不是FactoryBean类型，则返回null  \n  如果参数beanName不是以\"&\"为前缀，代表要获取真实bean的类型，如果上一步获取到的不是FactoryBean类型，则直接返回，如果是FactoryBean类型，优先根据泛型获取对应的type，如果获取失败则要进行初始化FactoryBean,因为一会要调用`Factory#getObjectType`来返回真实的类型  \n  创建流程请参考[`AbstractAutowireCapableBeanFactory#createBeanInstance`](#创建beanwrapper)(包含构造注入流程)，完事会返回一个BeanWrapper，如果factoryBean本身是单例的话则会放入缓存中`factoryBeanInstanceCache`，[在获取bean的时候，保证不能有二次初始化](#缓存取对应的beanWrapper)\n\n---\n\n### 通过class获取对应的beanNames流程\n1. 获取所有已注册的beanDefinitionNames和手动注册的单例beanNames(手动注册的已初始化)  \n  条件包含：非alias、非abstract、且是否包含非单例、是否允许早期初始化两个动态条件\n\n2. 依次遍历beanName\n\n3. 通过[beanName获取class](#通过beanname获取class流程)  \n  与'通过beanName获取class流程'大体流程一致，但是有些许的不同，比如没有beanDefinition不会报错，如果是FactoryBean则尽量不初始化的情况下获取到对应的targetType，否则只能初始化并调用`getTargetType`\n\n5. 判断获取到的class  \n   * 如果没有获取到class则为false,代表不匹配  \n   * 获取到class之后调用`isInstance`  \n       如果返回true则会把当前的beanName添加到list里面，最后一并返回  \n       如果为false，并且当前的beanName的类型为FactoryBean类型则会拼接'&'前缀作为beanName从新判断  \n\n---\n\n## 根据beanName优先获取单列的bean\n\n---\n\n### 把beanName转换为为标准的beanName\n1. 去除\"&\"的前缀  \n   FactoryBean他就是一个普通的bean，在注册beanDefinition时和普通的bean别无二致，只有在[获取的时候会有不同](#factorybean的转换)\n2. 通过alias获取真实的Name  \n   alisa其底层实现其实就是一个map，key为alias，value为实际的beanName\n   \n优先获取单列，如果非单例的bean压根就获取不到，所以优先获取单列  \n> 也可以手动注册单例，但是一样的beanName不允许二次注册(there is already)  \n> 手动注册的和spring扫描的且已初始化的单列bean都是存放在同一个地方中：`singletonObjects`  \n\n---\n\n### 单例bean的获取流程\n1. 从`singletonObjects`优先获取单例bean(手动注册的和spring已初始化的都在同一个地方)，有则直接返回  \n2. 没有则判断当前的beanName是否为正在创建的单例bean，因为正在创建的bean可能会依赖其他的bean，而其他的bean依赖于正在创建的bean，就变成了一个循环依赖  \n   > spring在每创建一个单例bean之前把当前beanName存放在一个set中，标志正在创建中，创建完之后会从Set删除，并把创建的实例放入到`singletonObjects`中  \n\n3. 如果当前获取的bean正在创建(循环依赖)，则会从`earlySingletonObjects`中获取  \n   > `earlySingletonObjects`是map类型，作用是暂时存放正在创建的bean，key为beanName,value为bean的实例且是由`singletonFactories`提供的  \n\n4. 如果`earlySingletonObjects`获取为空，且允许早期的引用(循环依赖)则从[`singletonFactories`](#单例的bean放入三级缓存中)中获取  \n   `singletonFactories`由`SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference`提供早期的引用，如aop返回代理对象的引用  \n   > 等实例创建完之后会放入到`singletonObjects`中，并从`earlySingletonObjects`和`singletonFactories`移除  \n\n5. 执行factoryBean的转换\n\n<span id='三级缓存'></span>\n> 其实单例bean获取的时候就已经解决了循环依赖，以上的各个变量就是网上说的三级缓存，如果还不太理解可以直观的看下代码  \n```java\npublic class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {\n    ...\n    public Object getSingleton(String beanName) {\n        return getSingleton(beanName, true);\n    }\n    protected Object getSingleton(String beanName, boolean allowEarlyReference) {\n        Object singletonObject = this.singletonObjects.get(beanName);// 一级缓存，所有已初始化完的单例bean都在这里\n        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {// 当前bean正在创建中\n            singletonObject = this.earlySingletonObjects.get(beanName);// 二级缓存，第一次访问肯定是空的，二级缓存的值由三级缓存提供\n            if (singletonObject == null && allowEarlyReference) {\n                synchronized (this.singletonObjects) { // 上锁\n                    singletonObject = this.singletonObjects.get(beanName); // 再次查看一级缓存\n                    if (singletonObject == null) {\n                        singletonObject = this.earlySingletonObjects.get(beanName); // 再次查看二级缓存\n                        if (singletonObject == null) {\n                            // 调用三级缓存，三级缓存是在bean创建的时候放进去的，并且value为ObjectFactory，只有在需要的时候才会初始化\n                            ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName); \n                            if (singletonFactory != null) {\n                                singletonObject = singletonFactory.getObject();\n                                this.earlySingletonObjects.put(beanName, singletonObject);// 放入二级缓存中\n                                this.singletonFactories.remove(beanName); // 最后要移除三级缓存\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return singletonObject;\n    }\n    ...\n}\n```\n\n---\n\n### factoryBean的转换\n如果第一步beanName参数是以\"&\"为前缀，则必须要返回FactoryBean，获取的不是FactoryBean类型的话直接报错  \n如果不是\"&\"前缀，并且获取到的实例为FactoryBean的类型的话，则标记`beanDefinition.isFactoryBean=true`，并调用`FactoryBean#getObject`方法返回真正的对象  \n\n---\n\n### 工厂bean调用方法`factoryBean#getObject`流程\n1. 首先判断是不是`isSingleton`，如果不是则直接调用`getObject`方法并调用`BeanPostProcessor#postProcessAfterInitialization`此时bean已创建完成（并不会自动装配）  \n2. 如果是singleton`FactoryBean#isSingleton`,则会放入缓存，每次优先取缓存，有则直接返回  \n3. 没有缓存则调用`getObject`，把当前beanName存放在一个set中，标志正在创建中,然后调用`BeanPostProcessor#postProcessAfterInitialization`此时bean已创建完成（并不会自动装配）,完事放入缓存中，并从set中移除  \n  > 如果在`postProcessAfterInitialization`期间又引用了当前的bean的话，则会重新调用`getObject`返回一个新的对象\n\n---\n\n## 获取不到bean则创建\nspring对非单例的循环引用会直接报错```throw new BeanCurrentlyInCreationException(beanName)```  \n> 非单例的bean创建之前都会把beanName放入```prototypesCurrentlyInCreation```中，创建过程中如果存在一样的bean名称，视为循环引用，直接报错，没有循环引用最后创建完则从中移除\n\n创建bean，必须需要beanDefinition，没有则`throw new NoSuchBeanDefinitionException`  \n   > beanDefinition的注册  \n   > 在[beanFactory初始化时](/posts/springBeanFactory流程解析#4-beandefinitionregistry)，通过调用[ConfigurationClassPostProcessor](/posts/解析spring是如何向beanFactory注册bean的)向beanFactory中注册符合条件的beanDefinition  \n\n---\n\n### 创建bean时的前期流程 \n1. 如果parentBeanFactory不为空，且当前的beanFactory不包含beanDefinition则交由parentBeanFactory处理，[从头开始](#把beanname转换为为标准的beanname)  \n   \n2. 把当前的bean标记为已创建，存放在`alreadyCreated`中，如果`alreadyCreated`不为空，代表beanFactory已开始创建bean  \n   \n3. 把当前的beanDefinition转换成`RootBeanDefinition`，root是spring创建bean时的视图，包含了父类的信息，算是一个标准，没有他可不行  \n  > 获取rootBeanDefinition逻辑时，如果包含内嵌的类，并且内嵌的类非singleton，则外围类的scope同内嵌的类  \n\n4. 确保`dependsOn`的beanName优先[初始化](#把beanname转换为为标准的beanname)  \n  > `@DependsOn`注解或其他配置等\n\n5. 判断bean的作用域  \n  首先判断作用域，非单例的其他作用域则在创建前会把beanName放入```prototypesCurrentlyInCreation```中  \n  如果有循环引用直接报错(通过`prototypesCurrentlyInCreation`判断是否包含bean的名称)，单例的循环引用不报错，最后创建完则从中移除  \n  > 自定义的作用域(非单例，非`prototype`)，都会从`scopes`中取对应的scope实现，比如servlet实现的session、request  \n\n---\n\n### 通过RootBeanDefinition获取真实的class\n如果是FactoryMethod则会通过反射获取方法上返回的类型  \n如果存在tempClassLoader，则用tempClassLoader加载class，不管用什么，都不会初始化class，除非已经初始化过\n\n---\n\n### 通过`InstantiationAwareBeanPostProcessor`提前实例化  \n此类为[`BeanPostProcessor`](/posts/beanPostProcessor的调用流程及各种实现#instantiationawarebeanpostprocessor)的子类  \n可以拦截bean实例化之前（`不包含factoryBean#getObject`），如果返回不为空，则直接调用`BeanPostProcessor`的后置方法并直接返回，此时bean已创建完毕（很少用）  \n\n---\n\n### 创建beanWrapper\n> `beanDefinition`为class定义的各种信息，`beanWrapper`为实例化的包装，包含一个实例的各种信息  \n\n通过`beanDefinition`创建`BeanWrapper`  \n要考虑到factoryBean有可能已经初始化过[在根据beanName获取class的过程中](#通过beanname获取class流程)）,所以优先从缓存<span id='缓存取对应的beanWrapper'/>`factoryBeanInstanceCache`获取factoryBean对应的beanWrapper，没有则会创建  \n\n创建beanWrapper其实就是创建bean的实例，创建流程如下  \n1. 在beanDefinition中如果提供`instanceSupplier`则直接调用并返回  \n   如我们常用的注解`@EnableConfigurationProperties`,instanceSupplier就是由他提供实现`ConfigurationPropertiesValueObjectBeanDefinition`  \n\n2. 在beanDefinition中如果提供`FactoryMethodName`则需要调用此方法获取实例  \n   如常用的注解`@Bean`，该方法如果有参数，则会从从beanDefinition和beanFactory中获取，找不到就报错，最终调用factoryMethod并返回  \n\n3. 在beanDefinition中如果有缓存则直接用缓存实例化-非单例的bean可能会多次实例化  \n   缓存的是构造方法，有其他步骤给给缓存赋值，如果缓存不为空则直接使用，如果有参数，则会从从beanDefinition和beanFactory中获取  \n\n4. 以上步骤都没有实例化则获取所有的构造方法寻找能够实例化的constructor  \n   优先使用有@Autowire注解的构造，如果required=true，参数不满足则直接报错，否则尝试用其他的\n\n> @Lookup注解的原理就是在此实例化bean的时候创建动态代理，具体可参考`CglibSubclassingInstantiationStrategy#instantiateWithMethodInjection`\n\n---\n\n### 单例的bean放入三级缓存中\n如果是单例，则通过[`SmartInstantiationAwareBeanPostProcessor`](/posts/beanPostProcessor的调用流程及各种实现#3-getearlybeanreference)提供早期的引用,并放入三级缓存`singletonFactories`中  \n等bean初始化完之后如果三级缓存中的bean也初始化了，说明当前bean有循环引用，则用三级缓存中的bean  \n\n---\n\n### 自动装配和初始化方法调用-aop和ioc  \n自动装配、初始化方法调用等都是通过beanPostProcessor来实现的  \n执行[beanPostProcessor](/posts/beanPostProcessor的调用流程及各种实现#4-postprocessafterinstantiation)第四步后面的流程  \n至此bean实例化、初始化完毕。如果是单例的bean则会放到`singletonObjects`中，缓存起来\n\n## 总结\nspring在获取bean的时候如果没有就会自动创建，如果是单例的bean就会缓存起来，非单例的每次根据scope作用域创建  \nspring最著名的莫非IOC和AOP了，在创建bean的时候通过[beanPostProcessor](/posts/beanPostProcessor的调用流程及各种实现)完成IOC和AOP等逻辑  ","tags":["源码","spring"],"categories":["java","spring"]},{"title":"解析spring是如何向beanFactory注册bean的","url":"/posts/解析spring是如何向beanfactory注册bean的/","content":"\n# 背景  \n\n<big>**ConfigurationClassPostProcessor**</big>  \n该类是一个BeanFactoryPostProcessor后置处理程序，其主要功能就是扫描beanFactory已注册的bean上的注解进而处理注解对应的职责    \n在[spring的refresh阶段](/posts/springBoot容器启动流程)调用[beanFactoryPostProcessors](/posts/springBeanFactory流程解析#4-调用beanfactorypostprocessors)时该类才开始工作  \n> 在springContext初始化的时候通过```AnnotationConfigUtils#registerAnnotationConfigProcessors```向beanFactory注册该类  \n\n# 工作流程\n\n## 1. 挨个挨个扫描beanFactory中的未扫描的bean\n该类开始工作时，[main方法所在的类已注册到beanFactory中](/posts/springBoot容器启动流程#3-contextprepared--applicationcontextinitializedevent)  \n先开始扫描main方法所在的类，并执行以下步骤2、3、4、5、6、7、8...等全部步骤，执行过程中会有新的bean注册到beanFactory中  \n然后再从beanFactory获取所有beanNames```getBeanDefinitionNames```,过滤未扫描的bean继续扫描，直到扫完为止  \n\n每扫一个bean执行完全部步骤之后都会\n>* 执行在扫描期间扫描到的注解[@Import需延后执行的-DeferredImportSelector](#deferredimportselector)现在立马执行  \n>* 遍历[```configurationClasses```](#3-通过conditionevaluator判断是否满足条件)，过滤已经解析过的，然后执行以下步骤  \n> 1. 通过```ConditionEvaluator```判断是否满足注册条件(<small>在```ConfigurationPhase.REGISTER_BEAN```执行期间</small>)，不满足则return;\n> 1. 如果是内嵌类、或者是`@Import`的类，则会被作为一个`@Configuration`注解的类，注册到beanFactory中(内嵌的类有其他注解则以其他注解优先，参考步骤2的注解)  \n> 1. 注册扫描期间扫描到的@Bean注解的方法，会通过`ConditionEvaluator`判断是否满足条件(<small>在```ConfigurationPhase.REGISTER_BEAN```执行期间</small>)  \n> 1. 执行扫描期间扫描到的[@ImportResource对应的资源](#8-遇到importresource注解时)现在进行资源的解析  \n> 1. 执行在扫描期间扫描到的注解[@Import需延后执行的-ImportBeanDefinitionRegistrar](#importbeandefinitionregistrar)现在立马执行 \n\n## 2. 如果class没有配置注解的话直接跳过\n必须有@Configuration  \n或@Component、@PropertySources、@ComponentScan、@Import、@ImportResource  \n或方法上有@Bean注解的  \n注解上包含以上注解的也可以---称之为复合注解（组合注解）  \n> 遇到class：BeanFactoryPostProcessor、BeanPostProcessor、AopInfrastructureBean、EventListenerFactory直接跳过\n\n## 3. 通过```ConditionEvaluator```判断是否满足条件  \n如果条件不满足(<small>在```ConfigurationPhase.PARSE_CONFIGURATION```期间</small>)则跳过，然后扫描下一个bean，继续从步骤1开始  \n> 如@ConditionOnBean、@ConditionOnClass、@ConditionMiss...等  \n\n条件满足则会判断是不是已经被扫描过，如果没有扫描则接着处理4、5、6。。。之后的全部步骤  \n**<font color='red'>并把当前扫描的类保存到</font>`configurationClasses`<font color='red'>中</font>**  \n\n如果已经被扫描过，则优先处理非导入的，如果都是被导入的，则会合并  \n## 4. 遇到```@Component```注解时优先处理内嵌的类继续循环2、3、4步骤\n内嵌的类作为一个被导入的类\n\n## 5. 遇到```@PropertySources、@PropertySource```注解时处理配置文件并添加到environment中\n\n## 6. 遇到```@ComponentScans、@ComponentScan```注解时扫描对应的basePackages或basePackageClasses\n@ComponentScan扫描的class会注册到beanFactory中并且继续循环2、3、4、5、6的步骤，但必须满足以下几个条件  \n* 扫描指定的包下面所有的class时必须有@Component注解或者@ManagedBean  \n> 该条件通过```ClassPathScanningCandidateComponentProvider#registerDefaultFilters```注册  \n* 通过[```ConditionEvaluator```](#2-通过conditionevaluator判断是否满足条件)判断是否可以注册到beanFactory中\n* 非接口、非abstract、并且为 top-level class or a nested class (static inner class),或者为abstract的类中必须有方法上是```@Lookup```注解的\n* 未往beanFactory注册过的\n\n## 7. 遇到```@Import```注解时进行导入操作\n@Import可以导入任何一个类，作为一个被导入的类，继续循环2、3、4、5、6、7的步骤,但是注意有三种类型比较特殊  \n> 在本步骤处理import时，不想相互import。例如：A import B，如果 B 在 import A就会报错\n\n### ImportSelector  \n  此类型的实现通过调用selectImports获取import的类全名称(可以为多个)，挨个循环继续执行步骤7\n  > 实现此类的有：  \n  > @EnableTransactionManagement-TransactionManagementConfigurationSelector-事务管理器  \n  > @EnableAsync-AsyncConfigurationSelector-开启异步  \n  > @EnableCaching-CachingConfigurationSelector-开启缓存  \n  \n### DeferredImportSelector\n  作用同ImportSelector，但是是延后处理，调用时机在[步骤1](#1-挨个挨个扫描beanfactory中的未扫描的bean)扫描bean执行完全部的步骤之后才会调用  \n  > 实现此类的有：  \n  > @EnableAutoConfiguration-AutoConfigurationImportSelector-开启自动配置  \n  > @ImportAutoConfiguration-ImportAutoConfigurationImportSelector-通过springSpi自定义具体的实现  \n  \n### ImportBeanDefinitionRegistrar\n  也是延后处理，调用时机在[步骤1](#1-挨个挨个扫描beanfactory中的未扫描的bean)扫描bean执行完全部的步骤之后才会调用  \n  不同于[ImportSelector](#importselector)此接口需要使用者自己往beanFactory注册bean，注册之前会有注解相关的信息供使用者使用  \n  > 实现此类的有：  \n  > @EnableAspectJAutoProxy-AspectJAutoProxyRegistrar-aop拦截符合条件的类  \n  > @EnableConfigurationProperties-EnableConfigurationPropertiesRegistrar-配置实体和配置文件的映射（配置文件类）  \n  \n## 8. 遇到```@ImportResource```注解时\n  @ImportResource用来导入一个资源文件如早期的spring-application.xml的配置文件  \n  但是资源并不会立马解析，也是延后处理，调用时机也是在[步骤1](#1-挨个挨个扫描beanfactory中的未扫描的bean)扫描bean执行完全部的步骤之后才会解析此资源\n\n## 9. 收集当前扫描的class中有@Bean注解的方法(包含接口上有此注解的方法)\n\n\n## 10. 继续扫描当前class的父类，直到为Object为止\n继续从步骤2开始\n  \n\n# 代码流程\n\n## 步骤1的代码  \n```java\npublic class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {\n  ...\n  public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    ...\n    ConfigurationClassParser parser = new ConfigurationClassParser(\n            this.metadataReaderFactory, this.problemReporter, this.environment,\n            this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n    do {\n      parser.parse(candidates);//执行2、3、4、5、6 。。。全部步骤\n      parser.validate();// 对于@Configuration的，类验证是否可以重写内部的方法\n\n      Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n      configClasses.removeAll(alreadyParsed);// 过滤已经处理过的\n\n      // Read the model and create bean definitions based on its content\n      if (this.reader == null) {\n        this.reader = new ConfigurationClassBeanDefinitionReader(\n                registry, this.sourceExtractor, this.resourceLoader, this.environment,\n                this.importBeanNameGenerator, parser.getImportRegistry());\n      }\n      // 步骤1当中的每一个bean，parse完之后都会做的步骤\n      this.reader.loadBeanDefinitions(configClasses);\n      alreadyParsed.addAll(configClasses); // 添加到已处理过的\n\n      candidates.clear();\n      // 过滤未扫描的bean继续扫描，这一块spring开发人员写的不怎么样，阅读起来有点费劲\n      if (registry.getBeanDefinitionCount() > candidateNames.length) {\n        String[] newCandidateNames = registry.getBeanDefinitionNames();\n        Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n        Set<String> alreadyParsedClasses = new HashSet<>();\n        for (ConfigurationClass configurationClass : alreadyParsed) {\n          alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n        }\n        for (String candidateName : newCandidateNames) {\n          if (!oldCandidateNames.contains(candidateName)) {\n            BeanDefinition bd = registry.getBeanDefinition(candidateName);\n            // 如果class没有步骤2中注解的话直接跳过\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n                    !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n              candidates.add(new BeanDefinitionHolder(bd, candidateName));\n            }\n          }\n        }\n        candidateNames = newCandidateNames;\n      }\n    }\n    while (!candidates.isEmpty());\n    ...\n  }\n  ...\n}\n```\n\n## 步骤2的代码\n```java\nabstract class ConfigurationClassUtils {\n  public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {\n    ...\n    AnnotationMetadata metadata = // 通过beanDef和metadataReaderFactory获取到metadata;\n    ...\n    // 如果是以下几种的class则至直接跳过，不解析\n    // BeanFactoryPostProcessor、BeanPostProcessor、AopInfrastructureBean、EventListenerFactory\n\n    // 有@Configuration注解  \n    Map<String, Object> config = metadata.getAnnotationAttributes(Configuration.class.getName());\n    if (config != null && !Boolean.FALSE.equals(config.get(\"proxyBeanMethods\"))) {\n      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);\n    }\n    // isConfigurationCandidate: \n    // 包含@Component、@PropertySources、@ComponentScan、@Import、@ImportResource\n    // 或方法上有@Bean注解的\n    else if (config != null || isConfigurationCandidate(metadata)) {\n      beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);\n    }\n    else {\n      return false;\n    }\n    ...\n    return true;\n  }\n  \n  public static boolean isConfigurationCandidate(AnnotationMetadata metadata) {\n    if (metadata.isInterface()) {\n      return false;\n    }\n\n    Set<String> candidateIndicators = new HashSet<>(8);\n    candidateIndicators.add(Component.class.getName());\n    candidateIndicators.add(ComponentScan.class.getName());\n    candidateIndicators.add(Import.class.getName());\n    \n    for (String indicator : candidateIndicators) {\n      if (metadata.isAnnotated(indicator)) {\n        return true;\n      }\n    }\n\n    try {\n      return metadata.hasAnnotatedMethods(Bean.class.getName());\n    }\n    catch (Throwable ex) {\n      ...  \n      return false;\n    }\n  }\n}\n```\n\n## 步骤3的代码\n\n```java\nclass ConfigurationClassParser {\n  ...\n  // 当前类初始化的时候\n  this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader);\n  \n  protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {\n    // 在PARSE_CONFIGURATION期间判断是否满足条件\n    if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {\n      return;\n    }\n\n    // 如果已经处理过，则优先处理非导入的类，如果都是导入的。则合并导入的类\n    ConfigurationClass existingClass = this.configurationClasses.get(configClass);\n    if (existingClass != null) {\n      if (configClass.isImported()) {\n        if (existingClass.isImported()) {\n          existingClass.mergeImportedBy(configClass);\n        }\n        // Otherwise ignore new imported config class; existing non-imported class overrides it.\n        return;\n      }\n      else {\n        // Explicit bean definition found, probably replacing an import.\n        // Let's remove the old one and go with the new one.\n        this.configurationClasses.remove(configClass);\n        this.knownSuperclasses.values().removeIf(configClass::equals);\n      }\n    }\n\n    // Recursively process the configuration class and its superclass hierarchy.\n    SourceClass sourceClass = asSourceClass(configClass, filter);\n    do {\n      // 执行4、5、6、7、8....等全部步骤\n      sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);\n    }\n    while (sourceClass != null);\n\n    this.configurationClasses.put(configClass, configClass);\n  }\n  ...\n}\n```\n\n## 步骤4之后的代码\n```java\nclass ConfigurationClassParser {\n  ...\n  protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter) {\n\n    // 处理内嵌的类\n    if (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n      processMemberClasses(configClass, sourceClass, filter);\n    }\n\n    // 步骤5的代码\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), \n            PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n      if (this.environment instanceof ConfigurableEnvironment) {\n        processPropertySource(propertySource);\n      }\n      ...\n    }\n\n    // 步骤6的代码\n    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n      for (AnnotationAttributes componentScan : componentScans) {\n        // The config class is annotated with @ComponentScan -> perform the scan immediately\n        Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n        // Check the set of scanned definitions for any further config classes and parse recursively if needed\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n          BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n          if (bdCand == null) {\n            bdCand = holder.getBeanDefinition();\n          }\n          if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n            parse(bdCand.getBeanClassName(), holder.getBeanName());\n          }\n        }\n      }\n    }\n\n    // 步骤7的代码\n    processImports(configClass, sourceClass, getImports(sourceClass), filter, true);\n\n    // 步骤8的代码\n    AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n    if (importResource != null) {\n      String[] resources = importResource.getStringArray(\"locations\");\n      Class<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n      for (String resource : resources) {\n        String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n        configClass.addImportedResource(resolvedResource, readerClass);\n      }\n    }\n\n    // 步骤9的代码\n    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n\n    // 步骤10的代码\n    if (sourceClass.getMetadata().hasSuperClass()) {\n      String superclass = sourceClass.getMetadata().getSuperClassName();\n      if (superclass != null && !superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n        this.knownSuperclasses.put(superclass, configClass);\n        // Superclass found, return its annotation metadata and recurse\n        return sourceClass.getSuperClass();\n      }\n    }\n\n    // No superclass -> processing is complete\n    return null;\n  }\n  ...\n}\n```\n> 有兴趣的可以用IDE阅读源码一番，会有不一样的收获\n\n# 总结\nConfigurationClassPostProcessor的作用就是扫描类上的注解，继而处理注解对应的功能  \n@Component、@PropertySources、@ComponentScan、@Import、@ImportResource、方法上@Bean的注解都有不同的职责，都是由此类进行处理  \n从[spring启动过程中的refresh](/posts/springBoot容器启动流程#4-contextloaded--applicationpreparedevent)阶段对beanFactory的操作，到[调用beanFactory的后置处理器](/posts/springBeanFactory流程解析#4-调用beanfactorypostprocessors)<small>本文的实现</small>，大体对spring的整体流程有了个全新的概貌  \n此时、beanFactory也初始化、bean的定义也都注册了，接下来我们会[分析bean的实例化流程](/posts/spring对bean实例化-初始化-流程)","tags":["源码","spring"],"categories":["java","spring"]},{"title":"JVM所有的参数配置详解","url":"/posts/jvm所有的参数配置详解/","content":"# 启动时输出jvm所有的配置\n1. -XX:+PrintFlagsFinal\n\n# 启动时输出非默认的jvm参数(人为配置的)\n1. -XX:+PrintCommandLineFlags\n\n# [循环放置安全点](/posts/java安全点safePoint以及JIT#安全点都有哪些呢)  \n1. -XX:+UseCountedLoopSafepoints\n\n# 设置默认的hashcode  \n\n* -XX:hashCode=0  \n  此类方案返回一个Park-Miller伪随机数生成器生成的随机数\n  \n* -XX:hashCode=1  \n  此类方案将对象的内存地址，做移位运算后与一个随机数进行异或得到结果\n\n* -XX:hashCode=2   \n  永远返回固定值1\n    \n* -XX:hashCode=3  \n  此类方案返回一个自增序列的当前值  \n  \n* -XX:hashCode=4  \n  此类方案返回当前对象的内存地址  \n\n# 内存\n## 1. -Xms1024m  \n   最小堆内存大小(memory start)\n\n## 2. -Mmx2048m  \n   最大堆内存大小(memory max)\n   \n## 3. -XX:+UseCompressedOops  \n   开启普通对象的指针压缩，此参数也会默认开启UseCompressedClassPointers  \n   一个对象的指针默认为8字节(64bit)，压缩后变为4字节(32bit)，最大可表示4G(2^32)，经JVM处理之后最大可访问地址为32G(堆内存大于32G时会自动失效)  \n   为什么压缩后用4字节就可以最大访问32G呢，因为根据jvm对象对齐空间来算(ObjectAlignmentInBytes默认是8)，也就是按照最小对象8字节来算有8个空挡(间隔)，所以2^32*8bit=32G  \n   开启之后会在机器码中植入压缩与解压指令，会给JVM增加额外的开销  \n   在jdk6以后不是clientVM且是64位的jvm中默认为开启状态  \n   \n## 4. -XX:+UseCompressedClassPointers  \n   开启在对象头中[类指针的压缩](/posts/java内存模型和GC以及锁#1-对象头)  \n   如果UseCompressedOops是关闭的状态，则会报错  \n   \n## 5. -XX:ObjectAlignmentInBytes=8  \n   对象对齐空间大小(bit)默认为8\n\n# 锁\n\n## -XX:-UseBiasedLocking  \n  关闭[偏向锁](/posts/java内存模型和GC以及锁#偏向锁)、jdk1.6之后默认为开启偏向锁。偏向锁竞争时会STW，如果竞争过于激烈，会导致性能下降  \n   \n## -XX:BiasedLockingStartupDelay=4000  \n  jvm启用偏向锁延迟时间，偏向锁的信息都是在markword(对象头)里面，刚出生的对象markword信息都是由对应的Klass中的prototype_header(包含锁标识、epoch)决定的  \n  默认启动4秒之后会把所有的klass的prototype_header中的数据标识为匿名偏向锁，只有匿名偏向锁才可以使用偏向锁  \n  > 延时机制是为了解决：JVM启动时必不可免会有大量sync的操作，而偏向锁竞争时会STW并升级为轻量级锁。如果开启了偏向锁，竞争会发生大量锁撤销和锁升级操作，大大降低JVM启动效率  \n   \n## -XX:BiasedLockingBulkRebiasThreshold=20  \n  偏向锁批量重偏向阈值，因为默认只能锁升级，升级轻量级锁需要等待[全局安全点](/posts/java安全点safePoint以及JIT#safepoint)，会耗费性能  \n  如果某个class的对象的偏向锁升级轻量级锁次数达到第20次时，则会标识第20个(包含)之后的对象全部可以偏向新的线程，避免升级为轻量级锁  \n  > 批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁升级为轻量级锁  \n  > 重偏原理是修改klass的prototype_header中的epoch,做+1操作，这样偏向锁上锁时检测epoch为失效状态，就会重新使用CAS上锁  \n  \n## -XX:BiasedLockingBulkRevokeThreshold=40  \n  偏向锁批量撤销阈值，撤销之后直接从轻量级锁开始。同上，如果锁升级过多，在25秒(如下参数设置)内，超过40次，则直接撤销当前class对应所有对象的偏向锁，后续一律从轻量级锁开始  \n  撤销的原理是：刚出生的对象markword信息都是由对应的Klass的决定的，修改Klass中的prototype_header弃用偏向锁即可  \n  > 批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的  \n   \n## -XX:BiasedLockingDecayTime=25000(默认)  \n  同上，一定时间内的阈值  ","tags":["jvm"],"categories":["java","jvm"]},{"title":"打印日志引起的oom的解决方案","url":"/posts/打印日志引起的oom的解决方案/","content":"\n# 场景\n电商促销的逻辑，由于算价过程涉及的逻辑较多，所以有关算价的过程及结果数据都会打印下来，一旦有问题较容易排查  \n**满减赠折**是促销模块比较复杂的逻辑，这次出现问题的原因是因为建了一个*满减赠折*的活动，满1元送一个赠品以及100个积分，几十万元送几十w个赠品，导致在打印日志的时候出现了问题  \n\n# 问题分析\n好在运维人员配置了自动dumpMemory  \n>  **[-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/applicationNameHeapdump.hprof](/posts/JVM所有的参数配置详解)**   \n>  在JVM内存溢出的时候自动dump内存快照,HeapDumpPath指定dump的路径，不指定的话默认输出路径为项目的根路径  \n>  经本地main方法测验，只要dump过一次，之后多次出现的oom不会dump第二次(删除dump的文件也不行)\n\n用jProfiler分析之后发现果然是日志打印过多，就是因为送赠品送了几十w个，会产生几十w个对象，显然这是不正确的，实际应该用数值表示有多少个即可。所以几十w个对象再用日志输出的时候显然就成为了一个系统瓶颈  \n毕竟在写完磁盘之前，这些对象一直贮存在内存中，导致内存偏小，机器的tps明显下降、甚至多次出现oom\n\n# 解决方案\n可参考[优雅打印日志](/posts/java如何优雅的打印log#限制序列化的长度)  \n或者修改代码逻辑，用数值代表几十万的赠品，不应该用几十万个对象","tags":["log","线上问题"],"categories":["java","log"]},{"title":"spring对Bean的排序","url":"/posts/spring对bean的排序/","content":"\n# 大体流程\n不同的bean实现的接口不同、它的作用也不不同、那么他的加载顺序也不同  \n具体可参考[beanFactory对不同类型的bean加载的顺序](/posts/springBeanFactory流程解析#4-调用beanfactorypostprocessors)  \n\n如果bean的类型相同、实现的接口也相同则根据\n1. 实现```org.springframework.core.PriorityOrdered```接口\n1. 实现```org.springframework.core.Ordered```接口\n1. 注解```@Order```\n1. 注解```@Priority```  \n\n以上优先级从高到低  \n接口优先级比注解的高  \n如果都是接口PriorityOrdered优先级更高  \n如果都是注解@Order优先级更高  \n**数值越小的优先级就越高**\n# 代码流程\n\n具体可参考```org.springframework.core.OrderComparator```\n> 默认的排序（不支持注解）\n\n具体可参考```org.springframework.core.annotation.AnnotationAwareOrderComparator```\n> 支持注解的排序\n\n具体可参考```org.springframework.core.annotation.OrderUtils```\n> 获取注解\n\nspring 中对bean的排序用的是```org.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE```\n## spring初始化context时会把排序的类注册到beanFactory中\n```java\nif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n    beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n}\n```","tags":["源码","spring"],"categories":["java","spring"]},{"title":"springBeanFactory流程解析","url":"/posts/springbeanfactory流程解析/","content":"# [spring启动流程](/posts/springBoot容器启动流程)中的refresh阶段\nbeanFactory在refresh阶段完成配置、扫描bean、注册bean等重要操作步骤  \n* refresh代码流程  \n```java\npublic abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext {\n    ...\n    public void refresh() throws BeansException, IllegalStateException {\n        synchronized (this.startupShutdownMonitor) {\n            ...\n            // 获取beanFactory,默认为new DefaultListableBeanFactory()\n            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n            prepareBeanFactory(beanFactory);// 配置beanFactory\n\n            try {\n                postProcessBeanFactory(beanFactory);// 交给context去配置beanFactory\n\n                invokeBeanFactoryPostProcessors(beanFactory);// 调用BeanFactoryPostProcessors\n\n                registerBeanPostProcessors(beanFactory);// 注册拦截bean创建的bean处理器\n\n                initMessageSource();\n\n                initApplicationEventMulticaster();// 初始化事件广播器，待会扫描以注解形式存在的listener\n\n                onRefresh(); // context容器进行onRefresh，servletContext会在这个时候创建tomcat\n\n                registerListeners();// 注册以注解形式存在的listener，并且广播之前已广播的事件\n\n                finishBeanFactoryInitialization(beanFactory); // 加载LoadTimeWeaverAware(增强AOP，通过修改字节码实现AOP，class已加载过的话则不起作用)，冻结配置，初始化所有的bean(单例、notLazy)\n\n                /* 最后一步: 发布相对应的事件\n                    1:获取所有Lifecycle类型的bean，如果是SmartLifecycle的类型并且isAutoStartup为true，则调用start方法\n                    2:发布contextRefreshedEvent\n                    3:把bean的信息注册到ManagementFactory（java监控工厂）\n                 */\n                finishRefresh();\n            } catch (BeansException ex) {\n                ...\n                // Destroy already created singletons to avoid dangling resources.\n                destroyBeans();\n\n                // Reset 'active' flag.\n                cancelRefresh(ex);\n\n                // Propagate exception to caller.\n                throw ex;\n            } finally {\n                // Reset common introspection caches in Spring's core, since we\n                // might not ever need metadata for singleton beans anymore...\n                resetCommonCaches();\n            }\n        }\n    }\n    ...\n}\n```\n\n我们具体分析下refresh当中的重要操作步骤，分析之前，我们先了解beanFactory的作用以及实现都有哪些\n\n---\n\n# beanFactory作用\n实现的类结构，如图![spring-beanFactory](/img/posts/2021/spring-beanFactory.png)\n\n## 1. BeanFactory\n> 主要作用是通过名字或类型get对应的bean实例\n\ngetBean|isTypeMatch|\ngetBeanProvider|getType|getAliases等方法\n   \n## 2. SingletonBeanRegistry\n> 主要作用是注册单例的bean  \n\nregisterSingleton|getSingleton|getSingletonNames等方法\n   \n## 3. HierarchicalBeanFactory\n> 可分层的beanFactory主要作用是可以多个beanFactory并且有父子关系\n\ngetParentBeanFactory|containsLocalBean 只有两个方法\n   \n## 4. **BeanDefinitionRegistry**\n\nregisterBeanDefinition|removeBeanDefinition|\ngetBeanDefinition|getBeanDefinitionNames等方法  \n\n* registerBeanDefinition  \n  BeanDefinition是包含了bean的所有信息，bean的名称、bean的class、scope、isLazy、isPrimary、bean的属性和bean的依赖关系等  \n  beanFactory获取一个bean时，除非bean已经存在，否则会通过beanDefinition自动创建，没有beanDefinition就会报错，所以beanDefinition是一个很重要的存在  \n  BeanDefinition包含了class的各种信息如注解的信息、class的资源路径等，但是不会初始化class，主要通过ASM字节码读取器来解析class字节码的内容  \n> ASM解析class字节码默认实现类`SimpleMetadataReaderFactory`，由`SharedMetadataReaderFactoryContextInitializer`在spring启动阶段中的`context#initialize`注册  \n> beanFactory通过调用[BeanFactoryPostProcessor](#4-调用beanfactorypostprocessors)主要的实现[ConfigurationClassPostProcessor](/posts/解析spring是如何向beanFactory注册bean的)先扫描所有的class，通过AMS既可以读取class内容也不会加载class，然后符合条件的bean会包装成BeanDefinition注册到beanFactory中\n   \n## 5. AliasRegistry\n> 为注册bean的别名，通过别名也可以获取到bean，主要作用就是注册bean的别名  \n\nregisterAlias|removeAlias|  \ngetAliases|isAlias 只有这四个方法\n   \n## 6. ListableBeanFactory\n> 可列举的beanFactory，通过条件获取beans，主要作用通过类型或注解或其他条件获取对应的bean  \n\ngetBeansOfType|getBeanNamesForType|findAnnotationOnBean 等方法\n   \n## 7. **AutoWireCapableBeanFactory**\n> 可自动装配的factory，在[获取Bean](#1-beanfactory)的时候，如果bean还没有创建则会[创建](/posts/spring对bean实例化-初始化-流程#创建流程)  \n> 默认实现```AbstractAutowireCapableBeanFactory#createBean```ioc、aop等逻辑都嵌套在内  \n\nresolveDependency|resolveBeanByName|\napplyBeanPostProcessorsBeforeInitialization|applyBeanPostProcessorsBeforeInitialization等其他方法  \n\n* resolveDependency    \n  在自动装配的时候会通过此方法获取可被装配的值\n\n## 8. ConfigurableListableBeanFactory和ConfigurableBeanFactory  \n> 生产bean时、装配时、类型转化时、销毁bean、冻结等配置各种各样的组件供方便使用\n\nregisterResolvableDependency|ignoreDependencyInterface|\nregisterScope|addBeanPostProcessor|  \nfreezeConfiguration|isConfigurationFrozen|  \npreInstantiateSingletons|destroySingletons|\nsetTypeConverter|setConversionService等其他方法  \n\n* registerResolvableDependency    \n  注册一个bean，其他依赖此类型的，可以直接用，autowiredValue不会放到bean工厂中，只会为其他类提供依赖\n  \n* ignoreDependencyInterface    \n  自动装配时忽略某个类型，通常配合beanFactory的addBeanPostProcessor一起使用。当bean初始化完后，[BeanPostProcessor](#5-注册拦截bean创建的bean处理器-beanpostprocessor)专门set忽略的字段    \n  如常用的如ServletContextAwareProcessor、EnvironmentAware、ApplicationContextAware等\n  \n* registerScope    \n  除单例和prototype之外有request、session等bean的生命周期定义都是由这个方法完成注册。通过Scope接口中的get方法获取bean\n\n## 9. DefaultListableBeanFactory为以上全部接口的默认实现\n\n---\n\n# beanFactory大体工作流程\n\n## 1 获取beanFactory  \n   context初始化时就自动创建好了  \n   默认实现```org.springframework.beans.factory.support.DefaultListableBeanFactory```  \n   ```this.beanFactory = new DefaultListableBeanFactory()```\n   \n## 2. 准备beanFactory  \n   beanFactory是刚new出来，没有经过配置，prepareBeanFactory方法对beanFactory进行一些简单的配置  \n   如注册[ApplicationContextAwareProcessor](#5-注册拦截bean创建的bean处理器-beanpostprocessor)，调用[registerResolvableDependency](#8-configurablelistablebeanfactory和configurablebeanfactory)注册BeanFactory、ApplicationContext等\n\n## 3. 交给context实现类去配置beanFactory  \n   例如：如果是servletBeanApplicationContext会对beanFactory增加额外的[Scope：registerScope](#8-configurablelistablebeanfactory和configurablebeanfactory)，比如RequestScope、SessionScope等\n\n## 4. 调用BeanFactoryPostProcessors\n> 针对beanFactory注册一些的bean、移除一些bean，等其他操作  \n总之beanFactory不关心具体的实现，只调用后置处理器并把beanFactory作为参数传递过去即可\n\n调用beanFactory的后置处理(beanFactory已经创建了)    \nBeanFactoryPostProcessor：针对[ConfigurableListableBeanFactory](#8-configurablelistablebeanfactory和configurablebeanfactory)初始化后的后置处理  \nBeanDefinitionRegistryPostProcessor：针对[BeanDefinitionRegistry](#4-beandefinitionregistry)初始化后的后置处理  \n<font color='red'>BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子类，会优先调用子类</font>\n\n* 那BeanFactoryPostProcessor具体的实现都有哪些、以及调用顺序是什么呢\n  * 具体的实现\n    1. context有一个beanFactoryPostProcessors成员，在context初始化的时候可以往里面添加  \n      <small>默认有LazyInitializationBeanFactoryPostProcessor:如果条件满足，则设置全部的bean为懒加载、PropertySourceOrderingPostProcessor:把defaultProperties配置文件的优先级降到最低，等</small>\n    2. context持有beanFactory，在context初始化的时候会往beanFactory注册[BeanDefinition](#4-beandefinitionregistry)  \n      <small>默认注册的有[ConfigurationClassPostProcessor，会扫描所有、注册符合条件的bean](/posts/解析spring是如何向beanFactory注册bean的)等其他  \n      具体可参考```AnnotationConfigUtils#registerAnnotationConfigProcessors```</small>\n  * 调用的顺序\n    1. context里面的beanFactoryPostProcessors成员，如果是```BeanDefinitionRegistryPostProcessor```类型，则优先调用，优先级是最高的\n    2. 然后从beanFactory获取```BeanDefinitionRegistryPostProcessor```类型，优先调用实现了```PriorityOrdered```的接口\n    3. 然后从beanFactory获取```BeanDefinitionRegistryPostProcessor```类型，调用实现了```Ordered```的接口\n    4. 然后从beanFactory获取```BeanDefinitionRegistryPostProcessor```类型，经过[排序](/posts/spring对Bean的排序)之后、在调用没有调用过的。直到调用完beanFactory里面所有BeanDefinitionRegistryPostProcessor类型的bean为止\n    5. 因为BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子类，所以等调用完所有1,2,3,4步骤对应的BeanDefinitionRegistryPostProcessor之后接着调用1、2、3、4步骤中的BeanFactoryPostProcessor\n    6. 调用context里面的beanFactoryPostProcessors成员且只是```BeanFactoryPostProcessor```的类型\n    7. 然后从beanFactory获取```BeanFactoryPostProcessor```类型的所有BeanName，优先调用实现了```PriorityOrdered```的接口，在调用实现了```Ordered```的接口，最后未调用过的经[排序](/posts/spring对Bean的排序)之后在调用\n  \n## 5. 注册拦截bean创建的bean处理器-BeanPostProcessor\n[它的作用就是在bean实例化前、后，初始化前、后进行拦截操作](/posts/beanPostProcessor的调用流程及各种实现)\n\n* BeanPostProcessor注册顺序是什么呢？\n  1. 从beanFactory获取```BeanPostProcessor```类型的所有beanNames  \n  2. 遍历所有的beanNames，优先注册实现了```PriorityOrdered```的接口、然后在注册实现了```Ordered```的接口，最后未注册过的经[排序](/posts/spring对Bean的排序)之后在注册  \n  3. 等所有的BeanPostProcessor注册完之后，如果是MergedBeanDefinitionPostProcessor类型的话注册顺序都会移到最后面哦  \n\n## 6. 初始化国际化资源\n\n## 7. 初始化事件广播器\n不同于spring启动的listener，这个事件广播器用户是可以用来广播自定义事件并自定义监听的  \n默认广播器的实现```SimpleApplicationEventMulticaster```  \n> 使用时注入```ApplicationEventPublisher```bean，调用publishEvent方法,监听者需实现```ApplicationListener```接口即可使用\n\n## 8. onRefresh初始化webServer\n如果是servletContext，则会在此阶段初始化内嵌的tomcat,[并扫描所有的servlet、filter、其他servlet注册器等并关联到servletContext中](/posts/springMvc执行流程#代码流程)\n\n## 9. 获取并广播以注解形式存在的ApplicationListener\n在[spring启动流程中](/posts/springBoot容器启动流程)通过spring-spi方式获取bean来事件广播，如果某些bean非spi配置的方式，而是以注解形式配置的，则广播不了  \n所以在此阶段通过beanFactory获取以注解形式存在的listener，并把之前已广播的事件再次广播（伪事件，因为已经过了那个阶段了）\n\n## 10. [实例化所有bean](/posts/spring对bean实例化-初始化-流程)\n实例化之前，优先实例化LoadTimeWeaverAware类型的bean(增强AOP，通过修改字节码实现AOP，class已加载过的话则不起作用，但是在这个阶段class基本上都已经被加载过)  \n* 实例化notLazyBean、singletonBean、如果为factoryBean，必须实现```SmartFactoryBean```接口且方法```isEagerInit```返回true才可以实例化  \n> notLazy And singletons 的bean是从哪里来的呢？  \n都是通过[BeanDefinitionRegistry](#4-beandefinitionregistry)注册的bean\n\n* 实例化完之后如果是单例的bean并且实现了```SmartInitializingSingleton```接口，则会按照bean的注册顺序依次调用```afterSingletonsInstantiated```\n\n\n## 11 收尾工作-发布相对应的事件\n1. 获取所有Lifecycle类型的bean，如果是SmartLifecycle的类型并且isAutoStartup为true，则调用start方法  \n2. 发布contextRefreshedEvent  \n3. 把bean的信息注册到ManagementFactory（java监控工厂）\n\n\n<big>**至此beanFactory流程解析完成**</big>后续继续[分析bean实例化,ioc,aop](/posts/spring对bean实例化-初始化-流程)","tags":["源码","spring"],"categories":["java","spring"]},{"title":"springMvc执行流程","url":"/posts/springmvc执行流程/","content":"\nspring的MVC是遵循着servlet规范的。\n# servlet规范\n当Http服务器接收请求后，Http服务器不直接调用业务类，而是把请求交给Servlet容器去处理，Servlet容器会将请求转发到具体的Servlet   \nServlet是个接口，如果想要让业务类具备处理请求的能力则需要实现此并接口，并配置到web.xml当中即可。  \n调用servlet时如果还没创建，就加载并实例化这个Servlet，然后调用这个Servlet的service方法  \n```java\npublic interface Servlet {\n    // Servlet容器在加载Servlet类的时候会调用init方法\n    void init(ServletConfig config) throws ServletException;\n    \n    // ServletConfig就是封装Servlet的初始化参数。可以在web.xml给Servlet配置参数\n    ServletConfig getServletConfig();\n\n    // 处理请求\n    void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;\n    \n    String getServletInfo();\n    \n    // Servlet容器在卸载Servlet类的时候会调用destory方法\n    void destroy();\n}\n```\n\n# springBoot的DispatcherServlet关联到servlet容器中\n我们知道springMVC的入口类dispatcherServlet，其实他也是servlet的实现类。那么他是如何和servlet容器关联上的呢，为什么所有的请求都由它管控呢？  \n\n## 大体流程\n1. 在springBoot容器启动流程中的[ContextRefresh阶段](/posts/springBoot容器启动流程)，context如果是ServletContext则会执行ServletContext的onStartup逻辑进行bind\n1. bind逻辑通过ServletContextInitializerBeans和beanFactory获取以下实现类  \nServletContextInitializer、Filter、Servlet、ServletContextAttributeListener、ServletRequestListener、ServletRequestAttributeListener、HttpSessionAttributeListener、HttpSessionListener、ServletContextListener\n1. 不是ServletContextInitializer的话，全部包装成ServletContextInitializer\n1. 排序所有的ServletContextInitializer，进行迭代依次调用onStartup\n1. onStartup时会把对应的urlMapping和servlet、filter、listener绑定到servletContext中\n\n## 代码流程\n```java\n// servletContext会创建WebServer,该context为spring的容器上下文\npublic class ServletWebServerApplicationContext extends GenericWebApplicationContext implements ConfigurableWebServerApplicationContext {\n...\n    // onRefresh是在refresh阶段调用的\n    protected void onRefresh() {\n        super.onRefresh();\n        ...\n        createWebServer();\n        ...\n    }\n    // 创建webServer\n    private void createWebServer() {\n        \n        // 为了阅读方便，我把代码直接写在这里。最终处理注册的实现类\n        ServletContextInitializer initializer = new ServletContextInitializer() {\n            public void onStartup(ServletContext servletContext) {\n                // 1 绑定当前context到servletContext中\n                // 2 新增scope为application，和servlertContext关联上\n                // 3 把servletContextParam绑定到Environment\n                ...\n                for (ServletContextInitializer beans : new ServletContextInitializerBeans(getBeanFactory())) {\n                    beans.onStartup(servletContext);\n                }\n            }\n        }; \n        \n        // 创建内嵌的webServer后在调用onStartup\n        if (this.webServer == null && getServletContext() == null) {\n            this.webServer = getWebServerFactory().getWebServer(initializer);\n            ...\n        }\n        else if (servletContext != null) {\n            ...\n            // 非内嵌的WebServer，直接调用onStartup\n            initializer.onStartup(servletContext);\n            ...\n        }\n    }\n}\n```\nonStartup方法通过ServletContextInitializerBeans最终获取了一批ServletContextInitializer类型的处理类，然后调用各自的onStartup完成的注册。\n> ServletContextInitializer是个接口，只提供onStartup方法。具体实现有filter注册、servlet注册、Listener注册器等。  \n> 不同的实现会调用不同的方法，如filter只会调用servletContext.addFilter();\n\nServletContextInitializer是根据ServletContextInitializerBeans以及BeanFactory获取到的。继续分析获取的流程  \n```java\npublic class ServletContextInitializerBeans extends AbstractCollection<ServletContextInitializer> {\n    private final Set<Object> seen = new HashSet<>(); // 以及添加过的bean，不允许再次添加\n    \n    // 所有的需要注册的bean,key为类型。\n    private final MultiValueMap<Class<?>, ServletContextInitializer> initializers = new LinkedMultiValueMap<>();\n    // 排序过后的所有要注册的bean\n    private List<ServletContextInitializer> sortedList;\n    \n    // 最终迭代的对象为sortedList，sortedList是通过initializers的values排序之后的结果\n    @Override\n    public Iterator<ServletContextInitializer> iterator() {\n        return this.sortedList.iterator();\n    }\n\n    @Override\n    public int size() {\n        return this.sortedList.size();\n    }\n\n    public ServletContextInitializerBeans(ListableBeanFactory beanFactory) {\n        ...\n        // 通过beanFactory获取ServletContextInitializer实例\n        for (Entry<String, ? extends ServletContextInitializer> initializerBean : getOrderedBeansOfType(beanFactory, ServletContextInitializer.class)) {\n            // 添加到成员initializers中\n            addServletContextInitializerBean(initializerBean.getKey(), initializerBean.getValue(), beanFactory);\n        }\n        /* 通过beanFactory直接获取以下实例\n         Servlet、Filter、\n         ServletContextAttributeListener、ServletRequestListener、ServletRequestAttributeListener、\n         HttpSessionAttributeListener、HttpSessionListener、ServletContextListener\n         */\n        addAdaptableBeans(beanFactory);\n        // 最终排序\n        this.sortedList = this.initializers.values().stream()\n                .flatMap((value) -> value.stream().sorted(AnnotationAwareOrderComparator.INSTANCE))\n                .collect(Collectors.toList());\n    }\n    \n    // 通过beanFactory获取ServletContextInitializer实例\n    private void addServletContextInitializerBean(String beanName, ServletContextInitializer initializer, ListableBeanFactory beanFactory) {\n        // 简化代码阅读\n        ...\n        Class<?> type;\n        Object source;\n        if (initializer instanceof ServletRegistrationBean) {\n            source = ((ServletRegistrationBean<?>) initializer).getServlet();\n            type = Servlet.class;\n        }\n        else if (initializer instanceof FilterRegistrationBean) {\n            source = ((FilterRegistrationBean<?>) initializer).getFilter();\n            type = Filter.class;\n        }\n        else if (initializer instanceof DelegatingFilterProxyRegistrationBean) {\n            source = ((DelegatingFilterProxyRegistrationBean) initializer).getTargetBeanName();\n            type = Filter.class;\n        }\n        else if (initializer instanceof ServletListenerRegistrationBean) {\n            source = ((ServletListenerRegistrationBean<?>) initializer).getListener();\n            type = EventListener.class;\n        }\n        else {\n            source = initializer;\n            type = ServletContextInitializer.class;\n        }\n        this.initializers.add(type, initializer);\n        if (source != null) {\n            // 防止重复添加，不同的包装获取source的方式不同\n            // Mark the underlying source as seen in case it wraps an existing bean\n            this.seen.add(source);\n        }\n    }\n\n    /* 通过beanFactory直接获取以下实例\n         Servlet、Filter、\n         ServletContextAttributeListener、ServletRequestListener、ServletRequestAttributeListener、\n         HttpSessionAttributeListener、HttpSessionListener、ServletContextListener\n     */\n    protected void addAdaptableBeans(ListableBeanFactory beanFactory) {\n        addAsRegistrationBean(beanFactory, Servlet.class, Servlet.class, new ServletRegistrationBeanAdapter(getMultipartConfig(beanFactory)));//Adapter = addServlet\n        addAsRegistrationBean(beanFactory, Filter.class, Filter.class, new FilterRegistrationBeanAdapter());// Adapter = addFilter\n        // supportedTypes = ServletContextAttributeListener、ServletRequestListener、ServletRequestAttributeListener、HttpSessionAttributeListener、HttpSessionListener、ServletContextListener\n        for (Class<?> listenerType : ServletListenerRegistrationBean.getSupportedTypes()) {\n            addAsRegistrationBean(beanFactory, EventListener.class, (Class<EventListener>) listenerType, new ServletListenerRegistrationBeanAdapter());// Adapter = addListener\n        }\n    }\n\n    private <T, B extends T> void addAsRegistrationBean(ListableBeanFactory beanFactory, Class<T> type,\n                                                        Class<B> beanType, RegistrationBeanAdapter<T> adapter) {\n        for (Entry<String, B> entry : getOrderedBeansOfType(beanFactory, beanType, this.seen)) {\n            String beanName = entry.getKey();\n            B bean = entry.getValue();\n            if (!this.seen.add(bean)) {\n                continue;\n            }\n            RegistrationBean registration = adapter.createRegistrationBean(beanName, bean, entries.size());\n            registration.setOrder(getOrder(bean));// 获取顺序\n            this.initializers.add(type, registration);// 添加到成员当中\n        }\n    }\n}\n```\n\n* 为什么所有的请求都由它管控呢  \n由DispatcherServletRegistrationBean注册dispatchServlet实例。  \nDispatcherServletRegistrationBean继承自DispatcherServletPath  \ngetServletUrlMapping获取servletPath,然后addMapping到对应的servlet中  \n  \n```java\npublic interface DispatcherServletPath {\n   ...\n   default String getServletUrlMapping() {\n      /* getPath() 为yml配置文件中的\n       server:\n         servlet:\n           context-path: ...\n       */\n      if (getPath().equals(\"\") || getPath().equals(\"/\")) {\n         return \"/\";\n      }\n      if (getPath().contains(\"*\")) {\n         return getPath();\n      }\n      if (getPath().endsWith(\"/\")) {\n         return getPath() + \"*\";\n      }\n      return getPath() + \"/*\";\n   }\n\n}\n```\n\n至此servletContext已经配置完毕。按照servlet容器的规范，我们的dispatcherServlet以及项目当中配置的filter，FilterRegistrationBean等配置都已经绑定好并生效。\n\n# dispatcher正常执行流程\n\n## 大体流程\n1. 通过request从HandlerMapping获取HandlerExecutionChain（包含了handler和拦截器）\n   handlerMapping：定位资源，不执行、不获取，只用来定位  \n   * @RequestMapping：<small>handler默认由RequestMappingHandlerMapping提供=org.springframework.web.method.HandlerMethod</small>  \n   * 静态资源：<small>handler默认由SimpleUrlHandlerMapping提供=org.springframework.web.servlet.resource.ResourceHttpRequestHandler</small>\n1. 通过handler获取handlerAdaptor(真正执行handler的处理器)  \n   handlerAdaptor: 根据定位的资源，进行获取(执行)  \n   * @RequestMapping：<small>默认由org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter提供执行服务</small>    \n   * 静态资源：<small>默认由org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter提供执行服务</small>\n1. 如果资源可以复用（未修改），直接返回304，由handlerAdaptor提供服务\n1. 执行前置拦截器interceptor，返回false不允许往下执行\n1. 由handlerAdaptor执行handler的逻辑并返回modelAndView  \n1. 执行后置拦截器interceptor\n1. 根据modelAndView或者执行期间捕获的exception处理最终的响应\n\n> spring的MVC常用的配置，默认由org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration提供  \n> 如静态资源、拦截器、跨域请求、@RequestMapping对应的方法等等。。。\n\n## 代码流程\n```java\npublic class DispatcherServlet extends FrameworkServlet {\n    \n   ...\n   // servlet最终会调用的方法\n   protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n      HttpServletRequest processedRequest = request;\n      HandlerExecutionChain mappedHandler = null; // 本次请求request的处理器，包含了拦截器\n      ...\n      ModelAndView mv = null; //处理结果\n      Exception dispatchException = null; // 处理遇到的异常\n      try {\n         ...\n         // @RequestMapping：默认由RequestMappingHandlerMapping提供handler=org.springframework.web.method.HandlerMethod\n         mappedHandler = getHandler(processedRequest);\n         if (mappedHandler == null) {\n            // 404处理 \n            noHandlerFound(processedRequest, response);\n            return;\n         }\n\n         // 获取执行handler的适配器。\n         // @RequestMapping，默认由org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter提供执行服务\n         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n         // 304。资源复用。\n         String method = request.getMethod();\n         boolean isGet = \"GET\".equals(method);\n         if (isGet || \"HEAD\".equals(method)) {\n            if (new ServletWebRequest(request, response).checkNotModified(ha.getLastModified(request, mappedHandler.getHandler())) && isGet) {\n               return;\n            }\n         }\n         \n         // 调用拦截器pre的方法\n         if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n            return;\n         }\n\n         /*\n          @RequestMapping方法的执行逻辑：     \n          RequestMappingHandlerAdapter执行HandlerMethod时，会通过ServletInvocableHandlerMethod执行HandlerMethod中的方法\n          */\n         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n         ...\n         // 调用后置拦截器\n         mappedHandler.applyPostHandle(processedRequest, response, mv);\n      } catch (Exception ex) {\n         dispatchException = ex;\n      } catch (Throwable err) {\n         dispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n      }\n      // 处理最终的结果，异常和结果都用同一个方法\n      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n      ...\n   }\n}\n```\n\n## @RequestMapping方法提供者-RequestMappingHandlerMapping\n\nRequestMappingHandlerMapping在初始化时会把所有带有@Controller注解或者@RequestMapping注解的bean解析    \n然后把@RequestMapping对应的url和对应的方法(bean和method)绑定到MappingRegistry(MultiValueMap类型)中：key为uri，value为多个HandlerMethod  \ndispatcherServlet在获取对应的Handler时，根据UrlPathHelper从request获取请求的uri(去除contextPath和双斜杠之后的uri)。在根据uri从MappingRegistry获取对应的handlerMethod(可能为0个,1个，多个)  \n如果获取不到可能是restful的接口，则需要遍历所有的接口。根据AntPathMatcher进行挨个匹配，直到循环完所有的mapping  \n此时handlerMethod可能为空，为1个，甚至为多个，然后再从中选取最优的\n\n* @RequestMapping注册的逻辑  \n```java\nclass MappingRegistry {\n    ...\n    //mapping为@RequestMapping的信息\n    public void register(T mapping, Object handler, Method method) {\n        this.readWriteLock.writeLock().lock();\n        try {\n            HandlerMethod handlerMethod = createHandlerMethod(handler, method);// HandlerMethod包含了bean和对应的method\n            validateMethodMapping(handlerMethod, mapping);// 验证@RequestMapping注解不能出现重复的值\n            this.mappingLookup.put(mapping, handlerMethod);\n\n            List<String> directUrls = getDirectUrls(mapping);// 获取@RequestMapping的url（direct：不包含\"*\"、\"?\"、\"{\"、\"}\"符合的url）\n            for (String url : directUrls) {\n                this.urlLookup.add(url, mapping);\n            }\n            ...\n            // 处理跨域@CrossOrigin的注解\n            CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n            if (corsConfig != null) {\n                this.corsLookup.put(handlerMethod, corsConfig);// 保存跨域的注解，后期由CorsInterceptor来处理跨域的信息\n            }\n            ...\n        } finally {\n            this.readWriteLock.writeLock().unlock();\n        }\n    }\n    ...\n}\n```\n\n* 根据请求获取对应的@RequestMapping  \n```java\n// 部分源码\npublic abstract class AbstractHandlerMethodMapping<T> extends AbstractHandlerMapping implements InitializingBean {\n    ...\n    protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {\n        List<Match> matches = new ArrayList<>();\n        // 根据uri直接获取\n        List<T> directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);\n        if (directPathMatches != null) {\n            // uri匹配的mapping，需要判断其他的配置是否匹配，比如@RequestMapping(params = \"abc=123\", method = RequestMethod.POST)\n            addMatchingMappings(directPathMatches, matches, request);\n        }\n        // 为空可能为restful风格，需要遍历所有的接口 原文：No choice but to go through all mappings...\n        if (matches.isEmpty()) {\n            addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);\n        }\n    \n        if (!matches.isEmpty()) {\n            Match bestMatch = matches.get(0);\n            // 获取最优的接口\n            if (matches.size() > 1) {\n                Comparator<Match> comparator = new MatchComparator(getMappingComparator(request));// 选取最优逻辑的排序器\n                matches.sort(comparator);\n                bestMatch = matches.get(0);\n                // 如果是预检请求直接返回一个预检的handler代表已匹配，但是预检请求并不会真正的执行，注意：只有大于2个handler时才会返回，这是因为预检请求和真实请求可能header或参数不一样。无法精确匹配handler\n                if (CorsUtils.isPreFlightRequest(request)) {\n                    return PREFLIGHT_AMBIGUOUS_MATCH;\n                }\n                if (comparator.compare(bestMatch, matches.get(1)) == 0) {\n                    // 选择不了最优的接口直接抛异常\n                    throw new IllegalStateException(...);\n                }\n            }\n            ...\n            return bestMatch.handlerMethod;\n        } else {\n            return null;\n        }\n    }\n    ...\n}\n```\n\n## 多个@RequestMapping时选择最优的匹配\n如以下几个配置\n1. ```@RequestMapping(value = \"*\", headers = \"content-type=text/*\", method = RequestMethod.POST)```  \n1. ```@RequestMapping(value = \"/abc/*\", method = RequestMethod.GET)```\n1. ```@RequestMapping(value = \"/abc/{id}\", params = \"abc=123\")```\n1. ```@RequestMapping(value = \"/abc/def\")```\n\n如果请求地址为 /abc/def,那么会直接匹配第四个注解。\n> 如果url无占位符号、通用符号，那么会根据url进行直接匹配\n\n如果请求地址为 /abc/123?abc=123，则都会匹配前三个的RequestMapping，那么是如何选取最优的呢？\n\n1. 如果request请求是head方法，则优先匹配方法一致的  \n   method = RequestMethod.HEAD\n1. 然后再次匹配pattern精度比较高的\n1. 匹配params精度比较高的  \n   params = \"abc=123\"\n1. 匹配headers精度比较高的  \n   headers = \"content-type=text/*\"\n1. consumers精度比较高的\n1. produces精度比较高的\n1. method精度比较高的\n   \n源码：  \n```java\npublic final class RequestMappingInfo implements RequestCondition<RequestMappingInfo> {\n    ...\n    public int compareTo(RequestMappingInfo other, HttpServletRequest request) {\n        int result;\n        // Automatic vs explicit HTTP HEAD mapping\n        if (HttpMethod.HEAD.matches(request.getMethod())) {\n            result = this.methodsCondition.compareTo(other.getMethodsCondition(), request);\n            if (result != 0) {\n                return result;\n            }\n        }\n        result = this.patternsCondition.compareTo(other.getPatternsCondition(), request);\n        if (result != 0) {\n            return result;\n        }\n        result = this.paramsCondition.compareTo(other.getParamsCondition(), request);\n        if (result != 0) {\n            return result;\n        }\n        result = this.headersCondition.compareTo(other.getHeadersCondition(), request);\n        if (result != 0) {\n            return result;\n        }\n        result = this.consumesCondition.compareTo(other.getConsumesCondition(), request);\n        if (result != 0) {\n            return result;\n        }\n        result = this.producesCondition.compareTo(other.getProducesCondition(), request);\n        if (result != 0) {\n            return result;\n        }\n        // Implicit (no method) vs explicit HTTP method mappings\n        result = this.methodsCondition.compareTo(other.getMethodsCondition(), request);\n        if (result != 0) {\n            return result;\n        }\n        result = this.customConditionHolder.compareTo(other.customConditionHolder, request);\n        if (result != 0) {\n            return result;\n        }\n        return 0;\n    }\n    ...\n}\n```\n\n## RequestMappingHandlerAdapter\n@RequestMapping对应的方法最终会封装成一个HandlerMethod，由RequestMappingHandlerAdapter执行HandlerMethod  \n但在RequestMappingHandlerAdapter内部，把执行权交给了ServletInvocableHandlerMethod，该类继承自HandlerMethod\n\n### <span id=\"ServletInvocableHandlerMethod\">ServletInvocableHandlerMethod</span>\n1. ServletInvocableHandlerMethod调用之前会组装(bind)参数    \n1. bind参数需要获取方法参数上的参数名,默认提供者：DefaultParameterNameDiscoverer    \n1. 以及根据参数名从request获取对应的value，默认提供者：RequestMappingHandlerAdapter#getDefaultArgumentResolvers。**ps:通过实现WebMvcConfigurer#addArgumentResolvers，可自定义参数解析器**  \n1. 组装好参数之后ServletInvocableHandlerMethod通过反射调用真正的@RequestMapping对应的方法  \n1. 调用出现异常会把异常抛出去，由[dispatcher处理](#dispatcher错误执行流程)  \n1. 调用方法后返回的结果会通过HandlerMethodReturnValueHandler处理响应，默认提供者：RequestMappingHandlerAdapter#getDefaultReturnValueHandlers。**ps:通过实现WebMvcConfigurer#addReturnValueHandlers可自定义返回值处理**  \n1. returnValue处理完之后动态的返回modelAndView**ps:如果是@ResponseBody则返回null，因为返回值已经在内部处理了，其他的如重定向、重转发、返回页面渲染等通过modelAndView完成**\n\n# <span id='dispatcher错误执行流程'>dispatcher错误执行流程</span>  \n常见的错误有\n1. 404\n2. @RequestMapping请求方式不对。\n3. 参数转换异常\n4. 参数校验失败\n5. **逻辑处理异常**\n6. ...等其他的不常见异常\n\n## 大体流程\n1. dispatcherServlet遇到异常会通过内部的方法processHandlerException遍历HandlerExceptionResolver的实现类处理异常\n1. HandlerExceptionResolver的默认提供者```org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#addDefaultHandlerExceptionResolvers```  \n   @ExceptionHandler的注解，由ExceptionHandlerExceptionResolver处理  \n1. ExceptionHandlerExceptionResolve处理异常时：通过异常的类型找出能处理的方法  \n   ```ExceptionHandlerExceptionResolver#getExceptionHandlerMethod```找出能处理对应异常类型的方法  \n   如果handler不为空代表在执行handler期间遇到的异常 ，优先从当前handler找出能处理对应异常的@ExceptionHandler注解方法  \n   如果handler为空或handler找不到能处理异常的方法，则从全局@ControllerAdvice注解的类中找出能处理对应异常的@ExceptionHandler注解方法  \n1. 获取然后包装成[ServletInvocableHandlerMethod](#ServletInvocableHandlerMethod)，并把执行权交给它\n1. 如果ServletInvocableHandlerMethod在执行异常处理期间遇到了异常则```return null```,交由下一个HandlerExceptionResolver的实现类接着处理原先的异常 \n\n## 代码流程\n\n1. dispatcherServlet遇到异常会通过内部的方法processHandlerException遍历HandlerExceptionResolver的实现类处理异常  \n   @ExceptionHandler的注解，由ExceptionHandlerExceptionResolver处理  \n```java\npublic class DispatcherServlet extends FrameworkServlet {\n    ...\n    protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        ...\n\t\tModelAndView exMv = null;\n\t\tif (this.handlerExceptionResolvers != null) {\n\t\t    // 遍历HandlerExceptionResolver的实现类处理异常\n\t\t\tfor (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {\n\t\t\t\texMv = resolver.resolveException(request, response, handler, ex);\n\t\t\t\tif (exMv != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (exMv != null) {\n\t\t\tif (exMv.isEmpty()) {// @ResponseBody已处理\n\t\t\t\trequest.setAttribute(EXCEPTION_ATTRIBUTE, ex);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!exMv.hasView()) {// 重定向、重转发、页面渲染等\n\t\t\t\tString defaultViewName = getDefaultViewName(request);\n\t\t\t\tif (defaultViewName != null) {\n\t\t\t\t\texMv.setViewName(defaultViewName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t...\n\t\t\treturn exMv;\n\t\t}\n\t\t...\n    }\n}\n```\n\n1. ExceptionHandlerExceptionResolve处理异常时：通过异常的类型找出能处理的方法  \n   获取然后包装成[ServletInvocableHandlerMethod](#ServletInvocableHandlerMethod)，并把执行权交给它\n\n```java\npublic class ExceptionHandlerExceptionResolver extends AbstractHandlerMethodExceptionResolver implements ApplicationContextAware, InitializingBean {\n\tprotected ModelAndView doResolveHandlerMethodException(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod, Exception exception) {\n         // 通过异常的类型找出能处理的方法\n         ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);\n         if (exceptionHandlerMethod == null) {\n            return null;\n         }\n         \n         if (this.argumentResolvers != null) {\n            exceptionHandlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n         }\n         if (this.returnValueHandlers != null) {\n            exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n         }\n         \n         ServletWebRequest webRequest = new ServletWebRequest(request, response);\n         ModelAndViewContainer mavContainer = new ModelAndViewContainer();\n         \n         try {\n            Throwable cause = exception.getCause();\n            if (cause != null) {\n                exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod);\n            }\n            else {\n                exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod);\n            }\n         }\n         catch (Throwable invocationEx) {\n            return null;\n         }\n         \n         // 如果已经对response做过处理\n         if (mavContainer.isRequestHandled()) {\n            return new ModelAndView();\n         }\n\t\t ...\n\t}\n\t\n   // 找出能处理对应异常的方法\n   protected ServletInvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {\n      Class<?> handlerType = null;\n      // 如果handler不为空代表在执行handler期间遇到的异常 ，优先从当前handler找出能处理对应异常的@ExceptionHandler注解方法\n      if (handlerMethod != null) {\n         handlerType = handlerMethod.getBeanType();\n         Method method = new ExceptionHandlerMethodResolver(handlerType).resolveMethod(exception);\n         if (method != null) {\n            return new ServletInvocableHandlerMethod(handlerMethod.getBean(), method);\n         }\n         if (Proxy.isProxyClass(handlerType)) {\n            handlerType = AopUtils.getTargetClass(handlerMethod.getBean());\n         }\n      }\n\n      // 如果handler为空或handler找不到能处理异常的方法，则从全局@ControllerAdvice注解的类中找出能处理对应异常的@ExceptionHandler注解方法\n      // 具体获取@ControllerAdvice对应的方法可参考ExceptionHandlerExceptionResolver#initExceptionHandlerAdviceCache\n      for (Map.Entry<ControllerAdviceBean, ExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n         ControllerAdviceBean advice = entry.getKey();\n         if (advice.isApplicableToBeanType(handlerType)) {\n            ExceptionHandlerMethodResolver resolver = entry.getValue();\n            Method method = resolver.resolveMethod(exception);\n            if (method != null) {\n               return new ServletInvocableHandlerMethod(advice.resolveBean(), method);\n            }\n         }\n      }\n\n      return null;\n   }\n\n}\n```\n\n# 总结\nExceptionHandlerExceptionResolver是@ExceptionHandler注解的实现。通过异常的类型优先从handler对应的bean里面寻找@ExceptionHandler  \n如果找不到处理异常的方法或者handler为空，则从全局@ControllerAdvice的bean里面寻找对应的方法  \n获取然后包装成[ServletInvocableHandlerMethod](#ServletInvocableHandlerMethod)，并把执行权交给它","tags":["源码","spring"],"categories":["java","spring"]},{"title":"springMvc统一异常处理","url":"/posts/springmvc统一异常处理/","content":"\n先配置处理异常的类，然后在分析源码\n\n# mvc统一处理异常的实现\n\n常见的异常如下，基本都是参数校验的异常。参数校验需要配合jsr303的注解校验哦。\n\n```java\n@Slf4j\n@RestControllerAdvice\n@ConditionalOnWebApplication // 只有web容器才会初始化\npublic class CommonExceptionHandler {\n\n    /**\n     * 本项目自定义的业务异常\n     */\n    @ExceptionHandler(BizException.class)\n    public Object exceptionHandler(BizException e, HttpServletRequest request) {\n        log.info(\"全局BizException异常params:\" + WebUtils.getPrettyParam(request), e);\n        return Result.toThis(e.getResultEnum(), e.getMessage(), e.getData());\n    }\n\n    @ExceptionHandler(RpcException.class)\n    public Result<?> handleException(RpcException e) {\n        // todo 需要系统通知\n        log.info(\"全局异常--dubbo调用异常RPC_INVOKE_ERROR:\", e);\n        if (e.getCause() instanceof RemotingException) {\n            // dubbo 提供者 不在线\n            return Result.toThis(ResultEnum.RPC_INVOKE_ERROR, \"服务提供者出现了问题\\n\" + e.getCause().getMessage());\n        }\n        // dubbo 未找到提供者\n        return Result.toThis(ResultEnum.RPC_INVOKE_ERROR, \"dubbo调用异常\\n\" + e.getMessage());\n    }\n\n    /**\n     * 参数校验异常\n     *\n     */\n    @ExceptionHandler(HttpMessageNotReadableException.class)\n    public Object exceptionHandler(HttpMessageNotReadableException e, HttpServletRequest request) {\n        log.info(\"全局方法参数校验异常HttpMessageNotReadableException,params:\" + WebUtils.getPrettyParam(request), e);\n        if (e.getRootCause() instanceof EnumDeserializeException) {\n            return Result.toThis(ResultEnum.ERROR_ALERT, e.getRootCause().getMessage());\n        }\n        return Result.toThis(ResultEnum.ERROR_ALERT, \"参数读取失败:\" + e.getMessage());\n    }\n\n    /**\n     * 参数校验异常\n     *\n     * @code 直接在方法参数上进行校验\n     */\n    @ExceptionHandler(ConstraintViolationException.class)\n    public Object exceptionHandler(ConstraintViolationException e, HttpServletRequest request) {\n        log.info(\"全局方法参数校验异常ConstraintViolationException,params:\" + WebUtils.getPrettyParam(request), e);\n\n        String message = e.getConstraintViolations().stream()\n                .map(ConstraintViolation::getMessage)\n                .collect(Collectors.joining(\", \"));\n\n        return Result.toThis(ResultEnum.ERROR_ALERT, message);\n    }\n\n    /**\n     * 处理所有接口数据验证异常\n     *\n     * @code @RequestBody 里面的字段\n     */\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public Result<?> handleMethodArgumentNotValidException(MethodArgumentNotValidException e, HttpServletRequest request) {\n        log.info(\"全局方法参数校验异常MethodArgumentNotValidException,params:\" + WebUtils.getPrettyParam(request), e);\n\n        List<ObjectError> errors = e.getBindingResult().getAllErrors();\n        String msg = errors.stream()\n                .map(DefaultMessageSourceResolvable::getDefaultMessage)\n                .distinct()\n                .collect(Collectors.joining(\"\\n\"));\n        return Result.toThis(ResultEnum.ERROR_ALERT, msg);\n    }\n\n    /**\n     * 参数验证异常\n     *\n     * @code @ModelAttribute 里面的字段\n     */\n    @ExceptionHandler(BindException.class)\n    public Object validateExp(BindException e, HttpServletRequest request) {\n        log.info(\"全局方法参数校验异常BindException,params:\" + WebUtils.getPrettyParam(request), e);\n        String sb = e.getAllErrors().stream()\n                .map(error -> {\n                    try {\n                        Object source = FieldUtils.readField(error, \"source\", true);\n                        if (source instanceof TypeMismatchException) {\n                            return getMessage((TypeMismatchException) source);\n                        }\n                        return error.getDefaultMessage();\n                    } catch (IllegalAccessException ignored) {\n                        return error.getDefaultMessage();\n                    }\n                }).distinct()\n                .collect(Collectors.joining(\"\\n\"));\n\n        return Result.toThis(ResultEnum.ERROR_ALERT, sb);\n    }\n\n    /**\n     * 参数验证异常\n     *\n     * @code @RequestParam(required = true)\n     */\n    @ExceptionHandler(MissingServletRequestParameterException.class)\n    public Object validateExp(MissingServletRequestParameterException e, HttpServletRequest request) {\n        log.info(\"全局方法参数校验异常MissingServletRequestParameterException,params:\" + WebUtils.getPrettyParam(request), e);\n        log.info(\"类型{}, 字段{}, 不能为空，必填项\", e.getParameterType(), e.getParameterName());\n        return Result.toThis(ResultEnum.ERROR_ALERT, e.getParameterName() + \"不能为空，必填项！类型：\" + e.getParameterType());\n    }\n\n    /**\n     * 参数验证异常 -- 对于springMVC接受参数类型转化问题\n     */\n    @ExceptionHandler(MethodArgumentTypeMismatchException.class)\n    public Object validateExp(MethodArgumentTypeMismatchException e, HttpServletRequest request) {\n        log.warn(\"全局方法参数校验异常MethodArgumentTypeMismatchException,params:\" + WebUtils.getPrettyParam(request), e);\n        String message = getMessage(e);\n        log.info(message);\n        return Result.toThis(ResultEnum.ERROR_ALERT, message);\n    }\n\n    private String getMessage(TypeMismatchException e) {\n        return \"参数：\" + e.getPropertyName() + \",值：\" + e.getValue() + \"，不能转成\" + e.getRequiredType() + \"类型！\";\n    }\n\n    /**\n     * 全局异常管理\n     */\n    @RestControllerAdvice\n    @ConditionalOnWebApplication // 当前是web容器才会初始化\n    public static class GlobalHandler {\n\n        /**\n         * 处理所有不可知的异常\n         */\n        @ExceptionHandler(Throwable.class)\n        public Object handleException(Throwable e) {\n            log.error(\"全局系统异常捕获\", e);\n\n            String stackStr = Arrays.stream(ObjectUtils.defaultIfNull(e.getStackTrace(), new StackTraceElement[0]))\n                    .filter(t -> t.getClassName().startsWith(\"com\") || t.getClassName().startsWith(\"cn\"))\n                    .filter(t -> t.getLineNumber() > 0)\n                    .map(t -> t.getClassName() + \".\" + t.getMethodName() + \":\" + t.getLineNumber())\n                    .collect(Collectors.joining(\"\\n\"));\n            stackStr = e.getClass() + \":\" + e.getMessage() + \"\\n\" + stackStr;\n\n            return Result.toThis(ResultEnum.SYSTEM_ERROR, ResultEnum.SYSTEM_ERROR.getMessage(), stackStr);\n        }\n\n        // 不支持的请求-post-get-put-delete\n        @ExceptionHandler(HttpRequestMethodNotSupportedException.class)\n        public Object validateExp(HttpRequestMethodNotSupportedException ex, HttpServletRequest request) {\n            String method = request.getMethod();\n            String supportList = Arrays.toString(ex.getSupportedMethods());\n            log.warn(\"不支持的请求，uri:{},method:{},支持的请求:{}\", request.getRequestURI(), method, supportList);\n            return Result.toThis(ResultEnum.SYSTEM_ERROR, \"不支持\" + method + \"请求，支持的请求：\" + supportList);\n        }\n\n        // 不支持的请求-post-get-put-delete\n        @ExceptionHandler(NoHandlerFoundException.class)\n        public Object validateExp(NoHandlerFoundException ex, HttpServletRequest request) {\n            log.warn(\"404，访问的接口地址:{},请求头:{}\", request.getRequestURI(), WebUtils.getPrettyHeaders(request));\n            return Result.toThis(ResultEnum.SYSTEM_ERROR, \"访问接口不存在，联系开发人员\");\n        }\n\n    }\n}\n\n```\n\n\n# 源码分析\n\n咱们一起来看看他是怎么生效的。为什么还区分全局和非全局？\n[springMvc异常时的执行流程](/posts/springMvc执行流程#总结)","tags":["spring","代码规范","异常拦截"],"categories":["java","spring"]},{"title":"spring-spi","url":"/posts/spring-spi/","content":"\njava有[java的spi](/posts/java-spi)  \ndubbo有[dubbo的spi](/posts/dubbo-spi)  \nspring也有自己的spi  \n\nspring spi 入口类为```org.springframework.core.io.support.SpringFactoriesLoader```\n\nspringBoot main启动时就用到了  \n```java\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n    ...\n    // Context initialize 监听器\n    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    // 所有的ApplicationListener\n    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n    ...\n}\n\nprivate <T> Collection<T> getSpringFactoriesInstances(Class<T> type) {\n    return getSpringFactoriesInstances(type, new Class<?>[] {});\n}\n\nprivate <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {\n    ClassLoader classLoader = getClassLoader();\n    // SpringFactoriesLoader为spring spi\n    Set<String> names = new LinkedHashSet<>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));\n    List<T> instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);\n    // 排序\n    AnnotationAwareOrderComparator.sort(instances);\n    return instances;\n}\n\n```\n\n# 原理\n在所有的classPath中寻找资源为```META-INF/spring.factories```的文件。  \n里面的格式为key=value[,value,value]\n> key为class全类名，value为对应实现类的全类名\n\n通过SpringFactoriesLoader 加载文件的内容。使用时通过```SpringFactoriesLoader.loadFactoryNames(type, classLoader)```来获取对应的value，然后在通过反射实例化\n\n# 源码赏析\n```java\npublic final class SpringFactoriesLoader {\n\n\tpublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n\n\t...\n\n\tpublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\n\t\tString factoryTypeName = factoryType.getName();\n\t\treturn loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());\n\t}\n\n\tprivate static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n\t\tMultiValueMap<String, String> result = cache.get(classLoader);\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// 通过classLoader获取所有的资源，并加载本地缓存里面\n\t\ttry {\n\t\t\tEnumeration<URL> urls = (classLoader != null ?\n\t\t\t\t\tclassLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n\t\t\t\t\tClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n\t\t\tresult = new LinkedMultiValueMap<>();\n\t\t\twhile (urls.hasMoreElements()) {\n\t\t\t\tURL url = urls.nextElement();\n\t\t\t\tUrlResource resource = new UrlResource(url);\n\t\t\t\tProperties properties = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t\tfor (Map.Entry<?, ?> entry : properties.entrySet()) {\n\t\t\t\t\tString factoryTypeName = ((String) entry.getKey()).trim();\n\t\t\t\t\tfor (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {\n\t\t\t\t\t\tresult.add(factoryTypeName, factoryImplementationName.trim());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcache.put(classLoader, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load factories from location [\" +\n\t\t\t\t\tFACTORIES_RESOURCE_LOCATION + \"]\", ex);\n\t\t}\n\t}\n\t...\n}\n\n```","tags":["源码","spring"],"categories":["java","spring"]},{"title":"MybatisPlus语法糖的校验","url":"/posts/mybatisplus语法糖的校验/","content":"mybatisPlus大大的提高了我们开发的速度。因为不需要关心sql。建立好的对象通过mybatisPlus语法糖来拼接sql。但是坏处是语法糖不好统一维护。到处都是语法糖。\n所以我们规定建立一层Dao，dao层负责统一管理sql。因为要去除xml里面的sql。写sql容易出问题（字符串容易写错，不同数据库还需要关心不同的特性）  \n建议Dao统一[继承此BaseDao](/posts/重新加装MybatisPlus#5避免空指针使api操作更安全)    \n> 一个表对应一个实体、一个mapper，一个Dao  \n> Dao继承BaseDao，需要实体继承BaseDomain,mapper继承CustomBaseMapper  \n> 如果实体不继承baseDomain，mapper不继承CustomBaseMapper，则dao也无法继承BaseDao\n\n**如何有效(强制)的避免以下相同拼接的sql出现在多处？**  \n例如以下的sql拼接语法糖  \n\n```java\npublic DemoService {\n    \n    @Autowired\n    DemoDao demoDao;\n    \n    public void doSomeA() {\n        ...\n        List<Object> list = this.demoDao.lambdaQuery()\n            .eq(\"Demo.field1\", 1)\n            .eq(\"Demo.field2\", 3)\n            .like(\"Demo.field3\", \"like\")\n            .list();\n        // 其他业务逻辑\n        ...\n    }\n    \n    public void doSomeB() {\n            ...\n            List<Object> list = this.demoDao.lambdaQuery()\n                .eq(\"Demo.field1\", 1)\n                .eq(\"Demo.field2\", 3)\n                .like(\"Demo.field3\", \"like\")\n                .list();\n            // 其他业务逻辑\n            ...\n    }\n}\n```\n\n虽然我们可以定制规范来约束大家把.点.点.的sql拼接的语法封装成一个方法。但是在人员越来越多的情况下，没有强制的规范约束会变得越来越乱。\n\n## 如何强制约束  \n1. 通过编写maven的编译插件，检测代码是否有冗余的，或者sql拼接出现在非Dao层中直接编译不通过，予以警告。但是由于学习成本比较大，编译平台过多，就放弃了(有心者可以按照此方法来实现，欢迎交流探讨)。  \n2. 通过Java的调用栈来判断是谁在调用(本文的实现)\n\n### 原理  \n通过看源码，语法糖拼接sql之前必定会```new  com.baomidou.mybatisplus.core.conditions.Wrapper```该类是语法糖对象顶层的超类(abstract class)。  \n通过切入wrapper的构造方法，判断是谁new的，如果调用者是别的模块，比如在service层中new的Wrapper，则直接报异常。如果是在dao层new的，则允许通过。  \n我们用javassist工具来切入com.baomidou.mybatisplus.core.conditions.Wrapper 的构造方法。\n\n## 上代码\nspring factories 配置容器启动的监听类\n```properties\norg.springframework.context.ApplicationListener=com.DaoVerify\n```\nfactories可参考[springBoot容器启动流程](/posts/springBoot容器启动流程)\n\nENV可参考 [获取spring启动环境的工具类](/posts/获取spring启动环境的工具类)\n```java\n@Slf4j\npublic static class DaoVerify implements ApplicationListener<ApplicationPreparedEvent> {\n\n    @SneakyThrows\n    @Override\n    public void onApplicationEvent(ApplicationPreparedEvent event) {\n\n        log.info(\"begin Weaving for runtime check\");\n        // test环境肯定都是按照规范来的,正式环境不做切入。提高性能。\n        if (ENV.isProd()) {\n            log.info(\"Non-dev does not check\");\n            return;\n        }\n\n        // wrapper超类实现的接口的classLoader\n        // 有用到restartDevTools或者spring-boot-maven-plugins，classLoader都会不同，用超类的classLoader准没错\n        ClassLoader loader = ISqlSegment.class.getClassLoader();\n        log.info(\"begin Weaving into  Dao for verify caller ，verify package name :dao ,classLoader:{}\", loader);\n        ClassPool pool = ClassPool.getDefault();\n        pool.insertClassPath(new LoaderClassPath(loader));\n        CtClass wrapper = pool.get(\"com.baomidou.mybatisplus.core.conditions.Wrapper\");\n        // 如果已经toClass，则是冻结的状态，spring多容器下此方法肯定会多次调用\n        if (wrapper.isFrozen()) {\n            log.info(\"isFrozen\");\n            return;\n        }\n\n        {\n            // 调用栈字符串拼接，用来做错误提示\n            StringBuilder sb = new StringBuilder();\n            // 整个的调用栈\n            StackTraceElement[] ste = (new Throwable()).getStackTrace();\n            // Dao层的调用次数\n            int daoCount = 0;\n            for (int i = 0; i < ste.length; ++i) {\n                StackTraceElement s = ste[i];\n                // 这个是mybatisPlus源码中new的，如果是此类，我们不做校验\n                if (s.getClassName().contains(\"com.baomidou.mybatisplus.core.toolkit.Wrappers$EmptyWrapper\")){\n                    return;\n                }\n                String className = s.getClassName();\n                sb.append(className).append(\":\").append(s.getMethodName()).append(\":\").append(s.getLineNumber()).append(\"\\\\\\\\n\");\n                // s.getLineNumber() > 0: 忽略动态代理的调用栈，动态代理的lineNumber = -1\n                if (className.startsWith(\"你的项目的Dao层的包名\") && !className.contains(\"BaseDao\") && s.getLineNumber() > 0){\n                    daoCount++;\n                }\n            }\n            // 如果没有Dao层调用，而是其他层调用，则直接报错，起到了强制校验的功能\n            if (daoCount == 0) {\n                // 提示并携带stacktrace\n                throw new RuntimeException(\"请把sql拼接的条件写在Dao中\\n\" + sb);\n            }\n        }\n        wrapper.getConstructors()[0].insertBeforeBody(\"需要把上面括号中的代码粘贴到此处，为了读者阅读方便就给提到了上面。\");\n        // 加载class，一但加载之后本工具类，不能再次修改\n        wrapper.toClass(loader, null);\n        log.info(\"weaving succeed\");\n    }\n}\n```\n\n# 总结\n配置好容器启动监听之后，赶在语法糖超类加载之前，利用javassist修改字节码工具。修改语法糖超类的构造方法。  \n构造方法执行的时候我们通过(new Throwable)查看java的stackTrace调用栈，如果没有我们的Dao层调用的话，直接抛出异常，这样就起到了强制校验的功能了。","tags":["mybatisPlus","代码规范"],"categories":["java","设计模式"]},{"title":"基于Spring的代码分层校验","url":"/posts/基于spring的代码分层校验/","content":"\n# 常见的代码分层图\n![代码分层图](/img/posts/2021/layer-code.png)\n\n## 分层很明确，先说缺点\n1. service层可以依赖多个dao层  \n一个表肯定对应一个dao。如果一个service直接操作多张表(dao)也没问题，但是有可能所有表的操作都封闭在一个service中。  \n   - 如果后期维护某一张表的时候你就得需要屡下所有调用此表的service，花费时间不说，还有可能漏掉。\n   - 如果对其中一个表进行别的业务复用的话，则需要把代码抽离出来，并且有可能开发人员不抽离，而是直接copy粘贴，导致代码原来越乱。\n> 所以建议一个表对应一个dao和一个service，其中service只能操作自己的表(dao)。要是操作其他的表只能依赖其对应的service\n2. 上图没有明确表明哪些是可以互相依赖(service依赖其他service，dao可以依赖其他dao...)，哪些不可以互相依赖。所以我们认为都是可以相互依赖的。互相依赖比较混乱。\n> dao专门负责管理sql，如果对一个实体的curd还涉及到另外其他的实体curd。那么这就显然属于业务范畴了，应该放在service。所以在dao这一层。我们不能让他操作多张表(不能有互相依赖)\n3. 没有强制的依赖校验。如果controller直接引用dao层也可以正常运行。会增加后期维护的困难性\n   \n# 代码依赖的强制校验\n对于代码依赖校验，按照以上几个点来校验的话\n1. 首先得定义一个dao层，确保一个表的curd的sql不会乱出现别的dao地方。所以用到[mybatisPlus的sql语法糖校验](/posts/MybatisPlus语法糖的校验)  \n2. 其次不同层有不同的依赖规则。  \n   - 如controller不能依赖dao，\n   - service不能依赖其他dao(表)，只能依赖自己的dao\n   - dao不能有相互依赖。  \n\n不同层有不用的配置,所以我们需要一个可配置的注解\n## 校验依赖的注解\n此注解只能放在package上。代表对此包以及子包里面spring管理的bean进行校验\n```java\n@Target(ElementType.PACKAGE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface PackageCheck {\n\n    /**\n     * 当前包的校验排除子包\n     */\n    String[] checkExcludeSubPackages() default \"config\";\n\n    /**\n     * 不能依赖此包的内容\n     */\n    String[] notAllowDependPackageNames();\n\n    /**\n     * 必须命名正则的规则\n     */\n    String mustNamePattern() default \".*\";\n\n    /**\n     * 当前包所有的类必须继承的类\n     */\n    Class<?> classMustExtendClass() default Object.class;\n\n    Class<?>[] exclusionClass() default {};\n\n    /**\n     * 当前包所有的类可以相互依赖\n     */\n    boolean interdependenceOnSamePackage() default true;\n\n    /**\n     * 当前包所有的类依赖的类型有且只能有一个(如果指定的话)\n     */\n    Class<?>[] dependOnly() default {};\n}\n```\n\n## 注解校验的配置\n1. controller层\n在controller包结构目录下新建一个packang-info.java。然后用此注解配置校验的内容  \n```java\n   @CodeVerify.PackageCheck(classMustExtendClass = BaseController.class // 所有的controller必须要继承此类，可有可无\n   , mustNamePattern = \".*Controller$\" // controller命名必须匹配该正则\n   , notAllowDependPackageNames = {\"mapper层的包名称\", \"dao层的包名称\"}) // controller不能直接依赖dao，也不能直接依赖mapper。（只能通过service调用）\n```\n   \n2. service层\n在service包结构目录下新建一个packang-info.java。然后用此注解配置校验的内容  \n```java\n   @CodeVerify.PackageCheck(classMustExtendClass = BaseService.class// 所有的service必须要继承此类，可有可无\n        , mustNamePattern = \".*Service(Impl)?$\"// 该包下spring管理的bean命名必须匹配该正则\n        , notAllowDependPackageNames = {\"mapper层的包名称\"} // 不能直接依赖mapper层，只能通过依赖dao。\n        , dependOnly = BaseDao.class)//只能依赖一个Dao，一般都是一个表，一个mapper，一个dao，一个service\n```\n   \n3. dao层\n建议Dao统一[继承此BaseDao](/posts/重新加装MybatisPlus#5避免空指针使api操作更安全)  \n一个表的所有sql按照规范写在同一个类中[mybatisPlus的sql语法糖强制校验](/posts/MybatisPlus语法糖的校验)  \n   \n```java\n@CodeVerify.PackageCheck(classMustExtendClass = BaseDAO.class\n        , mustNamePattern = \".*Dao$\"\n        , notAllowDependPackageNames = {}// 如果dao的java代码可以引用service不报错，可以配置不能依赖service包。因为我们项目是分模块，如果用service代码编译器会直接报错，所以写不写都没有必要\n        , interdependenceOnSamePackage = false) // 不允许有互相依赖，一个dao只能管理自己的表，如果涉及到其他表则应该放在service处理。\n```\n\n## 开始校验\n待容器启动后，所有bean的依赖的关系已形成，我们就可以校验了。\n> 可以参考[springBoot容器启动流程](/posts/springBoot容器启动流程)\n\n```java\n@Slf4j\npublic static class DependCheck implements ApplicationListener<ApplicationStartedEvent> {\n\n   @SneakyThrows\n   @Override\n   public void onApplicationEvent(ApplicationStartedEvent event) {\n      ConfigurableListableBeanFactory beanFactory = event.getApplicationContext().getBeanFactory();\n      \n      // 所有需要校验的包。Package.getPackages()只有对应的package有真正的类才算是真正的一个package，只有Package-info.java是不行的\n      List<Package> checkPackageList = Arrays.stream(Package.getPackages())\n              .filter(t -> t.isAnnotationPresent(PackageCheck.class))// 把需要校验的过滤出来\n              .collect(Collectors.toList());\n\n      String[] allBeanNames = beanFactory.getBeanDefinitionNames(); // 获取所有的bean\n\n      List<String> errorMessageList = Lists.newArrayList();\n\n      log.info(\"check PackageNames:{}\", checkPackageList);\n      for (Package checkPackage : checkPackageList) {\n         PackageCheck annotation = checkPackage.getAnnotation(PackageCheck.class);\n         log.info(\"DependCheck starting package:{}, configuration:{}\", checkPackage.getName(), annotation);\n\n         // 校验的条件\n         String[] excludeSubPackages = annotation.checkExcludeSubPackages();\n         Class<?> mustExtendClass = annotation.classMustExtendClass();\n         String mustSuffixName = annotation.mustNamePattern();\n         String[] notAllowDependPackageNames = annotation.notAllowDependPackageNames();\n         boolean interdependenceOnSamePackage = annotation.interdependenceOnSamePackage();\n         Class<?>[] dependOnly = annotation.dependOnly();\n         Class<?>[] exclusionsClass = annotation.exclusionClass();\n\n\n         String currentPackage = checkPackage.getName();\n         for (String beanName : allBeanNames) {\n            BeanDefinition mergedBeanDefinition = beanFactory.getMergedBeanDefinition(beanName);\n            String beanClassName = mergedBeanDefinition.getResolvableType().getType().getTypeName();\n            if (!beanClassName.startsWith(currentPackage)) { // 只有这个package的包才会校验\n               continue;\n            }\n\n            boolean excludeSubPackage = Arrays.stream(excludeSubPackages)\n                    .anyMatch(t -> beanClassName.substring(currentPackage.length()).contains(t)); // 排除子包的校验，如果有的话\n            if (excludeSubPackage) {\n               continue;\n            }\n\n            Class<?> beanClass = Class.forName(beanClassName);\n            boolean exclusionClass = Arrays.stream(exclusionsClass) // 排除class的校验，如果有的话\n                    .anyMatch(beanClass::isAssignableFrom);\n            if (exclusionClass) {\n               continue;\n            }\n\n            // 当前bean的依赖\n            String[] beanDependenciesName = beanFactory.getDependenciesForBean(beanName);\n            List<Class<?>> beanDependenciesClass = Arrays.stream(beanDependenciesName)\n                    .map(beanFactory::getMergedBeanDefinition)\n                    .map(BeanDefinition::getResolvableType)\n                    .map(ResolvableType::getRawClass)\n                    .collect(Collectors.toList());\n\n\n            // 不允许依赖其他的包\n            if (ArrayUtils.isNotEmpty(notAllowDependPackageNames)) {\n\n               boolean match = Arrays.stream(notAllowDependPackageNames)\n                       .anyMatch(notAllowDependPackageName ->\n                               beanDependenciesClass.stream()\n                                       .map(Class::getName)\n                                       .anyMatch(className ->\n                                               className.startsWith(notAllowDependPackageName)\n                                       )\n                       );\n\n               if (match) {\n                  String msg = MessageFormat.format(\n                          \"类:{0}，不能依赖{1}包的内容. \\n\\t目前依赖的有:{2}\"\n                          , beanClassName\n                          , Arrays.toString(notAllowDependPackageNames)\n                          , Arrays.toString(beanDependenciesName)\n                  );\n                  errorMessageList.add(\"依赖不规范:\\n\\t\" + msg);\n               }\n            }\n\n            // 不能有相互依赖\n            if (!interdependenceOnSamePackage) {\n               boolean match = beanDependenciesClass.stream()\n                       .map(Class::getName)\n                       .anyMatch(dependTypeName -> dependTypeName.startsWith(currentPackage));\n               if (match) {\n                  String msg = MessageFormat.format(\n                          \"类:{0}，不能依赖同包及子包的类. \\n\\t目前依赖的有:{1}\"\n                          , beanClassName\n                          , Arrays.toString(beanDependenciesName)\n                  );\n                  errorMessageList.add(\"依赖不规范:\\n\\t\" + msg);\n               }\n            }\n\n            // 依赖的类型有且只能有一个\n            if (ArrayUtils.isNotEmpty(dependOnly)) {\n\n               boolean match = Arrays.stream(dependOnly)\n                       .anyMatch(dependOnlyClass ->\n                               beanDependenciesClass.stream()\n                                       .filter(dependOnlyClass::isAssignableFrom)\n                                       .count() > 1\n                       );\n\n               if (match) {\n                  String msg = MessageFormat.format(\n                          \"类:{0}，依赖的类型有且只能有一个{1}, \\n\\t目前依赖的有:{2}\"\n                          , beanClassName\n                          , Arrays.toString(dependOnly)\n                          , Arrays.toString(beanDependenciesName)\n                  );\n                  errorMessageList.add(\"依赖不规范:\\n\\t\" + msg);\n               }\n            }\n\n            boolean configBean = beanClass.isAnnotationPresent(ConfigurationProperties.class) || beanClass.isAnnotationPresent(Component.class);\n\n            if (!configBean && !mustExtendClass.isAssignableFrom(beanClass)) {\n               errorMessageList.add(\"类继承不规范:\\n\\t\" + beanClassName + \"必须继承\" + mustExtendClass);\n            }\n            if (!configBean && !beanClassName.matches(mustSuffixName)) {\n               errorMessageList.add(\"名称不规范:\\n\\t\" + beanClassName + \"名称格式必须是:\" + mustSuffixName);\n            }\n\n         }\n\n      }\n      if (!errorMessageList.isEmpty()) {\n         throw new RuntimeException(\"代码编写不规范\\n\" + String.join(\"\\n\", errorMessageList)) {\n            public Throwable fillInStackTrace() {\n               return this;\n            }\n         };\n      }\n   }\n}\n```\n\n# 总结\n由于每个团队，每个项目工程的规范都不同。所以我们根据注解的配置进行校验。  \n在结合[mybatisPlus语法糖校验](/posts/MybatisPlus语法糖的校验)，保证sql只允许出现在一处，确保我们的项目curd不会过于混乱。  \n以本文的代码分层为规范的技术思想，不同于DDD领域驱动设计的是：按照本文设计的规范，在不用DDD(领取驱动设计)的前提下，应用过于庞大或复杂的情况时我们还能保证业务代码不会过于臃肿、林乱不堪。\n\n引用知乎的DDD驱动设计的简介。\n> DDD解决的问题是单体应用过大过于复杂导致开发团队的成员没有人能够了解业务全貌，换句话说程序的复杂度失控了。\n> 比如你有一个方法上千行，肯定难以维护，所以你要拆。但是一个应用你怎么拆？传统的拆分角度的出发点是基于技术，比如三层架构，比如前后分离。但是这样的拆分不能降低业务的复杂度。\n> DDD就是用来划分业务边界的。DDD不是架构思想，是统筹规划软件开发的思想。\n> 很多架构模式应用到DDD设计的系统里。其实你用DDD拆分出来的服务用传统的代码组织方式(传统的分层,repository, service, controller)也完全没有问题\n\nDDD就是用来划分业务边界的。但是DDD设计在普通的CURD应用开发中很难运用好，大部分都是分层的设计。但是我们可以吸取DDD的好处，并结合分层设计的思想来处理我们的业务代码  \n所以规范一张表对应一个实体，并且对应一个dao。然后我们保证一个dao只能由一个service操作，换句话说一个service只能操作一个dao，操作其他dao只能依赖其对应的service。  \n那么这种分层方式和DDD领取驱动设计的精髓有相似（重合）之处。在不用学习DDD的前提下还能保证我们的代码不会过于的混乱，也只有这种更精细的分层方式了。\n> 贫血模型：普通bean的一些内置get|set毫无意义，这就叫贫血模型。  \n> 充血模型：由于DDD的设计思想就是把bean里面塞满各种各样的自身业务逻辑。使此bean所有的操作都能聚合在一个bean(domain)中。这就叫充血模型。","tags":["spring","代码规范"],"categories":["java","设计模式"]},{"title":"springBoot容器启动流程","url":"/posts/springboot容器启动流程/","content":"main方法启动时，springBoot启动流程的各个生命周期会以事件通知的方式，把事件告知其他程序  \n前期通过[spring-spi](/posts/spring-spi)获取所有监听事件的类   \n* spring启动的大体流程为以下的几个方法    \n```java\npublic class EventPublishingRunListener implements SpringApplicationRunListener {\n    ...\n    private final SimpleApplicationEventMulticaster initialMulticaster = new SimpleApplicationEventMulticaster();\n\n    public EventPublishingRunListener(SpringApplication application, String[] args) {\n        // 通过springSPI获取所有的ApplicationListener，并copy到initialMulticaster\n        // 如果ApplicationListener是以注解形式使用，非spi配置的。会在[refresh阶段](/posts/springBeanFactory流程解析)扫描所有以注解形式配置的listener\n        // 也就是说注解形式配置的listener，监听refresh之前的事件都是伪事件\n        for (ApplicationListener<?> listener : application.getListeners()) {\n            this.initialMulticaster.addApplicationListener(listener);\n        }\n    }\n    \n    // 1 开始\n    @Override\n    public void starting() {\n        this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));\n    }\n    \n    // 2 环境准备\n    @Override\n    public void environmentPrepared(ConfigurableEnvironment environment) {\n        this.initialMulticaster.multicastEvent(new ApplicationEnvironmentPreparedEvent(this.application, this.args, environment));\n    }\n    /**\n     protected void applyInitializers(ConfigurableApplicationContext context) {\n         for (ApplicationContextInitializer initializer : getInitializers()) {\n             Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),\n             ApplicationContextInitializer.class);\n             Assert.isInstanceOf(requiredType, context, \"Unable to call initializer.\");\n             initializer.initialize(context);\n         }\n     } \n     */\n\n    // prepared之前 会调用 mian方法启动的SpringApplication 内置的 initialize,如上面的注释的代码\n    // 3 上下文准备\n    @Override\n    public void contextPrepared(ConfigurableApplicationContext context) {\n        this.initialMulticaster.multicastEvent(new ApplicationContextInitializedEvent(this.application, this.args, context));\n    }\n    \n    // 4 上下文已加载\n    @Override\n    public void contextLoaded(ConfigurableApplicationContext context) {\n        for (ApplicationListener<?> listener : this.application.getListeners()) {\n            if (listener instanceof ApplicationContextAware) {\n                ((ApplicationContextAware) listener).setApplicationContext(context);\n            }\n            context.addApplicationListener(listener);\n        }\n        this.initialMulticaster.multicastEvent(new ApplicationPreparedEvent(this.application, this.args, context));\n    }\n    // contextLoaded之后 会调用 [context.refresh](/posts/springBeanFactory流程解析)，会实例化所有的bean(单例的、notLazy的)，包括以注解形式配置的listener\n\n    // 5 启动完成\n    @Override\n    public void started(ConfigurableApplicationContext context) {\n        // 在refresh阶段后，后续的事件会通过context发出，context持有beanFactory,beanFactory在refresh期间会扫描所有的listener。所以就不能仅仅调用spi配置的listener了\n        context.publishEvent(new ApplicationStartedEvent(this.application, this.args, context));\n        AvailabilityChangeEvent.publish(context, LivenessState.CORRECT);\n    }\n\n    // 6 运行中\n    @Override\n    public void running(ConfigurableApplicationContext context) {\n        // 通过context发出事件，context持有beanFactory,beanFactory会扫描所有的ApplicationListener。\n        context.publishEvent(new ApplicationReadyEvent(this.application, this.args, context));\n        AvailabilityChangeEvent.publish(context, ReadinessState.ACCEPTING_TRAFFIC);\n    }\n\n    @Override\n    public void failed(ConfigurableApplicationContext context, Throwable exception) {\n        ...\n    }\n    ...\n}\n```\n  \n> 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。\n\n# 启动流程\n\n## 1. starting -》ApplicationStartingEvent  \n正在进行时、代表容器刚开始运行了---发出程序开始事件  \nspringDevTools就是用到了此事件，把类加载器给换了一下，起到了热部署的作用，后期咱们会有详细的分析\n\n## 2. environmentPrepared -》ApplicationEnvironmentPreparedEvent  \n[配置环境变量加载配置文件资源等](/posts/分析spring的environment（配置文件）的加载)---发出环境配置已就绪事件  \nnacos和springCloud远程加载配置文件就是用到了此事件，后期咱们会有详细的分析  \n> 事件发出之后，马上就要实例化ApplicationContext了，不同的WebApplicationType，context不同   \n> **不管什么样的context，都会持有beanFactory,并且都会向beanFactory注册一个非常重要的bean  \n> 注册代码```AnnotationConfigUtils#registerAnnotationConfigProcessors```  \n> [=ConfigurationClassPostProcessor](/posts/解析spring是如何向beanFactory注册bean的)，在[beanFactory执行后置处理](/posts/springBeanFactory流程解析#4-调用beanfactorypostprocessors)时，会调用此类，并扫描所有的bean**  \n> 实例化完后会发布事情通知容器已经实例化，调用ApplicationContextInitializer的initialize\n\n## 3. contextPrepared -》ApplicationContextInitializedEvent    \n容器准备---发出应用程序上下文初始化事件  \n**contextPrepared之后springBoot会把main方法所在的类注册到beanFactory中**  \nbeanFactory在执行[beanFactory执行后置处理](/posts/springBeanFactory流程解析#4-调用beanfactorypostprocessors)时，会调用[ConfigurationClassPostProcessor  \nConfigurationClassPostProcessor通过扫描beanFactory所有注册的bean上的注解继而扫描其他的bean(包)](/posts/解析spring是如何向beanFactory注册bean的)\n\n## 4. contextLoaded -》ApplicationPreparedEvent  \n容器已加载完毕---发出应用程序已准备就绪事件\n> contextLoaded之后 会调用 context.refresh，会实例化所有的bean(单例的、notLazy的)  \n> refresh阶段比较复杂，基本上都是操作beanFactory完成bean的扫描、组装、初始化等逻辑  \n> beanFactory可参考[springBeanFactory流程解析](/posts/springBeanFactory流程解析)\n\n## 5. started -》ApplicationStartedEvent  \n发出应用程序已启动事件\n\n## 6. running -》ApplicationReadyEvent  \n运行中---发出程序已做完事件\n\n--failed -》ApplicationFailedEvent  \n启动失败时的事件处理器，spring默认就是打印日志。  \n我们可以实现此事件的监听，项目启动失败之后直接报警等\n\n\n# 总结\nApplicationContext这个是spring的容器（非常重要），启动的流程基本上都是围绕着他展开。  \n从各个事件的通知事件我们不难看出。从最开始的starting、environmentPrepared都是为applicationContext做准备。根据不同的WebType实例化不同的applicationContext，之后context会持有environment  \nenvironment包含了所有的配置文件  \n然后再以context为中心进行initialize事件的触发、然后contextPrepared、contextLoaded、context.refresh  \nrefresh工作比较复杂也是beanFactory的核心，具体可参考[springBeanFactory流程解析](/posts/springBeanFactory流程解析)\n最后在做结尾的工作started和running","tags":["源码","spring"],"categories":["java","spring"]},{"title":"获取spring启动环境的工具类","url":"/posts/获取spring启动环境的工具类/","content":"\n# 必须用到的枚举工具类\n* 参考通用枚举的---使用例子一 [通用枚举](/posts/通用枚举)  \n\n# 定义ENV枚举\n```java\n@Slf4j\npublic enum ENV implements IEnums<String> {\n    RELEASE(\"正式\", \"release\", \"prod\"),\n    PRE(\"预发\", \"pre\"),\n    TEST(\"测试\", \"test\", \"test1\", \"test2\", \"test3\"),\n    DEV(\"dev\", \"dev\"),\n    LOCAL(\"本地\", \"local\"),\n    ;\n\n    private final String[] envs;\n    private final String doc;\n\n    ENV(String doc, String... envs) {\n        this.envs = envs;\n        this.doc = doc;\n    }\n\n    private static ENV CURRENT_ENV;\n\n    private static void setCurrentEnv(ENV env) {\n        // 此变量不可随意改变，如有程序错乱，环境不一致就直接退出程序，避免后续的问题\n        if (CURRENT_ENV != null && CURRENT_ENV != env) {\n            System.out.println(\"ENV只能赋值一次，请查看spring容器配置是否正确\");\n            System.err.println(\"ENV只能赋值一次，请查看spring容器配置是否正确\");\n            log.error(\"ENV只能赋值一次，请查看spring容器配置是否正确\");\n            System.exit(1);\n        }\n        CURRENT_ENV = env;\n        System.out.println(\"当前启动环境:\" + CURRENT_ENV);\n        log.warn(\"当前启动环境:\" + CURRENT_ENV);\n    }\n\n    public static boolean isProd() {\n        return Objects.equals(getENV(), RELEASE);\n    }\n\n    public static boolean isDEV() {\n        return Objects.equals(getENV(), DEV);\n    }\n\n    public static boolean isDevOrTest() {\n        return isDEV() || Objects.equals(getENV(), TEST);\n    }\n\n    private static ENV getENV() {\n        Assert.notNull(CURRENT_ENV, \"环境还未初始化，请确认代码顺序\");\n        return CURRENT_ENV;\n    }\n\n    @Override\n    public String[] getIdentities() {\n        return envs;\n    }\n\n    @Override\n    public String getDoc() {\n        return doc;\n    }\n}\n```\n\n# 定义spring listener 推断程序的环境\n\n## 先要在factories文件配置此类的监听\n```properties\n# Run Listeners\norg.springframework.context.ApplicationListener=com.DecideENVProcessor\n```\n\n## java推断逻辑的代码\n\n[springBoot容器启动流程](/posts/springBoot容器启动流程)  \nApplicationContextInitializedEvent 事件是容器上下文准备初始化的时候进行调用，此事件代表之前的environment，已经初始化完毕  \n[environment主要流程解析](/posts/分析spring的environment（配置文件）的加载)  \n\n\n```java\npublic static class DecideENVProcessor implements ApplicationListener<ApplicationContextInitializedEvent> {\n\n    private static final AtomicBoolean initialized = new AtomicBoolean(false);\n\n    @Override\n    public void onApplicationEvent(ApplicationContextInitializedEvent event) {\n        ConfigurableEnvironment environment = event.getApplicationContext().getEnvironment();\n        // profiles多容器下有可能 会多次调用，头几次可能为空\n        if (environment.getActiveProfiles().length == 0) {\n            return;\n        }\n        // 命令行传递参数的active.profile 肯定不为空，多次调用的话要避免重复执行以下逻辑\n        if (!initialized.compareAndSet(false, true)) {\n            return;\n        }\n        ENV env = IEnums.getEnum(ENV.class, environment.getActiveProfiles()[0], RELEASE);\n        ENV.setCurrentEnv(env);\n    }\n}\n```\n这样在ApplicationContextInitializedEvent事件之后的逻辑，直接调用枚举Env，用来处理不同的业务逻辑即可。  \n虽然直接用\n```java\n@Autowired\nEnvironment env;\n\nboolean isDev = Objects.eqalse(\"dev\", env.getActiveProfiles()[0]);\n```\n也能实现，但是这用容易写错，后期也不易于维护。更多的缺点你懂得。。。\n\n# 总结\n我们用通用枚举实现配置我们各个不同的环境的env枚举。\n然后再监听spring 容器启动事件，获取Environment的activeProfiles，存到上下文当中，这样我们在后续的工作后期写代码中，用起来特别的方便。","tags":["源码","spring"],"categories":["java","spring"]},{"title":"分析spring的Environment（配置文件）的加载","url":"/posts/分析spring的environment（配置文件）的加载/","content":"\n项目立项->开发->测试->维护->上线->维护，这几个过程中分为不同的环境。不同的环境不同业务有着不同的逻辑。  \nspring完美支持启动的时候加载不同的配置文件。我们通过指定不同的spring.profiles.active即可实现加载不同的配置文件。  \n不管怎么样默认会加载如下几个配置文件   \n```java\npublic class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered {\n    ...\n    // Note the order is from least to most specific (last one wins)\n    private static final String DEFAULT_SEARCH_LOCATIONS = \"classpath:/,classpath:/config/,file:./,file:./config/*/,file:./config/\";\n\n    private static final String DEFAULT_NAMES = \"application\";\n    ...\n}\npublic class PropertiesPropertySourceLoader implements PropertySourceLoader {\n    ...\n    @Override\n    public String[] getFileExtensions() {\n        return new String[]{\"properties\", \"xml\"};\n    }\n    ...\n}\npublic class YamlPropertySourceLoader implements PropertySourceLoader {\n\n    @Override\n    public String[] getFileExtensions() {\n        return new String[]{\"yml\", \"yaml\"};\n    }\n}\n```\n5个位置，一个名称，4个后缀，总共有多少种组合？（还没有profile情况下😁）\n\n# 加载流程\n[springBoot容器启动流程](/posts/springBoot容器启动流程)\n\n## springListener\nspring factories 配置了容器启动的监听类  \n```properties\n# Application Listeners\norg.springframework.context.ApplicationListener=\\\n...\norg.springframework.boot.context.config.ConfigFileApplicationListener,\\\n...\n```\n\n此监听类又独自搞了一套EnvironmentPostProcessor，同样也是用的spring spi机制来处理\n```java\npublic class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered {\n\n    /**\n     * The default order for the processor.\n     */\n    public static final int DEFAULT_ORDER = Ordered.HIGHEST_PRECEDENCE + 10;\n    ...\n\n    // 监听spring boot容器的事件\n    public void onApplicationEvent(ApplicationEvent event) {\n        if (event instanceof ApplicationEnvironmentPreparedEvent) {\n            // 调用 独自搞的EnvironmentPostProcessor\n            onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);\n        }\n        if (event instanceof ApplicationPreparedEvent) {\n            onApplicationPreparedEvent(event);\n        }\n    }\n    \n    private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {\n        // 根据spring spi 找出environment处理类\n        List<EnvironmentPostProcessor> postProcessors = SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader());\n        // 添加self\n        postProcessors.add(this);\n        // 排序如果有比DEFAULT_ORDER优先级高的那么会优先处理。\n        AnnotationAwareOrderComparator.sort(postProcessors);\n        for (EnvironmentPostProcessor postProcessor : postProcessors) {\n            // 进行处理\n            postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());\n        }\n    }\n\n    // self postProcessEnvironment\n    public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {\n        RandomValuePropertySource.addToEnvironment(environment);\n        // 核心loader逻辑。下如下代码\n        new Loader(environment, application.getResourceLoader()).load();\n    }\n    ...\n}\n```\n\n\n## 真正加载的逻辑\n\n```java\nprivate class Loader {\n\n    private final ConfigurableEnvironment environment;\n\n    private final PropertySourcesPlaceholdersResolver placeholdersResolver;\n\n    private final ResourceLoader resourceLoader;\n\n    private final List<PropertySourceLoader> propertySourceLoaders;\n\n    private Deque<Profile> profiles;\n\n    private List<Profile> processedProfiles;\n\n    private boolean activatedProfiles;\n\n    private Map<Profile, MutablePropertySources> loaded;\n\n    private Map<DocumentsCacheKey, List<Document>> loadDocumentsCache = new HashMap<>();\n\n    Loader(ConfigurableEnvironment environment, ResourceLoader resourceLoader) {\n        this.environment = environment;\n        this.placeholdersResolver = new PropertySourcesPlaceholdersResolver(this.environment);\n        this.resourceLoader = (resourceLoader != null) ? resourceLoader : new DefaultResourceLoader(null);\n        this.propertySourceLoaders = SpringFactoriesLoader.loadFactories(PropertySourceLoader.class,\n                getClass().getClassLoader());\n    }\n\n    void load() {\n        // 排除 defaultProperties资源里面的spring.profiles.active|include属性\n        FilteredPropertySource.apply(this.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,\n                (defaultProperties) -> {\n                    this.profiles = new LinkedList<>();\n                    this.processedProfiles = new LinkedList<>();\n                    this.activatedProfiles = false;\n                    this.loaded = new LinkedHashMap<>();\n                    // 初始化profile,非命令行传递的active的参数，profiles会有两个，一个是null，一个是default\n                    // 意思是直接搜索application名字的资源，以及application-default的资源（如果命令行参数指定了active则不会有default）\n                    initializeProfiles();\n                    // 循环加载不同的profile\n                    while (!this.profiles.isEmpty()) {\n                        Profile profile = this.profiles.poll();\n                        if (isDefaultProfile(profile)) {\n                            addProfileToEnvironment(profile.getName());\n                        }\n                        // 配合5个位置，1个名称，4个后缀，加载不同的profile。\n                        // 加载当前的profile，如果遇到新的spring.profiles.active|include属性，则会再次添加到profiles里，继续while循环加载\n                        load(profile, this::getPositiveProfileFilter,\n                                addToLoaded(MutablePropertySources::addLast, false));\n                        /* \n                         * this::getPositiveProfileFilter：\n                         * yml配置文件 支持 '---' 用来分隔配置，此方法就是用来判断是否可以加载分隔的内容\n                         * 如果分割的内容中有spring.profiles，但是spring还未加载过的话，spring是不支持加载此内容的\n                         * 具体可移步org.springframework.boot.context.config.ConfigFileApplicationListener.Loader#asDocuments\n                         */\n                        \n                        /*\n                         * addToLoaded(MutablePropertySources::addLast, false)\n                         * 顾名思义，把profile找到的source无条件的加载到这个字段里：Map<Profile, MutablePropertySources> loaded;\n                         */\n                        \n                        this.processedProfiles.add(profile);\n                    }\n                    // yml配置文件 支持 '---' 用来分隔配置，此方法就是优先加载 (5个位置，1个名称，4个后缀)的文件里面的分隔内容\n                    load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true));\n                    // 把加载的资源配置到spring的environment里面\n                    addLoadedPropertySources();\n                    // environment.setActiveProfiles\n                    applyActiveProfiles(defaultProperties);\n                });\n    }\n}\n```\n至此代码分析完毕，如果想看更细节的东西，请移步至org.springframework.boot.context.config.ConfigFileApplicationListener.Loader#load()\n\n## 总结\n通过监听springEnvironment事件，然后用spring SPI找出所有的EnvironmentPostProcessor  \nLoad类为加载配置文件的类。它的逻辑主要分为  \n1.初始化profile(包含null,以及未指定命令行参数的active时用defaultProfile)  \n2.循环profile加载（5个位置、1个名称、4个后缀）的文件  \n3.把加载的资源配置到spring的environment里面  \n4.setActiveProfiles","tags":["源码","spring"],"categories":["java","spring"]},{"title":"java如何优雅的打印log","url":"/posts/java如何优雅的打印log/","content":"\n1 用sl4j（采用门面模式，不提供实现，且提供占位符打印的方式）  \n2 过长的内容没有意义，[集合最多打印几十个](#限制序列化的长度)  \n3 如果有字符串拼接或者toJSON的情况，打印log之前判断该级别是否开启，不然会白白浪费cpu  \n4 对于第3点可优化的地方，用下面的util，配合着sl4j，这样就不用写判断日志级别是否开启的代码了  \n```java\npublic abstract class LogUtils {\n\n    public static LogUtils lazyJson(Object object) {\n        return new LogUtils() {\n            String json = null;\n            @Override\n            // 只有在输出的时候在toJSON，并且如果是集合的类型限制最多输出100个\n            public String toString() {\n                return json != null ? json : (json = JSON.toJSONString(object, JSONMaxSerializeConfig.MAX_100_SERIALIZE_CONFIG));\n            }\n        };\n    }\n}\n```\n例如：\n```java\nlog.info(\"我要打印一个实体，想在开启info级别的情况下toJSON，还不想写if代码，并且实体里面有集合类型字段的话，最多输出100长度即可：{}\", LogUtils.lazyJson(实体));\n```\n\n# 限制序列化的长度  \n日志过多过长也就没有了意义，所以如果是集合类型，我们只打印前100几个，输出过多的日志非常影响服务器性能  \n```java\n// 序列化限制集合的长度\n@Slf4j\npublic class JSONMaxSerializeConfig extends SerializeConfig {\n\n    // 常量-最多序列化100个集合\n    // 用法 JSON.toJSONString(object, MAX_100_SERIALIZE_CONFIG)\n    public static final JSONMaxSerializeConfig MAX_100_SERIALIZE_CONFIG = new JSONMaxSerializeConfig(100);\n\n    private final int MAX_SERIALIZE_NUM;\n\n    public JSONMaxSerializeConfig(int MAX_SERIALIZE_NUM) {\n        super(true);// 不使用ASM，以field类型为基础进行序列化，不然无法使用当前ObjectSerializer\n        this.MAX_SERIALIZE_NUM = MAX_SERIALIZE_NUM;\n        this.register(new Module() {\n\n            @Override\n            public ObjectDeserializer createDeserializer(ParserConfig parserConfig, Class aClass) {\n                return null;\n            }\n\n            @Override\n            public ObjectSerializer createSerializer(SerializeConfig serializeConfig, Class aClass) {\n\n                if (AbstractList.class.isAssignableFrom(aClass)) {\n                    return ABSTRACT_LIST_SERIALIZER;\n                }\n\n                if (AbstractSet.class.isAssignableFrom(aClass)) {\n                    return ABSTRACT_SET_SERIALIZER;\n                }\n                // map类型长度限制是否需要限制？\n                return null;\n            }\n        });\n    }\n\n\n    private final ObjectSerializer ABSTRACT_LIST_SERIALIZER = (jsonSerializer, o, o1, type, i) -> {\n        AbstractList<?> list = (AbstractList<?>) o;\n        ListSerializer.instance.write(jsonSerializer, new AbstractList<Object>() {\n            public int size() {\n                if (list.size() > MAX_SERIALIZE_NUM) {\n                    log.warn(\"序列化输出已超出最大限制，后续的序列化将要舍弃，实际大小:{}, max:{}\", list.size(), MAX_SERIALIZE_NUM);\n                }\n                return Math.min(list.size(), MAX_SERIALIZE_NUM);\n            }\n\n            public Object get(int index) {\n                return list.get(index);\n            }\n        }, o1, type, i);\n    };\n\n    private final ObjectSerializer ABSTRACT_SET_SERIALIZER = (jsonSerializer, o, o1, type, i) -> {\n        @SuppressWarnings(\"unchecked\")\n        AbstractSet<Object> set = (AbstractSet<Object>) o;\n        CollectionCodec.instance.write(jsonSerializer, new AbstractSet<Object>() {\n            public Iterator<Object> iterator() {\n                return new Iterator<Object>() {\n                    final Iterator<?> originIterator = set.iterator();\n                    int count = 1;\n\n                    public boolean hasNext() {\n                        count++;\n                        if (count > MAX_SERIALIZE_NUM) {\n                            log.warn(\"序列化输出已超出最大限制，后续的序列化将要舍弃, max:{}\", MAX_SERIALIZE_NUM);\n                        }\n                        return count <= MAX_SERIALIZE_NUM && originIterator.hasNext();\n                    }\n\n                    public Object next() {\n                        return originIterator.next();\n                    }\n                };\n            }\n\n            public int size() {\n                return Math.min(set.size(), MAX_SERIALIZE_NUM);\n            }\n        }, o1, type, i);\n    };\n}\n```","tags":["log"],"categories":["java","log"]},{"title":"重新加装MybatisPlus","url":"/posts/重新加装mybatisplus/","content":"\n# 1.字段填充器\n\n注意重写了`strictFill`方法  \n统一规范，字段填充的值和类型所有的表都一样。所以不作类型判断。\n```java\n@Component\npublic class FieldAutoFillHandler implements MetaObjectHandler {\n\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        User user = CurrentUser.getCurrentUser();\n\n        this.strictInsertFill(metaObject, \"deleteFlag\", null, DeleteFlag.N);\n        this.strictInsertFill(metaObject, \"isDelete\", null, DeleteFlag.N);\n\n        this.strictInsertFill(metaObject, \"createUserId\", null, user.getUserId());\n        this.strictInsertFill(metaObject, \"creatorUserId\", null, user.getUserId());\n\n        this.strictInsertFill(metaObject, \"createUserName\", null, user.getUserName());\n        this.strictInsertFill(metaObject, \"creatorUserName\", null, user.getUserName());\n\n        this.strictInsertFill(metaObject, \"createTime\", null, LocalDateTime.now());\n    }\n\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        User user = CurrentUser.getCurrentUser();\n\n        this.strictUpdateFill(metaObject, \"updateTime\", null, LocalDateTime.now());\n        this.strictUpdateFill(metaObject, \"updateUserId\", null, user.getUserId());\n        this.strictUpdateFill(metaObject, \"updateUserName\", null, user.getUserName());\n    }\n\n    /**\n     * 重写自动填充的逻辑\n     * 只要有该字段、且字段为空、则填充\n     */\n    @Override\n    public MetaObjectHandler strictFill(boolean insertFill, TableInfo tableInfo, MetaObject metaObject, List<StrictFill> strictFills) {\n\n        strictFills.forEach(i -> {\n            final String fieldName = i.getFieldName();\n            if (!metaObject.hasSetter(fieldName)) {\n                return;\n            }\n            if (metaObject.getValue(fieldName) != null) {\n                return;\n            }\n            Object value = i.getFieldVal().get();\n            if (value == null) {\n                return;\n            }\n            metaObject.setValue(fieldName, value);\n        });\n        return this;\n    }\n\n}\n```\n\n## 原理\n\n* 最终调用了`insertFill`或者`updateFill`  \n    ```java\n    // 调用MybatisPlus 的 ibatis代码\n    public abstract class BaseStatementHandler implements StatementHandler {\n        protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {\n            。。。\n            // 就是在这里调用了MybatisPlus的填充逻辑\n            this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);\n            。。。\n        }\n    }\n    \n    // MybatisPlus的参数处理程序\n    public class MybatisDefaultParameterHandler extends DefaultParameterHandler {\n    \n        private final TypeHandlerRegistry typeHandlerRegistry;\n        private final MappedStatement mappedStatement;\n        private final Object parameterObject;\n        private final BoundSql boundSql;\n        private final Configuration configuration;\n    \n        public MybatisDefaultParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {\n            // processParameter 处理参数\n            super(mappedStatement, processParameter(mappedStatement, parameterObject), boundSql);\n            。。。\n        }\n    \n        protected static Object processParameter(MappedStatement ms, Object parameterObject) {\n            if (parameterObject != null &&\n                (SqlCommandType.INSERT == ms.getSqlCommandType() || SqlCommandType.UPDATE == ms.getSqlCommandType())\n            ) {\n                。。。\n                Collection<Object> parameters = getParameters(parameterObject);\n                if (null != parameters) {\n                    parameters.forEach(obj -> process(ms, obj));\n                } else {\n                    process(ms, parameterObject);\n                }\n            }\n            return parameterObject;\n        }\n    \n        private static void process(MappedStatement ms, Object parameterObject) {\n            TableInfo tableInfo;\n            ...\n            if (tableInfo != null) {\n                MetaObject metaObject = ms.getConfiguration().newMetaObject(entity);\n                if (SqlCommandType.INSERT == ms.getSqlCommandType()) {\n                    populateKeys(tableInfo, metaObject, entity);\n                    // 最终填充\n                    insertFill(metaObject, tableInfo);\n                } else {\n                    // 最终填充\n                    updateFill(metaObject, tableInfo);\n                }\n            }\n        }\n    }\n    ```\n\n# 2.[批量|单个]软删除使自动填充器生效（默认不生效）\nmybatisPlus 使用`@TableLogic`注解在字段上，表示当前表软删除，当前字段为软删除字段    \n正常调用删除的API即可软删除。但是缺点是：并不会使字段填充器生效  \n目前我用的3.3.2有单个的软删除使字段填充器生效，但是批量的没有  \n批量软删除参考批量删除的方法  \n\n* mybatisPlus在初始化的时候会给每个表添加通用的Statement映射\n* 批量软删除需要再加一个参数，总共两个参数，一个是实体(不然字段填充器往哪里填？)，一个是删除的idList集合，所以需要从新定义一个方法\n\n## 自定义批量软删除的代码\n```java\n// mapper新增一个方法\nint deleteBatchIdsWithFill(@Param(Constants.ENTITY) T t, @Param(Constants.COLLECTION) Collection<? extends Serializable> idList);\n\n// 具体statement实现\npublic class LogicBatchDeleteWithFill extends AbstractMethod {\n\n    // mapper的方法名\n    private static final String MAPPER_METHOD = \"deleteBatchIdsWithFill\";\n\n    @Override\n    public MappedStatement injectMappedStatement(Class<?> mapperClass, Class<?> modelClass, TableInfo tableInfo) {\n        // 如果表不是逻辑删除，则复用SqlMethod.DELETE_BATCH_BY_IDS\n        if (!tableInfo.isLogicDelete()) {\n            String sql = String.format(SqlMethod.DELETE_BATCH_BY_IDS.getSql()\n                    , tableInfo.getTableName()\n                    , tableInfo.getKeyColumn()\n                    , SqlScriptUtils.convertForeach(\"#{item}\", Constants.COLLECTION, null, \"item\", COMMA)\n            );\n            SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, Object.class);\n            return this.addDeleteMappedStatement(mapperClass, MAPPER_METHOD, sqlSource);\n        }\n\n        // 引用批量删除的sql\n        SqlMethod sqlMethod = SqlMethod.LOGIC_DELETE_BATCH_BY_IDS;\n\n        // 找出是需要记录更新的字段\n        List<TableFieldInfo> fieldInfos = tableInfo.getFieldList().stream()\n                .filter(TableFieldInfo::isWithUpdateFill)\n                .collect(toList());\n        String sql;\n        if (CollectionUtils.isNotEmpty(fieldInfos)) {\n            // 这里是重点，把mapper新定义的方法第一个参数作为前缀，把需要更新的字段拼到sql中\n            String sqlSet = \"SET \" + fieldInfos.stream().map(i -> i.getSqlSet(Constants.ENTITY_DOT)).collect(joining(EMPTY))\n                    + tableInfo.getLogicDeleteSql(false, false);\n            sql = String.format(sqlMethod.getSql()\n                    , tableInfo.getTableName()\n                    , sqlSet, tableInfo.getKeyColumn()\n                    , SqlScriptUtils.convertForeach(\"#{item}\", Constants.COLLECTION, null, \"item\", COMMA)\n                    , tableInfo.getLogicDeleteSql(true, true)\n            );\n        } else {\n            sql = String.format(sqlMethod.getSql()\n                    , tableInfo.getTableName()\n                    , sqlLogicSet(tableInfo)\n                    , tableInfo.getKeyColumn()\n                    , SqlScriptUtils.convertForeach(\"#{item}\", Constants.COLLECTION, null, \"item\", COMMA)\n                    , tableInfo.getLogicDeleteSql(true, true)\n            );\n        }\n        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);\n        return this.addUpdateMappedStatement(mapperClass, modelClass, MAPPER_METHOD, sqlSource);\n    }\n}\n```\n\n## 最后需要把sql映射的工具类添加到Spring容器中哦\n```java\n @Bean\npublic AbstractSqlInjector customSqlMethod() {\n    List<AbstractMethod> allMethodList = new ArrayList<>();\n    //单个删除withFillApi（3.3.2自带）\n    allMethodList.add(new LogicDeleteByIdWithFill());\n    //批量删除withFillApi\n    allMethodList.add(new LogicBatchDeleteWithFill());\n    // 默认的api\n    allMethodList.addAll(new DefaultSqlInjector().getMethodList(null));\n    return new AbstractSqlInjector() {\n        @Override\n        public List<AbstractMethod> getMethodList(Class<?> mapperClass) {\n            return allMethodList;\n        }\n    };\n}\n```\n\n> 使用的话一定要使用mapper新定义的方法哦\n\n大功告成\n\n# 3.MybatisPlus查询软删除的数据\n批量软删除，我们已经完美的实现，字段填充器也可以生效。但有些业务需要查询已经删除的数据，mybatisPlus目前还没有对应的方法，只能自己实现了。\n\n## 首先定义方法到mapper里面\n```java\n\n// BaseDomain是我们数据库实体的父类\npublic interface CustomBaseMapper<T extends BaseDomain<? extends Serializable>> extends BaseMapper<T> {\n\n    /**\n     * 查询数据忽略已经删除的数据\n     * ps: 如果有逻辑删除的话\n     */\n    List<T> selectListIgnoreDeleted(@Param(Constants.WRAPPER) Wrapper<T> wrapper);\n\n    /**\n     * 查询数据忽略已经删除的数据\n     * ps: 如果有逻辑删除的话\n     */\n    T selectOneIgnoreDeleted(@Param(Constants.WRAPPER) Wrapper<T> wrapper);\n\n    /**\n     * 根据 ID 查询忽略已经删除的数据\n     * ps: 如果有逻辑删除的话\n     */\n    T selectByIdIgnoreDeleted(Serializable id);\n\n    /**\n     * 查询（根据ID 批量查询）忽略已经删除的数据\n     * ps: 如果有逻辑删除的话\n     */\n    List<T> selectBatchIdsIgnoreDeleted(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);\n}\n```\n\n## 然后定义这些个方法的实现\n\n**有用动态代理啊[动态代理](/posts/javaUtil动态代理)**\n\n\n```java\n/**\n * 查询单个时忽略已删除的数据\n * ps:如果有逻辑删除的话\n */\npublic static class SelectOneIgnoreDeleted extends AbstractMethod {\n\n    private static final String MAPPER_METHOD = \"selectOneIgnoreDeleted\";\n\n    @Override\n    public MappedStatement injectMappedStatement(Class<?> mapperClass, Class<?> modelClass, TableInfo tableInfo) {\n\n        // DynamicProxy为本文的动态代理\n        // 和源码最重要的不同点是，这里直接忽略逻辑删除 \n        TableInfo ignoreDeleteLogic = new DynamicProxy<>(tableInfo, Object.class)\n                .getProxy((target, proxyMethod, args, originMethod) -> {\n                    // 忽略逻辑删除\n                    if (originMethod.getName().equals(\"isLogicDelete\")) {\n                        // 直接返回false\n                        return false;\n                    }\n                    return proxyMethod.invoke(target, args);\n                });\n\n        String formatted = String.format(SqlMethod.SELECT_ONE.getSql()\n                , sqlFirst()\n                , sqlSelectColumns(tableInfo, true)\n                , tableInfo.getTableName()\n                , sqlWhereEntityWrapper(true, ignoreDeleteLogic)\n                , sqlComment()\n        );\n\n        SqlSource sqlSource = languageDriver.createSqlSource(configuration, formatted, modelClass);\n\n        return this.addSelectMappedStatementForTable(mapperClass, MAPPER_METHOD, sqlSource, tableInfo);\n    }\n}\n\n/**\n * 查询单个id时忽略已删除的数据\n * ps:如果有逻辑删除的话\n */\npublic static class SelectByIdIgnoreDeleted extends AbstractMethod {\n\n    private static final String MAPPER_METHOD = \"selectByIdIgnoreDeleted\";\n\n    @Override\n    public MappedStatement injectMappedStatement(Class<?> mapperClass, Class<?> modelClass, TableInfo tableInfo) {\n\n        String formatted = String.format(SqlMethod.SELECT_BY_ID.getSql()\n                , sqlSelectColumns(tableInfo, false)\n                , tableInfo.getTableName(), tableInfo.getKeyColumn(), tableInfo.getKeyProperty()\n                // 和源码最重要的不同点是这里不拼接逻辑删除的sql\n                , EMPTY\n        );\n\n        SqlSource sqlSource = new RawSqlSource(configuration, formatted, Object.class);\n        return this.addSelectMappedStatementForTable(mapperClass, MAPPER_METHOD, sqlSource, tableInfo);\n    }\n}\n\n/**\n * 查询多个id时忽略已删除的数据\n * ps:如果有逻辑删除的话\n */\npublic static class SelectBatchByIdsIgnoreDeleted extends AbstractMethod {\n\n    private static final String MAPPER_METHOD = \"selectBatchIdsIgnoreDeleted\";\n\n    @Override\n    public MappedStatement injectMappedStatement(Class<?> mapperClass, Class<?> modelClass, TableInfo tableInfo) {\n        String sqlFormatted = String.format(SqlMethod.SELECT_BATCH_BY_IDS.getSql()\n                , sqlSelectColumns(tableInfo, false)\n                , tableInfo.getTableName()\n                , tableInfo.getKeyColumn()\n                , SqlScriptUtils.convertForeach(\"#{item}\", COLLECTION, null, \"item\", COMMA)\n                // 和源码最重要的不同点是这里不拼接逻辑删除的sql\n                , EMPTY\n        );\n        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sqlFormatted, Object.class);\n        return addSelectMappedStatementForTable(mapperClass, MAPPER_METHOD, sqlSource, tableInfo);\n    }\n}\n\n/**\n * 查询列表时忽略已删除的数据\n * ps:如果有逻辑删除的话\n */\npublic static class SelectListIgnoreDeleted extends AbstractMethod {\n\n    private static final String MAPPER_METHOD = \"selectListIgnoreDeleted\";\n\n    @Override\n    public MappedStatement injectMappedStatement(Class<?> mapperClass, Class<?> modelClass, TableInfo tableInfo) {\n\n        // 和源码最重要的不同点是，这里直接忽略逻辑删除\n        TableInfo ignoreDeleteLogic = new DynamicProxy<>(tableInfo, Object.class)\n                .getProxy((target, proxyMethod, args, originMethod) -> {\n                    if (originMethod.getName().equals(\"isLogicDelete\")) {\n                        // 直接返回false\n                        return false;\n                    }\n                    return proxyMethod.invoke(target, args);\n                });\n\n        String sql = String.format(SqlMethod.SELECT_LIST.getSql()\n                , sqlFirst()\n                , sqlSelectColumns(tableInfo, true)\n                , tableInfo.getTableName()\n                , sqlWhereEntityWrapper(true, ignoreDeleteLogic)\n                , sqlComment()\n        );\n\n        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);\n        return this.addSelectMappedStatementForTable(mapperClass, MAPPER_METHOD, sqlSource, tableInfo);\n    }\n}\n```\n\n## 绑定statement\n```java\n\n    @Bean\n    public AbstractSqlInjector customSqlMethod() {\n        List<AbstractMethod> allMethodList = new ArrayList<>();\n        // 默认的api\n        allMethodList.addAll(new DefaultSqlInjector().getMethodList(null));\n\n        // 新增的api\n        List<AbstractMethod> methodList = Stream.of(\n                new SelectByIdIgnoreDeleted(),\n                new SelectBatchByIdsIgnoreDeleted(),\n                new SelectOneIgnoreDeleted(),\n                new SelectListIgnoreDeleted()\n        ).collect(toList());\n\n        allMethodList.addAll(allMethodList);\n        return new AbstractSqlInjector() {\n                @Override\n                public List<AbstractMethod> getMethodList(Class<?> mapperClass) {\n                    return allMethodList;\n                }\n        };\n    }\n```\n\n至此完成SQL的statement绑定，然后具体业务继承CustomBaseMapper即可享用啦\n\n# 4.避免字符串编码\nlambda语法已经帮我们解决了字符串编码的问题，但是非lambda的api，他的参数只支持接受字符串，那么我们如何避免字符串呢？  \n参考[Lambda转字符串](/posts/mybatisPlus分析Lambda语法原理)\n我们也可以自定义lambda转字符串\n```java\n/**\n * api获取字段名\n * 避免面向字符串编程\n */\npublic static <T> String cts(SFunction<T, ?> column) {\n    return columnToString(column);\n}\n\npublic static <T> String columnToString(SFunction<T, ?> column) {\n    // mybatisPlus自带的api\n    SerializedLambda resolve = LambdaUtils.resolve(column);\n    return org.apache.ibatis.reflection.property.PropertyNamer.methodToProperty(resolve.getImplMethodName());\n}\n```\n这样我们在其他地方也可以用lambda转字段的语法了\n\n# 5.避免空指针，使api操作更安全\n\n集成以上所有的特性到一个类中作为一个baseDao。  \n实际项目中一个表对应一个实体，一个mapper，当然也需要一个Dao，继承此Dao就可以顺心的使用了。  \n我们Dao的职责就是用来拼接sql的。避免sql东一处西一处，不好维护。强制校验把sql写在Dao类中👉[MybatisPlus语法糖的校验](/posts/MybatisPlus语法糖的校验)\n然后service的业务代码，调用Dao写好的sql即可。**service层不关心sql**。\n\n```java\n/**\n * 和业务无关，所有数据库表的Dao继承此类\n * manger基类 （ 泛型：M 是 mapper 对象，T 是数据库实体 ）\n * 1：修改原有的api，使api操作更安全\n * 2：逻辑删除时使用填充删除\n * 3: lambda转换成字段名，可以随时随地用啦\n */\npublic abstract class BaseDao<M extends CustomBaseMapper<T>, T extends BaseDomain<? extends Serializable>> extends ServiceImpl<M, T> {\n\n    /**\n     * 简写方法名\n     */\n    public static <T> String cts_(SFunction<T, ?> column) {\n        return columnToStringUnderline(column);\n    }\n\n    /**\n     * api获取字段名并且驼峰变下划线\n     */\n    private static <T> String columnToStringUnderline(SFunction<T, ?> column) {\n        return StringUtils.camelToUnderline(columnToString(column));\n    }\n\n    /**\n     * 简写方法名\n     */\n    public static <T> String cts(SFunction<T, ?> column) {\n        return columnToString(column);\n    }\n\n    /**\n     * api获取字段名\n     * 避免面向字符串编程\n     */\n    private static <T> String columnToString(SFunction<T, ?> column) {\n        SerializedLambda resolve = LambdaUtils.resolve(column);\n        return PropertyNamer.methodToProperty(resolve.getImplMethodName());\n    }\n\n\n    private final Class<T> entityClass = currentModelClass();\n\n    // 增加统一校验id的方法\n    public T checkId(Serializable id) throws BizException {\n        return checkId(id, false);\n    }\n\n    public T checkId(Serializable id, boolean ignoreDeleted) throws BizException {\n        T byId = ignoreDeleted ? getByIdIgnoreDeleted(id) : getById(id);\n        if (byId == null) {\n            throw new BizException(\"数据：\" + id + \"不存在\");\n        }\n        return byId;\n    }\n\n    /*\n     * 如果条件为空一律返回null，禁止抛出异常\n     */\n    @Override\n    public T getById(Serializable id) {\n        if (id == null) {\n            return null;\n        }\n        return super.getById(id);\n    }\n\n    public T getByIdIgnoreDeleted(Serializable id) {\n        if (id == null) {\n            return null;\n        }\n        return getBaseMapper().selectByIdIgnoreDeleted(id);\n    }\n\n    // 调用软删除\n    @Override\n    public boolean removeById(Serializable id) {\n        T baseDomain = BeanUtils.instantiateClass(entityClass);\n        //noinspection unchecked\n        ((BaseDomain<Serializable>) baseDomain).setId(id);\n        return SqlHelper.retBool(getBaseMapper().deleteByIdWithFill(baseDomain));\n    }\n\n    @Override\n    public boolean removeByIds(Collection<? extends Serializable> idList) {\n        T t = BeanUtils.instantiateClass(entityClass);\n        return SqlHelper.retBool(getBaseMapper().deleteBatchIdsWithFill(t, idList));\n    }\n\n    /**\n     * 所有的list 如果条件为空一律返回空的list\n     */\n    @Override\n    public List<T> listByIds(Collection<? extends Serializable> idList) {\n        if (CollectionUtils.isEmpty(idList)) {\n            return Collections.emptyList();\n        }\n        return super.listByIds(idList);\n    }\n\n    /**\n     * 所有的list 如果条件为空一律返回空的list\n     */\n    public List<T> listByIdsIgnoreDeleted(Collection<? extends Serializable> idList) {\n        if (CollectionUtils.isEmpty(idList)) {\n            return Collections.emptyList();\n        }\n        return getBaseMapper().selectBatchIdsIgnoreDeleted(idList);\n    }\n\n    public T getOneIgnoreDeleted(Wrapper<T> queryWrapper) {\n        return getOneIgnoreDeleted(queryWrapper, true);\n    }\n\n    /**\n     * 根据 Wrapper，查询一条记录\n     */\n    public T getOneIgnoreDeleted(Wrapper<T> queryWrapper, boolean throwEx) {\n        if (throwEx) {\n            return getBaseMapper().selectOneIgnoreDeleted(queryWrapper);\n        }\n        return SqlHelper.getObject(log, getBaseMapper().selectListIgnoreDeleted(queryWrapper));\n    }\n\n    /**\n     * 查询条件忽略已经删除的数据(如果是逻辑删除的话)\n     */\n    public LambdaQueryChainWrapper<T> lambdaQueryIgnoreDeleted() {\n        return new LambdaQueryChainWrapper<T>(getBaseMapper()) {\n            boolean haveNullValueOfIn = false;// in条件是否有空的list\n\n            {\n                super.wrapperChildren = new LambdaQueryWrapper<T>() {\n                    // 为空则不添加此条件\n                    @Override\n                    public LambdaQueryWrapper<T> in(boolean condition, SFunction<T, ?> column, Collection<?> coll) {\n                        if (CollectionUtils.isEmpty(coll)) {\n                            haveNullValueOfIn = true;// true，直接返回，不增加这个in条件\n                            return typedThis;\n                        } else {\n                            return super.in(condition, column, coll);\n                        }\n                    }\n                };\n            }\n\n            @Override\n            public List<T> list() {\n                if (haveNullValueOfIn) {\n                    return Collections.emptyList();\n                }\n                // 调用忽略逻辑删除的列表api\n                return BaseDao.this.getBaseMapper().selectListIgnoreDeleted(wrapperChildren);\n            }\n        };\n\n    }\n\n    /**\n     * LambdaQuery中，条件有in，并且条件为空，一律返回空的list\n     */\n    @Override\n    public LambdaQueryChainWrapper<T> lambdaQuery() {\n        return new LambdaQueryChainWrapper<T>(getBaseMapper()) {\n            boolean haveNullValueOfIn = false;// in条件是否有空的list\n\n            {\n                super.wrapperChildren = new LambdaQueryWrapper<T>() {\n                    // 为空则不添加此条件\n                    @Override\n                    public LambdaQueryWrapper<T> in(boolean condition, SFunction<T, ?> column, Collection<?> coll) {\n                        if (CollectionUtils.isEmpty(coll)) {\n                            haveNullValueOfIn = true;// true，直接返回，不增加这个in条件\n                            return typedThis;\n                        } else {\n                            return super.in(condition, column, coll);\n                        }\n                    }\n                };\n            }\n\n            @Override\n            public List<T> list() {\n                if (haveNullValueOfIn) {\n                    return Collections.emptyList();\n                }\n                return super.list();\n            }\n        };\n    }\n\n    /**\n     * query中，条件有且只有一个in，并且条件为空，一律返回空的list\n     */\n    @Override\n    public QueryChainWrapper<T> query() {\n        return new QueryChainWrapper<T>(getBaseMapper()) {\n            // in条件是否有空的list\n            boolean haveNullValueOfIn = false;\n            // 只有in的条件\n            boolean onlyInCondition = true;\n\n            {\n                super.wrapperChildren = new QueryWrapper<T>() {\n                    // 为空则不添加此条件\n                    @Override\n                    public QueryWrapper<T> in(boolean condition, String column, Collection<?> coll) {\n                        if (CollectionUtils.isEmpty(coll)) {\n                            haveNullValueOfIn = true;// true，直接返回，不增加这个in条件\n                            return typedThis;\n                        } else {\n                            return super.in(condition, column, coll);\n                        }\n                    }\n\n                    @Override\n                    protected QueryWrapper<T> doIt(boolean condition, ISqlSegment... sqlSegments) {\n                        onlyInCondition = false;// 此方法执行代表有其他的条件\n                        return super.doIt(condition, sqlSegments);\n                    }\n                };\n            }\n\n            @Override\n            public List<T> list() {\n                if (onlyInCondition && haveNullValueOfIn) {\n                    return Collections.emptyList();\n                }\n                return super.list();\n            }\n        };\n    }\n}\n```\n\n# 总结\n1. 配置字段填充器  \n省去无关记录用户的操作\n2. 批量软删除使字段填充器删除时也生效  \n3. 查询已经删除的数据  \n4. 避免字符串编程  \n5. 避免空指针异常  \n\nmybatisPlus 虽然能开箱即用，但是如果没有更完善的配置，用起来也会不是特别的方便。这些特性配置完事之后，按照每个特性的使用步骤来。\n可以节省我们开发人员很多的代码量。以及省去了很多不需要关系的东西。","tags":["mybatis","mybatisPlus"],"categories":["java","mybatis"]},{"title":"MybatisPlus针对Saas系统的动态多租户插件","url":"/posts/mybatisplus针对saas系统的动态多租户插件/","content":"多租户就是用额外的一个字段代表当前表中的数据的归属。在sql curd时根据上下文的用户（租户） 自动拼接此条件  \n**动态**就是有些表是公用的，没有多租户的概念。那么操作此表的时候需要排除，亦或者多个字段，每个字段的值都不一样等\n\n# 前期工作\n1.首先定义一个多租户字段的枚举，为提取数据库多租户字段的字段做准备  \nIEnums参考[通用枚举](/posts/通用枚举)\n```java\n@Getter\npublic enum TenantField implements IEnums<String> {\n    // mid 为我们系统的租户字段\n    // CurrentTenant 是业务系统的上下文，比如说当前的登录用户信息，可以自由改造\n    MID(\"商户id\", \"mid\", () -> CurrentTenant.getCurrentTenant().getMid()),\n    ;\n    private final String[] dbFieldNames;\n    private final String doc;\n    private final Supplier<Long> getTenantValue;\n\n    TenantField(String doc, String underlineField, Supplier<Long> getTenantValue) {\n        this.doc = doc;\n        this.getTenantValue = getTenantValue;\n        String underlineLower = underlineField.toLowerCase(Locale.ENGLISH);\n        String underlineUpper = underlineField.toUpperCase(Locale.ENGLISH);\n        String camel = StringUtils.underlineToCamel(underlineField);\n        String camelLower = camel.toLowerCase(Locale.ENGLISH);\n        String camelUpper = camel.toUpperCase(Locale.ENGLISH);\n        // 下划线、驼峰、大写都可以匹配\n        this.dbFieldNames = new String[]{underlineLower, underlineUpper, camel, camelLower, camelUpper};\n    }\n\n    @Override\n    public String[] getIdentities() {\n        return dbFieldNames;\n    }\n\n    @Override\n    public String getDoc() {\n        return doc;\n    }\n}\n```\n定义好字段，以及获取字段值的方式之后接下来该读取数据库有此字段的表  \n为接下来动态拼接sql做准备\n\n# 读取数据库的多租户信息\n这个是MYSQL的获取表字段的方式哦，其他类型的数据库请参考其文档\nLogUtils.lazyJson 可参考[优雅打印日志](/posts/java如何优雅的打印log)\n```java\n\n    @Autowired\n    DataSource dataSource;\n\n    /**\n     * 表名称和对应的租户对应的字段\n     * 忽略大小写的map(mysql不区分大小写)\n     */\n    private final Map<String, List<String>> tableName$tenantField_map = new CaseInsensitiveKeyMap<>();\n\n    // spring容器给dataSource赋值之后的操作\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        // 所有的多租户字段\n        Set<String> tenantColumnNameSet = Arrays.stream(TenantField.values())\n                .map(TenantField::getDbFieldNames)\n                .flatMap(Arrays::stream)\n                .collect(Collectors.toSet());\n        log.info(\"tenant init all supports column names:\\n{}\", LogUtils.lazyJson(tenantColumnNameSet));\n\n        try (Connection connection = dataSource.getConnection()) {\n            String catalog = connection.getCatalog();\n            DatabaseMetaData metaData = connection.getMetaData();\n            ResultSet tables = metaData.getTables(catalog, null, null, new String[]{\"TABLE\"});\n\n            // 循环所有的表\n            while (tables.next()) {\n                String table_name = tables.getString(\"TABLE_NAME\");\n                ResultSet columns = metaData.getColumns(catalog, null, table_name, null);\n                // 循环表所有的字段\n                while (columns.next()) {\n                    String column_name = columns.getString(\"COLUMN_NAME\");\n                    // 如果有符合租户字段则Put\n                    if (tenantColumnNameSet.contains(column_name)) {\n                        tableName$tenantField_map.computeIfAbsent(table_name, k -> Lists.newArrayList())\n                                .add(column_name);\n                    }\n                }\n            }\n        }\n        log.info(\"tenant init table name and tenant column name :\\n{}\", LogUtils.lazyJson(tableName$tenantField_map));\n    }\n\n```\n提取表对应的租户字段之后就可以做动态注入的操作操作了。  \n如果表结构变更，只有重启系统才会生效哦\n\n# 拦截增删改查sql并动态注入条件\n```java\n@Component\npublic class CustomTenantSqlParser extends TenantSqlParser {\n\n    // 插入\n    @Override\n    public void processInsert(net.sf.jsqlparser.statement.insert.Insert insert) {\n        ItemsList itemsList = insert.getItemsList();\n        if (itemsList == null) {\n            return;\n        }\n\n        // 判断是否有租户字段并且判断是否为 有效的租户\n        List<String> tenantFieldList = ObjectUtils.defaultIfNull(tableName$tenantField_map.get(insert.getTable().getName()), Collections.emptyList());\n\n        // 如果已经显示的有租户字段，则不用处理\n        Set<String> existsColumnsSet = insert.getColumns().stream()\n                .map(Column::getColumnName)\n                .collect(Collectors.toSet());\n\n        tenantFieldList = tenantFieldList.stream()\n                .filter(t -> !existsColumnsSet.contains(t))\n                .collect(Collectors.toList());\n\n        // 如果当前操作的表没有租户的字段或者非有效租户，直接返回\n        if (CollectionUtils.isEmpty(tenantFieldList) || !CurrentTenant.isValidTenant()) {\n            return;\n        }\n\n        // 添加插入的字段，到最后一列\n        List<Column> newColumnList = tenantFieldList.stream()\n                .map(Column::new)\n                .collect(Collectors.toList());\n        insert.getColumns().addAll(newColumnList);\n\n\n        List<Expression> valueExpressionList = tenantFieldList.stream()\n                .map(field -> getTenantValueExpression(IEnums.mustGetEnum(TenantField.class, field)))\n                .collect(Collectors.toList());\n\n        // 批量新增\n        if (itemsList instanceof MultiExpressionList) {\n            ((MultiExpressionList) itemsList).getExprList().forEach(el -> el.getExpressions().addAll(valueExpressionList));\n        } else {\n            // 单个新增\n            ((ExpressionList) insert.getItemsList()).getExpressions().addAll(valueExpressionList);\n        }\n    }\n\n    // 更新\n    @Override\n    public void processUpdate(net.sf.jsqlparser.statement.update.Update update) {\n        Expression expression = getExpression(update.getTable(), update.getWhere());\n        if (expression != null) {\n            update.setWhere(expression);\n        }\n    }\n\n    // 删除\n    @Override\n    public void processDelete(net.sf.jsqlparser.statement.delete.Delete delete) {\n        Expression expression = getExpression(delete.getTable(), delete.getWhere());\n        if (expression != null) {\n            delete.setWhere(expression);\n        }\n    }\n\n    private Expression getExpression(Table table, Expression where) {\n        List<String> tenantFieldList = tableName$tenantField_map.get(table.getName());\n        return builderExpression(where, table, tenantFieldList);\n    }\n\n    /**\n     * 处理 普通查询\n     * @param addColumn   是否添加租户列,insert into select语句中需要\n     */\n    @Override\n    protected void processPlainSelect(PlainSelect plainSelect, boolean addColumn) {\n        FromItem fromItem = plainSelect.getFromItem();\n        if (fromItem instanceof Table) {\n            Table fromTable = (Table) fromItem;\n            List<String> tenantFieldList = tableName$tenantField_map.get(fromTable.getName());\n            plainSelect.setWhere(builderExpression(plainSelect.getWhere(), fromTable, tenantFieldList));\n            if (addColumn) {\n                tenantFieldList.forEach(field -> plainSelect.getSelectItems().add(new SelectExpressionItem(new Column(field))));\n            }\n        } else {\n            processFromItem(fromItem);\n        }\n        List<Join> joins = plainSelect.getJoins();\n        if (joins != null && joins.size() > 0) {\n            joins.forEach(j -> {\n                processJoin(j);\n                processFromItem(j.getRightItem());\n            });\n        }\n    }\n\n    // 联表查询\n    @Override\n    protected void processJoin(Join join) {\n        if (join.getRightItem() instanceof Table) {\n            Table rightItem = (Table) join.getRightItem();\n            List<String> tenantFieldList = tableName$tenantField_map.get(rightItem.getName());\n            join.setOnExpression(builderExpression(join.getOnExpression(), rightItem, tenantFieldList));\n        }\n    }\n\n    // 除新增外最终构造where条件\n    private Expression builderExpression(Expression currentExpression, Table table, List<String> tenantFieldList) {\n        if (CollectionUtils.isEmpty(tenantFieldList) || !CurrentTenant.isValidTenant()) {\n            return currentExpression;\n        }\n\n        if (currentExpression instanceof BinaryExpression) {\n            BinaryExpression binaryExpression = (BinaryExpression) currentExpression;\n            doExpression(binaryExpression.getLeftExpression());\n            doExpression(binaryExpression.getRightExpression());\n        } else if (currentExpression instanceof InExpression) {\n            InExpression inExp = (InExpression) currentExpression;\n            ItemsList rightItems = inExp.getRightItemsList();\n            if (rightItems instanceof SubSelect) {\n                processSelectBody(((SubSelect) rightItems).getSelectBody());\n            }\n            ItemsList leftItems = inExp.getLeftItemsList();\n            if (leftItems instanceof SubSelect) {\n                processSelectBody(((SubSelect) leftItems).getSelectBody());\n            }\n        }\n\n        Expression expression = currentExpression;\n        for (String tenantField : tenantFieldList) {\n            Expression tenantValueExpression = getTenantValueExpression(IEnums.mustGetEnum(TenantField.class, tenantField));\n\n            Expression appendExpression = this.processTableAlias4CustomizedTenantIdExpression(tenantValueExpression, table, tenantField);\n            if (expression instanceof OrExpression) {\n                expression = new AndExpression(appendExpression, new Parenthesis(expression));\n            } else if (expression != null) {\n                expression = new AndExpression(appendExpression, expression);\n            } else {\n                expression = appendExpression;\n            }\n\n        }\n        return expression;\n    }\n\n    /**\n     * 目前: 针对自定义的tenantId的条件表达式[tenant_id in (1,2,3)]，无法处理多租户的字段加上表别名\n     * select a.id, b.name\n     * from a\n     * join b on b.aid = a.id and [b.]tenant_id in (1,2) --别名[b.]无法加上 TODO\n     */\n    private Expression processTableAlias4CustomizedTenantIdExpression(Expression expression, Table table, String tenantField) {\n        if (expression instanceof ValueListExpression) {\n            InExpression inExpression = new InExpression();\n            inExpression.setLeftExpression(this.getAliasColumn(table, tenantField));\n            inExpression.setRightItemsList(((ValueListExpression) expression).getExpressionList());\n            return inExpression;\n        } else {\n            EqualsTo equalsTo = new EqualsTo();\n            equalsTo.setLeftExpression(this.getAliasColumn(table, tenantField));\n            equalsTo.setRightExpression(expression);\n            return equalsTo;\n        }\n    }\n\n    private Column getAliasColumn(Table table, String tenantField) {\n        StringBuilder column = new StringBuilder();\n        if (table.getAlias() != null) {\n            column.append(table.getAlias().getName()).append(StringPool.DOT);\n        }\n        column.append(tenantField);\n        return new Column(column.toString());\n    }\n\n    /**\n     * 从当前上下文获取租户的值\n     */\n    private static Expression getTenantValueExpression(TenantField tenantField) {\n        Long tenantId = tenantField.getGetTenantValue().get();\n        return new LongValue(tenantId);\n    }\n\n}\n```\n实现增删改方法的拦截之后再把此类注入到spring容器当中即可\n\n# 注入并生效\n```java\n@Configuration\npublic class MyBatisPlusConfig {\n\n    @Autowired\n    CustomTenantSqlParser customTenantSqlParser;\n\n    /**\n     * 分页插件\n     * 和\n     * sql拦截器\n     */\n    @Bean\n    public PaginationInterceptor paginationInterceptor() {\n        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();\n        paginationInterceptor.setSqlParserList(Collections.singletonList(customTenantSqlParser));\n        return paginationInterceptor;\n    }\n\n}\n```\n\n# 总结\n至此动态多租户的插件到此结束，总结分为这几个步骤  \n1.定义好多租户的字段以及值获取的方式（enum TenantField）  \n2.根据定义好的字段读取数据库有此字段的表的信息，定义一个java缓存(tableName$tenantField_map)  \n3.实现多租户sql拦截的方法包括:增(自动insert)删改查(自动拼接sql条件)  \n4.把此插件注入到spring容器中即可  \n实现的效果为所有的sql 会自动拼接对应的条件。但是具体字段名称和字段值的提供都由使用者自定义实现(enum TenantField)  \n这样我们针对saas系统的业务完全可以当做非saas系统来开发，提升开发效率","tags":["mybatis","多租户"],"categories":["java","mybatis"]},{"title":"java的序列化和反序列化Serializable原理","url":"/posts/java的序列化和反序列化serializable原理/","content":"\n## 背景\n实现Serializable接口就能把对象序列化反序列化出去，那么原理是什么呢？  \n带着以下问题一探究竟  \n* 为什么实现这个接口就能序列化和反序列化呢？\n* 序列化和反序列化的内容是什么呢，可以自定义吗？\n\n## 为什么实现这个接口就能序列化和反序列化呢\n\n* java序列化代码  \n```java\npublic static void main(String[] args) throws IOException {\n    Object o = new Serializable() {\n        String strValue = \"这是内容\";\n        Integer intValue = 999;\n    };\n    File file = new File(System.getProperty(\"java.io.tmpdir\"), \"serializable/\");\n    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file));\n    objectOutputStream.writeObject(o);\n}\n```\n\n这样就会把对象序列化到指定的文件中，我们点开writeObject方法看源码一探究竟  \n```java\n\npublic final void writeObject(Object obj)throws IOException{\n  ...\n  try{\n      writeObject0(obj,false);\n  }catch(IOException ex){\n      if(depth==0){\n        writeFatalException(ex);\n      }\n      throw ex;\n  }\n}\n\nprivate void writeObject0(Object obj, boolean unshared)\n        throws IOException\n    {\n        boolean oldMode = bout.setBlockDataMode(false);\n        depth++;\n        try {\n            // handle previously written and non-replaceable objects\n            int h;\n            if ((obj = subs.lookup(obj)) == null) {\n                writeNull();\n                return;\n            } else if (!unshared && (h = handles.lookup(obj)) != -1) {\n                writeHandle(h);\n                return;\n            } else if (obj instanceof Class) {\n                writeClass((Class) obj, unshared);\n                return;\n            } else if (obj instanceof ObjectStreamClass) {\n                writeClassDesc((ObjectStreamClass) obj, unshared);\n                return;\n            }\n\n            // check for replacement object\n            Object orig = obj;\n            Class<?> cl = obj.getClass();\n            ObjectStreamClass desc;\n            for (;;) {\n                // REMIND: skip this check for strings/arrays?\n                Class<?> repCl;\n                desc = ObjectStreamClass.lookup(cl, true);\n                // 如果有无参的writeReplace且返回值为Object类型的方法则会调用\n                if (!desc.hasWriteReplaceMethod() ||\n                    (obj = desc.invokeWriteReplace(obj)) == null ||\n                    (repCl = obj.getClass()) == cl)\n                {\n                    break;\n                }\n                cl = repCl;\n            }\n            if (enableReplace) {\n                Object rep = replaceObject(obj);\n                if (rep != obj && rep != null) {\n                    cl = rep.getClass();\n                    desc = ObjectStreamClass.lookup(cl, true);\n                }\n                obj = rep;\n            }\n\n            // if object replaced, run through original checks a second time\n            if (obj != orig) {\n                subs.assign(orig, obj);\n                if (obj == null) {\n                    writeNull();\n                    return;\n                } else if (!unshared && (h = handles.lookup(obj)) != -1) {\n                    writeHandle(h);\n                    return;\n                } else if (obj instanceof Class) {\n                    writeClass((Class) obj, unshared);\n                    return;\n                } else if (obj instanceof ObjectStreamClass) {\n                    writeClassDesc((ObjectStreamClass) obj, unshared);\n                    return;\n                }\n            }\n\n            // remaining cases\n            if (obj instanceof String) {\n                writeString((String) obj, unshared);\n            } else if (cl.isArray()) {\n                writeArray(obj, desc, unshared);\n            } else if (obj instanceof Enum) {\n                writeEnum((Enum<?>) obj, desc, unshared);\n            } else if (obj instanceof Serializable) {\n                // 这里是重点，如果序列化的对象不是Serializable的实现类，else就会报错\n                writeOrdinaryObject(obj, desc, unshared);\n            } else {\n                if (extendedDebugInfo) {\n                    throw new NotSerializableException(\n                        cl.getName() + \"\\n\" + debugInfoStack.toString());\n                } else {\n                    throw new NotSerializableException(cl.getName());\n                }\n            }\n        } finally {\n            depth--;\n            bout.setBlockDataMode(oldMode);\n        }\n    }\n```\n\n所以要想[反]序列化对象，类型必须是String\\|array\\|enum\\|Serializable\\|class，不然就会直接报错\n\n* writeOrdinaryObject\n```java\nprivate void writeOrdinaryObject(Object obj,\n                                     ObjectStreamClass desc,\n                                     boolean unshared)\n        throws IOException\n    {\n        try {\n            bout.writeByte(TC_OBJECT);\n            writeClassDesc(desc, false);\n            handles.assign(unshared ? null : obj);\n            // 实现java.io.Externalizable接口，可自定义[反]序列化的内容\n            if (desc.isExternalizable() && !desc.isProxy()) {\n                writeExternalData((Externalizable) obj);\n            } else {\n                writeSerialData(obj, desc);\n            }\n        } finally {\n            if (extendedDebugInfo) {\n                debugInfoStack.pop();\n            }\n        }\n    }\n```\n\n* writeSerialData\n```java\nprivate void writeSerialData(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();\n        for (int i = 0; i < slots.length; i++) {\n            ObjectStreamClass slotDesc = slots[i].desc;\n            // 当前对象[反]序列化工具类的包装，\n            // 如果没有实现java.io.Externalizable自定义[反]序列化接口也没关系\n            // 直接把writeObject(序列化)和readObject(反序列化)名称写在你自己的类当中，也可以自定义[反]序列化的内容哦\n            if (slotDesc.hasWriteObjectMethod()) {\n                PutFieldImpl oldPut = curPut;\n                curPut = null;\n                SerialCallbackContext oldContext = curContext;\n\n                if (extendedDebugInfo) {\n                    debugInfoStack.push(\n                        \"custom writeObject data (class \\\"\" +\n                        slotDesc.getName() + \"\\\")\");\n                }\n                try {\n                    curContext = new SerialCallbackContext(obj, slotDesc);\n                    bout.setBlockDataMode(true);\n                    slotDesc.invokeWriteObject(obj, this);\n                    bout.setBlockDataMode(false);\n                    bout.writeByte(TC_ENDBLOCKDATA);\n                } finally {\n                    curContext.setUsed();\n                    curContext = oldContext;\n                    if (extendedDebugInfo) {\n                        debugInfoStack.pop();\n                    }\n                }\n\n                curPut = oldPut;\n            } else {\n                // 直接获取对象内的字段，进行递归[反]序列化\n                defaultWriteFields(obj, slotDesc);\n            }\n        }\n    }\n```\n如果类中有writeReplace方法，则会调用，并且序列化的目标类为该方法的返回值\n* defaultWriteFields\n```java\nprivate void defaultWriteFields(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        Class<?> cl = desc.forClass();\n        if (cl != null && obj != null && !cl.isInstance(obj)) {\n            throw new ClassCastException();\n        }\n\n        desc.checkDefaultSerialize();\n\n        // 优先输出基本类型\n        int primDataSize = desc.getPrimDataSize();\n        if (primVals == null || primVals.length < primDataSize) {\n            primVals = new byte[primDataSize];\n        }\n        desc.getPrimFieldValues(obj, primVals);\n        bout.write(primVals, 0, primDataSize, false);\n\n        ObjectStreamField[] fields = desc.getFields(false);\n        Object[] objVals = new Object[desc.getNumObjFields()];\n        int numPrimFields = fields.length - objVals.length;\n        desc.getObjFieldValues(obj, objVals);\n        for (int i = 0; i < objVals.length; i++) {\n            if (extendedDebugInfo) {\n                debugInfoStack.push(\n                    \"field (class \\\"\" + desc.getName() + \"\\\", name: \\\"\" +\n                    fields[numPrimFields + i].getName() + \"\\\", type: \\\"\" +\n                    fields[numPrimFields + i].getType() + \"\\\")\");\n            }\n            try {\n                // 继续递归调用\n                writeObject0(objVals[i],\n                             fields[numPrimFields + i].isUnshared());\n            } finally {\n                if (extendedDebugInfo) {\n                    debugInfoStack.pop();\n                }\n            }\n        }\n    }\n```\n\n# 总结 \n* 除基本类型和String、Enum、class和array外，其他类型想要[反]序列化，必须实现Serializable接口，不然直接报错\n* 自定义[反]序列化内容有两种方法，一是直接写方法(writeObject(序列化)|readObject(反序列化))到自己的类中，二是实现java.io.Externalizable接口.  \n  writeObject参数类型是ObjectOutputStream  \n  readObject参数类型是ObjectInputStream  \n  **方法返回类型必须为void，private，非static**\n\n* writeReplace返回值为Object类型的方法，可自定义真正序列化的对象","tags":["序列化","反序列化"],"categories":["java","基础"]},{"title":"mybatisPlus分析Lambda语法原理","url":"/posts/mybatisplus分析lambda语法原理/","content":"\n用lambda就不用写字符串了，这个对于开发业务来说，能减少很多的错误发生。尤其是字段写错了，数据库变更字段名了，等。  \n用法如下\n```java\neq(FissionCoupon::getMid, mid)\n```\n他会自动转换为mid，那他的原理是什么呢？  \n原来他接受的是一个可序列化的Function对象\n```java\n@FunctionalInterface\npublic interface SFunction<T, R> extends Function<T, R>, Serializable {\n}\n```\n\n其实用到了jdk自带的序列化。因为lambda是个特殊的实例，也是个特殊的class。  \n在序列化的时候lambda实例中有一个writeReplace方法。  \n* 可参考jdk的序列化 [Serializable原理](/posts/java的序列化和反序列化Serializable原理)  \n该方法的返回值是一个lambda描述对象，```java.lang.invoke.SerializedLambda```  \n```java\npublic final class SerializedLambda implements Serializable {\n    private static final long serialVersionUID = 8025925345765570181L;\n    private final Class<?> capturingClass;\n    private final String functionalInterfaceClass;\n    private final String functionalInterfaceMethodName;\n    private final String functionalInterfaceMethodSignature;\n    private final String implClass;\n    private final String implMethodName;\n    private final String implMethodSignature;\n    private final int implMethodKind;\n    private final String instantiatedMethodType;\n    private final Object[] capturedArgs;\n    。。。。\n}\n```\n通过此对象就能获取到对应的方法名，等信息了。通过方法名去掉get|set|is方法之后就得到字段名称了\n\n# 总结\n通过调用可序列化的lambda实例中的writeReplace方法，获取到lambda对象及可获取到里面的各种信息","tags":["序列化","反序列化","mybatis","lambda"],"categories":["java","mybatis"]},{"title":"枚举序列化和反序列化的代码","url":"/posts/枚举序列化和反序列化的代码/","content":"在java或各种框架中，[反]序列化对枚举类型默认一般都是用的枚举的名称。  \n如果代码有魔法值，我们想改成枚举类型。但我们在改造、重构后端的时候不想对前端或者第三方有影响，可以用到此方法。\n\n# 必须用到的枚举工具类\n* 参考通用枚举 [通用枚举](/posts/通用枚举)  \n所有的枚举想要实现(反)序列化比较要用到通用枚举，实现通用枚举的接口即可\n\n# 代码（最初版本）\n\n1.可反序列化的枚举  \n```java\n/**\n * 可反序列化的枚举\n */\npublic enum DeserializableEnum {\n    // DBEnum是MybatisPlus枚举的adapter，增加了getDoc的方法。MybatisPlus是直接支持数据库[反]序列化的。但是还不支持和前端的[反]序列化的交互，所以在此配置即可。\n    DB_Enum(DBEnum.class, DBEnum::getValue, DB_Enum::getDoc),\n    // 一个枚举对应单个标识\n    I_Enum(IEnum.class, IEnum::getIdentity, IEnum::getDoc),\n    // 一个枚举对应多个标识\n    I_Enums(IEnums.class, IEnums::getIdentities, IEnums::getDoc),\n    ;\n\n    private final Class<?> enumInterface;\n    private final Function<Object, Serializable> getIdentityFunction;\n    private final Function<Object, String> getDocFunction;\n\n    <T> DeserializableEnum(Class<T> enumInterface, Function<T, Serializable> getIdentityFunction, Function<T, String> getDocFunction) {\n        this.enumInterface = enumInterface;\n        this.getIdentityFunction = (Function<Object, Serializable>) getIdentityFunction;\n        this.getDocFunction = (Function<Object, String>) getDocFunction;\n    }\n\n  /**\n   * 判断class是否可以进行反序列化\n   */\n    public static Optional<DeserializableEnum> getDeserializableEnum(Class<?> enumClass) {\n        if (enumClass == null) {\n            return Optional.empty();\n        }\n        if (!enumClass.isEnum()) {\n            return Optional.empty();\n        }\n        for (DeserializableEnum deserializableEnum : DeserializableEnum.values()) {\n            if (deserializableEnum.enumInterface.isAssignableFrom(enumClass)) {\n                return Optional.of(deserializableEnum);\n            }\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * 进行反序列化\n     */\n    private Enum<?> deserializeEnum(Class<Enum<?>> enumClass, Object rawValue) {\n        for (Enum<?> enumConstant : enumClass.getEnumConstants()) {\n            Serializable identity = this.getGetIdentityFunction.apply(enumConstant);\n            if (Objects.equals(identity, rawValue)) {\n                return enumConstant;\n            }\n            if (identity instanceof Object[]) {\n                for (Object i : (Object[]) identity) {\n                    if (Objects.equals(i, rawValue)) {\n                        return enumConstant;\n                    }\n                }\n            }\n        }\n\n        // 最后值为空则返回null\n        if (rawValue == null || StringUtils.isBlank(rawValue.toString())) {\n            return null;\n        }\n\n        // 转换失败一律抛异常，后期可根据注解进行动态的抛异常\n        throw new EnumDeserializeException(MessageFormat.format(\"参数错误，无法匹配对应的类型,value:{0}, type:{1}\", rawValue, enumClass.getSimpleName()));\n    }\n}\n\n```\n\n2.枚举[反]序列化的各种框架配置\n如jackson,fastjson,springConvert等  \n```java\npublic class EnumDeserializerImpls {\n    /**\n     * 定义一个常量为spring converter 组件\n     */\n    public static final GenericConverter ENUM_DESERIALIZER_CONVERTER = new GenericConverter() {\n        @Override\n        public Set<ConvertiblePair> getConvertibleTypes() {\n            Set<ConvertiblePair> cpSet = Sets.newHashSet();\n            for (DeserializableEnum deserializableEnum : DeserializableEnum.values()) {\n                /* convert匹配逻辑：\n                 先循环 sourceType 水平class\n                 然后内嵌 targetType 水平class 进行内嵌循环\n                 找对对应的ConvertiblePair为止\n                 所以sourceType必须比较精确不然覆盖不了defaultConvertor\n                 */\n                cpSet.add(new ConvertiblePair(String.class, deserializableEnum.enumInterface));\n                cpSet.add(new ConvertiblePair(Number.class, deserializableEnum.enumInterface));\n            }\n            return cpSet;\n        }\n\n        @Override\n        public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n            ResolvableType targetResolvableType = targetType.getResolvableType();\n            Class<?> valueRawClass = getValueRawClass(targetResolvableType);\n            if (valueRawClass == null) {\n                return source;\n            }\n            Class<Enum<?>> enumClass = (Class<Enum<?>>) targetResolvableType.resolve();\n\n            DeserializableEnum deserializableEnum = DeserializableEnum.getDeserializableEnum(enumClass).orElse(null);\n            if (deserializableEnum == null) {\n                return source;\n            }\n            // 把source转换成枚举真实值的类型\n            Object rawValue = DefaultConversionService.getSharedInstance().convert(source, valueRawClass);\n            return deserializableEnum.deserializeEnum(enumClass, rawValue);\n        }\n    };\n\n    /**\n     * 定义一个常量为jacksonModule 组件\n     */\n    public static final SimpleModule ENUM_MODULE = new SimpleModule() {\n        @Override\n        public void setupModule(SetupContext context) {\n\n            // 添加枚举反序列化\n            context.addDeserializers(new Deserializers.Base() {\n                @Override\n                public JsonDeserializer<?> findEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) {\n                    Class<?> valueRawClass = getValueRawClass(ResolvableType.forClass(type));\n                    if (valueRawClass == null) {\n                        return null;\n                    }\n\n                    return DeserializableEnum.getDeserializableEnum(type)\n                            .map(deserializableEnum -> new JsonDeserializer<Enum<?>>() {\n                                @Override\n                                public Enum<?> deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException {\n                                    Object value = DefaultConversionService.getSharedInstance().convert(jsonParser.getValueAsString(), valueRawClass);\n                                    return deserializableEnum.deserializeEnum((Class<Enum<?>>) type, value);\n                                }\n                            }).orElse(null);\n\n                }\n            });\n        }\n\n    };\n\n\n    /*\n     * 定义一个常量为fastJson 组件\n     */\n    public static final Module FASTJSON_MODULE = new Module() {\n        @Override\n        public ObjectDeserializer createDeserializer(ParserConfig config, Class type) {\n            Class<?> valueRawClass = getValueRawClass(ResolvableType.forClass(type));\n            if (valueRawClass == null) {\n                return null;\n            }\n\n            return DeserializableEnum.getDeserializableEnum(type)\n                    .map(deserializableEnum -> new ObjectDeserializer() {\n                        @Override\n                        public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {\n                            Object value = parser.parse();\n\n                            Object rawValue = DefaultConversionService.getSharedInstance().convert(value, valueRawClass);\n                            return (T) deserializableEnum.deserializeEnum((Class<Enum<?>>) type, rawValue);\n                        }\n\n                        public int getFastMatchToken() {\n                            return JSONToken.LITERAL_STRING;\n                        }\n                    }).orElse(null);\n\n        }\n\n        @Override\n        public ObjectSerializer createSerializer(SerializeConfig config, Class type) {\n            return null;\n        }\n    };\n\n    /**\n     * 获取接口上的泛型\n     */\n    public static Class<?> getValueRawClass(ResolvableType realClassResolvedType) {\n        ResolvableType[] enumInterfaces = realClassResolvedType.getInterfaces();\n        if (ArrayUtils.isEmpty(enumInterfaces)) {\n            return null;\n        }\n        ResolvableType valueResolvableType = enumInterfaces[0].getGeneric(0);\n        if (valueResolvableType == ResolvableType.NONE) {\n            return null;\n        }\n        return valueResolvableType.getRawClass();\n    }\n\n}\n```\n\n## 缺陷\n1：目前不支持序列化😝  \n2：获取枚举identity类型的方法比较愚钝，一刀切了  \n> 如果是间接实现的枚举或者泛型的位置不在第一个位置，那就有问题喽。  \n\n3：反序列化和序列化只能单层序列和反序列，什么意思呢？\n> 枚举的标识可以获取到枚举对吧？如果枚举的标识还是一个枚举呢？目前只支持序列化和反序列化最外一层的value。太抽象？\n\n* 用户类型1  \n```java\npublic enum UserType1 implements IEnum<Integer> {\n\n  NEW_USER(1, \"新用户\"),\n\n  OLD_USER(0, \"老用户\");\n  public final int code;\n\n  public final String doc;\n\n  UserType1(int code, String doc) {\n    this.code = code;\n    this.doc = doc;\n  }\n\n  @Override\n  public Integer getIdentity() {\n    return code;\n  }\n}\n```\n\n* 用户类型2  \n```java\npublic enum UserType2 implements IEnum<UserType1> {\n\n  NEW_USER(UserType1.NEW_USER, \"新用户2\"),\n\n  OLD_USER(UserType1.OLD_USER, \"旧用户2\");\n  \n  public final UserType1 userType1;\n\n  public final String doc;\n\n  UserType2(UserType1 userType1, String doc) {\n    this.userType1 = userType1;\n    this.doc = doc;\n  }\n\n  /**\n   * 当前枚举的标识是userType1枚举类型\n   */\n  @Override\n  public UserType1 getIdentity() {\n    return userType1;\n  }\n\n  @Override\n  public String getDoc() {\n    return doc;\n  }\n}\n```\n如果用UserType2枚举的话，反序列化或者序列化就会出现缺陷。因为不支持内嵌套一个枚举当做当前枚举的标识。  \n所以有了以下的新代码。\n\n# 代码（新版本）\n* 支持序列化啦\n* 支持枚举内嵌的标识序列化和反序列化\n* 更精准的获取泛型上的标识\n\n1.可反序列化的枚举  \n```java\n/**\n * 可反序列化的枚举\n */\npublic enum DeserializableEnum {\n    // DBEnum是MybatisPlus枚举的adapter，增加了getDoc的方法。MybatisPlus是直接支持数据库[反]序列化的。但是还不支持和前端的[反]序列化的交互，所以在此配置即可。\n    DB_Enum(DBEnum.class, 0, DBEnum::getValue, DBEnum::getDoc),\n    I_Enum(IEnum.class, 0, IEnum::getIdentity, IEnum::getDoc),\n    I_Enums(IEnums.class, 0, IEnums::getIdentities, IEnums::getDoc),\n    ;\n\n    // 可反序列化枚举的接口\n    public final Class<?> enumInterface;\n    // 接口对应的identity(枚举的标识)泛型的下标\n    private final int identityGenericIndex;\n    // 获取枚举的identity\n    private final Function<Enum<?>, Serializable> getIdentityFunction;\n    // 获取枚举的doc(文档)\n    public final Function<Enum<?>, String> getDocFunction;\n\n    <T> DeserializableEnum(Class<T> enumInterface, int identityGenericIndex, Function<T, Serializable> getIdentityFunction, Function<T, String> getDocFunction) {\n        this.enumInterface = enumInterface;\n        this.identityGenericIndex = identityGenericIndex;\n        this.getIdentityFunction = (Function<Enum<?>, Serializable>) getIdentityFunction;\n        this.getDocFunction = (Function<Enum<?>, String>) getDocFunction;\n    }\n\n    /**\n     * 进行反序列化\n     */\n    private Enum<?> deserializeEnum(Class<Enum<?>> enumClass, Object rawValue) {\n        for (Enum<?> enumConstant : enumClass.getEnumConstants()) {\n            Object identity = getIdentity(enumConstant);\n            if (identity instanceof Object[]) {\n                for (Object i : (Object[]) identity) {\n                    if (Objects.equals(i, rawValue)) {\n                        return enumConstant;\n                    }\n                }\n            } else {\n                if (Objects.equals(identity, rawValue)) {\n                    return enumConstant;\n                }\n            }\n        }\n\n        // 最后值为空则返回null\n        if (rawValue == null || StringUtils.isBlank(rawValue.toString())) {\n            return null;\n        }\n\n        // 转换失败一律抛异常，后期可根据注解进行动态的抛异常\n        throw new EnumDeserializeException(MessageFormat.format(\"参数错误，无法匹配对应的类型,value:{0}, type:{1}\", rawValue, enumClass.getSimpleName()));\n    }\n    \n    public Object getIdentity(Enum<?> enumConstant) {\n        Serializable identity = this.getIdentityFunction.apply(enumConstant);\n        if (identity == null) {\n            return null;\n        }\n        Class<?> identityType;\n        if (identity instanceof Object[]) {\n            identityType = identity.getClass().getComponentType();\n        } else {\n            identityType = identity.getClass();\n        }\n\n        // 递归判断\n        DeserializableEnum deserializableEnum = getDeserializableEnumAndIdentityClass(identityType)\n                .map(Map.Entry::getKey)\n                .orElse(null);\n\n        if (deserializableEnum == null || !(identity instanceof Enum<?>)) {\n            return identity;\n        }\n        return deserializableEnum.getIdentity((Enum<?>) identity);\n    }\n\n    /**\n     * 获取接口上标识枚举值的类型\n     */\n    private Class<?> getValueRawClass(Class<?> enumInterface) {\n        ResolvableType resolvableType = ResolvableType.forClass(enumInterface).as(this.enumInterface);\n        Class<?> valueRawClass = resolvableType.getGeneric(this.identityGenericIndex).resolve();\n        // 判断递归获取\n        DeserializableEnum deserializableEnum = DeserializableEnum.getDeserializableEnumAndIdentityClass(valueRawClass)\n                .map(Map.Entry::getKey)\n                .orElse(null);\n\n        if (deserializableEnum == null) {\n            return valueRawClass;\n        }\n\n        return deserializableEnum.getValueRawClass(valueRawClass);\n    }\n\n    public static Optional<Map.Entry<DeserializableEnum, Class<?>>> getDeserializableEnumAndIdentityClass(Class<?> enumClass) {\n        if (enumClass == null) {\n            return Optional.empty();\n        }\n        if (!enumClass.isEnum()) {\n            return Optional.empty();\n        }\n        for (DeserializableEnum deserializableEnum : DeserializableEnum.values()) {\n            if (deserializableEnum.enumInterface.isAssignableFrom(enumClass)) {\n                Class<?> identityValueRawClass = deserializableEnum.getValueRawClass(enumClass);\n                return Optional.of(Pair.of(deserializableEnum, identityValueRawClass));\n            }\n        }\n        return Optional.empty();\n    }\n}\n```\n\n2.枚举[反]序列化的各种框架配置\n```java\n@Slf4j\npublic class EnumDeserializerImpls {\n    /**\n     * spring converter反序列化\n     */\n    public static final GenericConverter ENUM_DESERIALIZER_CONVERTER = new GenericConverter() {\n        @Override\n        public Set<ConvertiblePair> getConvertibleTypes() {\n            Set<ConvertiblePair> cpSet = Sets.newHashSet();\n            for (DeserializableEnum deserializableEnum : DeserializableEnum.values()) {\n                /* 匹配逻辑：\n                 先循环 sourceType 水平class\n                 然后内嵌 targetType 水平class 进行内嵌循环\n                 找对对应的ConvertiblePair为止\n                 所以sourceType必须比较精确不然覆盖不了defaultConvertor\n                 */\n                cpSet.add(new ConvertiblePair(String.class, deserializableEnum.enumInterface));\n                cpSet.add(new ConvertiblePair(Number.class, deserializableEnum.enumInterface));\n            }\n            return cpSet;\n        }\n\n        @Override\n        public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n            Class<?> targetClass = targetType.getResolvableType().resolve();\n\n            return DeserializableEnum.getDeserializableEnumAndIdentityClass(targetClass)\n                    .map((Function<Map.Entry<DeserializableEnum, Class<?>>, Object>) entry -> {\n                        Object rawValue = DefaultConversionService.getSharedInstance().convert(source, entry.getValue());\n                        return entry.getKey().deserializeEnum((Class<Enum<?>>) targetClass, rawValue);\n                    }).orElse(null);\n        }\n    };\n\n    /**\n     * jacksonModule序列化和反序列化\n     */\n    public static final SimpleModule ENUM_MODULE = new SimpleModule() {\n        @Override\n        public void setupModule(SetupContext context) {\n            context.addSerializers(new Serializers.Base() {\n                @Override\n                public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) {\n                    return DeserializableEnum.getDeserializableEnumAndIdentityClass(type.getRawClass())\n                            .map(Map.Entry::getKey)\n                            .map(deserializableEnum -> new JsonSerializer<Enum<?>>() {\n                                @Override\n                                public void serialize(Enum<?> o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n                                    jsonGenerator.writeObject(deserializableEnum.getIdentity(o));\n                                }\n                            }).orElse(null);\n                }\n            });\n\n            context.addDeserializers(new Deserializers.Base() {\n                @Override\n                public JsonDeserializer<?> findEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) {\n                    return DeserializableEnum.getDeserializableEnumAndIdentityClass(type)\n                            .map(entry -> new JsonDeserializer<Enum<?>>() {\n                                public Enum<?> deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException {\n                                    Object value = DefaultConversionService.getSharedInstance().convert(jsonParser.getValueAsString(), entry.getValue());\n                                    return entry.getKey().deserializeEnum((Class<Enum<?>>) type, value);\n                                }\n                            }).orElse(null);\n                }\n            });\n        }\n\n    };\n\n\n    /*\n     * fastJson 枚举序列化和反序列化\n     */\n    public static final Module FASTJSON_MODULE = new Module() {\n        @Override\n        public ObjectDeserializer createDeserializer(ParserConfig config, Class type) {\n            return DeserializableEnum.getDeserializableEnumAndIdentityClass(type)\n                    .map(entry -> new ObjectDeserializer() {\n                        @Override\n                        public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {\n                            Object rawValue = DefaultConversionService.getSharedInstance().convert(parser.parse(), entry.getValue());\n                            return (T) entry.getKey().deserializeEnum((Class<Enum<?>>) type, rawValue);\n                        }\n\n                        @Override\n                        public int getFastMatchToken() {\n                            return JSONToken.LITERAL_STRING;\n                        }\n                    }).orElse(null);\n        }\n\n        @Override\n        public ObjectSerializer createSerializer(SerializeConfig config, Class type) {\n            return DeserializableEnum.getDeserializableEnumAndIdentityClass(type)\n                    .map(entry -> new ObjectSerializer() {\n                        @Override\n                        public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) {\n                            serializer.write(entry.getKey().getIdentity((Enum<?>) object));\n                        }\n                    }).orElse(null);\n        }\n    };\n\n}\n```\n基本实现以及各种框架的组件都已经定义出来了，可以参考[springMvc枚举序列化和反序列化](/posts/mvc枚举序列化和反序列化的配置)，把这些实现应用到实际的项目当中。  \n然后我们用各种枚举什么的，后端可以安心的进行重构（使用）了\n\n> 新代码用到了递归，如果不理解旧代码的话阅读起来比较复杂。建议先理解旧代码在阅读新代码","tags":["效率","枚举","序列化","反序列化"],"categories":["java","枚举"]},{"title":"mvc枚举序列化和反序列化的配置","url":"/posts/mvc枚举序列化和反序列化的配置/","content":"\n# 必须用到的枚举工具类\n* 参考通用枚举 [通用枚举](/posts/通用枚举)\n\n\n# 使用背景\nspring mvc 接收或者序列化枚举类型时，\n默认是根据枚举的名称(string)进行序列化或者反序列化。  \n但是在实际开发当中，我们一般用枚举代表某一个数值，数据库存储值。\n同时我们也希望和前端交互用数值交互，而不是string名称。因此用到这个工具类  \n支持以下几个组件的反序列化和序列化\n* spring convert  \n  @RequestParam  \n  @PathVariable  \n  ...  \n  \n* jackson  \n  @ResponseBody\n  \n* fastjson  \n  JSON.parseObject(...)\n  \n\n# 代码\n* 枚举序列化和反序列化的代码 [枚举序列化和反序列化的代码](/posts/枚举序列化和反序列化的代码)\n\n# 使用方式\n\n## springConverter组件的使用\nspring 接收参数为form表单请求时，默认用的converter组件进行转换对象\n```java\n@Configuration\npublic class AddEnumConverter implements WebMvcConfigurer {\n\n  @Override\n  public void addFormatters(FormatterRegistry registry) {\n    registry.addConverter(EnumDeserializerImpls.ENUM_DESERIALIZER_CONVERTER);\n  }\n}\n```\n\n\n## jackson序列化和反序列化的使用\nspring的@RequestBody,@ResponseBody 默认使用jackson进行反序列化和序列化\n\n```java\n@Configuration\npublic class AddEnumJacksonModule implements WebMvcConfigurer {\n\n  @Override\n  public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n\n    for (HttpMessageConverter<?> converter : converters) {\n      if (!(converter instanceof MappingJackson2HttpMessageConverter)) {\n        continue;\n      }\n      ((MappingJackson2HttpMessageConverter) converter).getObjectMapper()\n              .registerModule(EnumDeserializerImpls.ENUM_MODULE);\n    }\n  }\n}\n```\n\n## fastJson的使用\n```java\n// 序列化\nParserConfig.getGlobalInstance().register(EnumDeserializerImpls.FASTJSON_MODULE);\n// 反序列化\nSerializeConfig.getGlobalInstance().register(EnumDeserializerImpls.FASTJSON_MODULE);\n```\n\n# 总结\n我们定义好通用枚举之后，所有枚举实现通用枚举的接口。在定义枚举的序列化实现，然后在定义各自(反)序列化框架的实现  \n最后我们把各种(反)序列化枚举的实现配置到spring容器中，最终才生效。  \n这样配置好之后呢，可以直接用枚举当做接收参数和返回参数了。前端交互用的还是数值类型哦。  \n这样针对老项目重构的时候可以在不影响前端的情况下，后端全部可以改成枚举哦。  \n\n数据库枚举的序列化和反序列化-mybatisPlus目前是直接支持的。参考mybatisPlus的文档即可。但是前端交互用数值的话需要配合此代码才行哦","tags":["效率","枚举","序列化","反序列化","mvc"],"categories":["java","枚举"]},{"title":"业务开发如何优雅的编写代码","url":"/posts/业务开发如何优雅的编写代码/","content":"\n# 背景\n我们开发人员，基本都是从搬砖的码农做起，但也有非常优秀的人，一直在做中间件或其他底层通用的逻辑。显然，我们大多数都不够优秀。\n那针对业务开发的我们也需要提升自己的技能，而不是每天的CURD，为了提升我们自己，所以在我们的日常开发工作中不仅仅完成任务作为目标，至少还有一些目标之外的思维，如\n* 代码阅读性高吗？\n* 代码便于维护或协作吗？\n* 代码会不会冗余？\n* 怎样用更精简的方法实现它呢？\n* 自己有没有重复造轮子呢？\n* ...  \n\n如果缺少了这些思维的话，那你适合做管理层。  \n本文是个总结文，就拿我常在开发中用到的技术展开交流。需要读者点开其他文章依次观看😂\n> springboot + mvc + mybatisPlus + dubbo + Saas业务\n\n## 定义通用枚举\n* [通用枚举](/posts/通用枚举)  \n避免魔法值、统一枚举的**获取方式**\n\n* [springMvc枚举(反)序列化配置](/posts/mvc枚举序列化和反序列化的配置)  \n  定义好通用枚举之后也要配置好(反)序列化，mybatisPlus也支持枚举，结合起来。项目当中能够完全避免魔法值的产生\n\n* 定义一个[获取当前环境的枚举的工具类](/posts/获取spring启动环境的工具类)  \n  这个很有必要，在复杂业务的情况下，不同业务，不同环境下逻辑也不一样。比如说swagger不能在线上开启，热部署禁止在线上使用等  \n\n## 重新加装Mybatis-plus(业务开发必备)\n* [重新加装MybatisPlus](/posts/重新加装MybatisPlus)  \n  字段填充器、软删除使字段填充器生效、查询软删除的数据、避免字符串编程、避免空指针等等\n\n* [MybatisPlus针对Saas系统的动态多租户插件](/posts/MybatisPlus针对Saas系统的动态多租户插件)  \n  针对多租户Saas系统，这个插件可以极大的提高我们开发人员的工作效率，不用关心多租户的业务\n\n## 定义代码校验（协作开发必备）\n虽然我们有代码分层的设计，但是还是会写出林乱不堪的代码。  \n如何让别人写出可阅读的代码、可维护的代码呢？如何强制实现代码规范？  \n\n* [MybatisPlus语法糖的校验](/posts/MybatisPlus语法糖的校验)  \n  我们用mybatisPlus语法糖可代替很多sql。但是保证不了会在别的地方出现。那么如何保证我们sql语法糖的规范统一呢，那就用sql语法糖的校验。  \n  \n* [基于Spring的代码分层校验](/posts/基于Spring的代码分层校验)    \n  领域驱动DDD你应该听过吧？DDD过于抽象，实际项目当中用好DDD并不容易。**这样分层更合理，且更容易维护**(吸取了DDD的精髓)。\n\n## 定义统一异常拦截处理类  \n* [springMvc统一异常处理](/posts/springMvc统一异常处理)  \n  \n* [设置事务对所有的异常进行回滚](/posts/spring事务和aop的原理#设置事务对所有的异常进行回滚)  \n  事务回滚默认为RuntimeException和Error  \n  如捕获异常也需要事务回滚，但是还不想修改注解的话可以用这种方式，这种方法是全局生效的  \n\n## 定义日志打印帮助问题排查\n[http日志链路追踪]()  \n[request记录请求体中的数据]()  \n[dubbo日志链路追踪]()  \n\n## 定义统一响应包装类\n* [mvc对外提供统一响应包装](/posts/mvc对外提供统一响应包装)  \n\n* [强制后端的提示信息实现的in18国际化]()  \n\n## 定义swagger通用接口文档\n* [定义swagger通用接口文档](/posts/定义swagger通用接口文档)\n我们用的swagger版本为\n  \n```xml\n\n<dependency>\n    <groupId>com.github.xiaoymin</groupId>\n    <artifactId>swagger-bootstrap-ui</artifactId>\n    <version>1.9.6</version>\n</dependency>\n\n```\n\n1. 由于swagger的分组在配置文件中不支持中文，所以我们给他改成中文  \n1. 由于我们统一了http最外层的响应包装，swagger是检测不出来的，所以我们要给他加上最外层的响应包装  \n1. 由于我们统一了枚举，swagger也是检测不出来的，所以我们要给他加上枚举的注释以及对应的value  \n\n## 危险，集成热部署工具（线上禁止使用）\n* [springDevTools+jdkInstruments实现热部署](/posts/解决springRemoteRestart不起作用#优化热部署-减少部署时间)  \n自己编写的简单热部署工具，不用运维、不用第三方庞大的插件。只需要有http服务的接口即可,非常简易\n","tags":["效率"],"categories":["效率","java开发"]},{"title":"奇葩说-刘秦vs薛兆丰","url":"/posts/奇葩说-刘秦vs薛兆丰/","content":"总感觉我一个文盲谈论一个权威极高的教授实在是没有资格。但也确实这样（没有资格）。但我观察这两个教授的言行并总结下来能够对我有很大帮助\n\n# 第7季\n宋丹丹来的那一季~因为我只看了20分钟，印象不深，但是薛老师的观点我特别赞同，所以印象特别深~\n\n## 薛兆丰  \n\n* 痛苦不是成本，损失一个机会才是成本  \n> 痛苦是可以磨炼人的意志力的。对你来说并没有损失什么，只是心情上的落差。\n但是在现有的社会中没有人会关心你的心情，人毕竟是自私自利的。所以在三观正常、态度正确的情况下你应该为你争取更多的机会。而不是胆怯和懦弱\n\n* 做难做的工作，谈简单的恋爱  \n> 人是琢磨不透的，月有阴晴圆缺，人有阴晴不定，如果你谈难谈的恋爱，很有可能结果是一场空。\n但是你做难做的工作，对你来说都是阅历、知识和经验、对以后事业是有帮助的（毕竟人还是要独立的）。\n虽然你谈复杂的恋爱也有经历和经验，也能傍大款，但是一但你换对象（换工作）会给人的感觉你不忠，能天天傍大款吗？再说傍大款也需要你有内在的谈吐（就是你肚子里有没有墨水）。\n更何况不忠映射到工作上来呢（Boss会录用一个不忠的人吗）？所以一定要做做难做的工作，谈简单的恋爱","categories":["生活","感想"]},{"title":"js-copy","url":"/posts/js-copy/","content":"\n觉得手动copy麻烦的话，写一个小脚本，执行即可copy  \n\n```javascript\n// 获取val\nlet val = \"\";\n// 这段代码是我们在confluence 维护的sql代码片段。执行即可获取全部的sql\n$('.code .container div').each((i,e)=>val+= $(e).text() + \"\\n\");\n\n// 执行copy\nlet input = document.createElement('textarea');\ninput.value = val;\ndocument.body.appendChild(input);\ninput.select();\ndocument.execCommand('copy');\ndocument.body.removeChild(input);\n```","tags":["js","开发工具类"],"categories":["js"]},{"title":"我的第一本人生规划手册","url":"/posts/我的第一本人生规划手册/","content":"# 我的第一本人生规划手册\n\n* 小孩子为什么会情绪崩溃大哭？因为当脑子中的词汇量无法精准表达自己情绪的时候，只能情绪大哭。\n> 我理解一旦有失落的时候，情绪不好的时候，一定要找人倾诉，表达出来。其实就是释放出来，但不一定倾听者是人。主要就是不能憋着。\n\n## 5w2h1e  \n* why、what、who、when、where    \n为什么要干什么，谁，何时何地  \n\n* how、how much      \n怎么做，需要多少资源？  \n\n* effect    \n预测结果，有什么样的效果？","tags":["书籍","读书笔记"],"categories":["生活","书籍"]},{"title":"通用枚举","url":"/posts/通用枚举/","content":"\n# 使用场景\n我们一般用枚举来代表数字或者字符串，避免魔法值的产生。\n有时需要根据数字或字符串获取到对应的枚举。\n虽然可以在枚举里面写静态方法根据int获取对应的枚举也可以做到，但是你需要在一个枚举写一个方法，如果有N多个枚举则会非常的冗余  \n类似于这段代码\n```java\n@Getter\npublic enum Condition {\n  ONCE(0, \"满\"),\n  EACH_TIMES(1, \"每满\"),\n  LADDERED(2, \"阶梯满\");\n\n  private final int code;\n  private final String name;\n\n  Condition(int code, String name) {\n    this.code = code;\n    this.name = name;\n  }\n\n  // 类似于这段代码\n  public static Condition getTypeByCode(int code) {\n    for (Condition value : Condition.values()) {\n      if (value.getCode() == code) {\n        return value;\n      }\n    }\n    return null;\n  }\n}\n```\n避免**冗余代码**，所以用到此工具类，用法就是所有的枚举需要实现此类即可进行使用\n\n## 代码  \n\n### <span id='一个枚举对应多个标识'>一个枚举可以有多个标识</span>  \n```java\nimport java.io.Serializable;\nimport java.util.Objects;\n\n/**\n * IdentityIEnums\n * 可以有多个标识的枚举\n *\n * @author anyOne\n */\npublic interface IEnums<T extends Serializable> {\n\n    /**\n     * 获取枚举的标识\n     */\n    T[] getIdentities();\n\n    /**\n     * 枚举对应的文档，描述\n     */\n    String getDoc();\n\n    /**\n     * 传入指定的枚举class，和指定的identity(变量标识)\n     * 如果枚举的identity和传入的相等则返回对应的枚举\n     */\n    static <T extends Serializable, E extends IEnums<T>> E mustGetEnum(Class<E> enumClass, T identity) {\n        return getEnum(enumClass, identity)\n                .orElseThrow(NullPointerException::new);\n    }\n\n    static <T extends Serializable, E extends IEnums<T>> Optional<E> getEnum(Class<E> enumClass, T identity) {\n        E e = getEnum(enumClass, identity, null);\n        return Optional.ofNullable(e);\n    }\n\n    static <T extends Serializable, E extends IEnums<T>> E getEnum(Class<E> enumClass, T identity, E defaultValue) {\n        for (E enumConstant : enumClass.getEnumConstants()) {\n            for (T t : enumConstant.getIdentities()) {\n                if (Objects.equals(t, identity)) {\n                    return enumConstant;\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n}\n```\n\n### 一个枚举对应一个标识  \n\n* util  \n```java\nimport java.io.Serializable;\n// 单个变成数组util\npublic class ObjectUtils extends org.apache.commons.lang3.ObjectUtils {\n    @SafeVarargs\n    public static <T extends Serializable> T[] array(T... t) {\n        return t;\n    }\n}\n```\n\n* 代码复用、继承即可，最终还是调用[一个枚举对应多个标识](#一个枚举对应多个标识)那个工具类  \n```java\nimport ObjectUtils;\nimport java.io.Serializable;\nimport java.util.Optional;\n\npublic interface IEnum<T extends Serializable> extends IEnums<T> {\n\n    /**\n     * 获取枚举的标识\n     */\n    T getIdentity();\n\n    // 默认实现获取多个标识 \n    default T[] getIdentities() {\n        return ObjectUtils.array(getIdentity());\n    }\n}\n```\n\n## 使用例子一\n\n* 工具类  \n```java\n@Slf4j\npublic enum ENV implements IEnums<String> {\n    RELEASE(\"release\", \"prod\"),\n    PRE(\"pre\"),\n    TEST(\"test\", \"test1\", \"test2\", \"test3\"),\n    DEV(\"dev\"),\n    LOCAL(\"local\"),\n    ;\n\n    private final String[] envs;\n\n    ENV(String... envs) {\n        this.envs = envs;\n    }\n\n    // 只要实现此方法即可\n    @Override\n    public String[] getIdentities() {\n        return envs;\n    }\n}\n```\n\n* 使用详情  \n```java\nENV env = IEnums.getEnum(ENV.class, \"dev\", RELEASE);\nENV test1 = IEnums.getEnum(ENV.class, \"test1\", RELEASE);\nENV test2 = IEnums.getEnum(ENV.class, \"test2\", RELEASE);\nassert test1 == test2;\n```\n\n\n\n\n## 使用例子二\n\n* 工具类\n```java\npublic enum UserType implements IEnum<Integer> {\n\n  NEW_USER(1, \"新用户\"),\n\n  OLD_USER(0, \"老用户\");\n  public final int code;\n\n  public final String doc;\n\n  UserType(int code, String doc) {\n    this.code = code;\n    this.doc = doc;\n  }\n\n  @Override\n  public Integer getIdentity() {\n    return code;\n  }\n\n  @Override\n  public String getDoc() {\n    return doc;\n  }\n}\n```\n\n* 使用详情\n```java\nOptional<UserType> type = IEnums.getEnum(UserType.class, 1);\n```\n\n# 总结\n在项目中，把我们的枚举统一归纳起来，所有的枚举实现此类接口。这样就可以直接爽快的使用了","tags":["开发工具类","java","枚举"],"categories":["java","枚举"]},{"title":"javaUtil动态代理","url":"/posts/javautil动态代理/","content":"动态代理有很多使用的场景，比如  \n* springAOP切入\n* spring事务、缓存\n* 自定义业务场景等\n\n本文就是一个动态代理util。为了使用起来更加的方便。之后的文章也有可能用得到。  \n> 后续用新文章来分析动态代理的原理\n\n[本文的使用场景（点我）](#本文的使用场景)\n\n# 代码  \n```java\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\n\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Method;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * 动态代理\n *\n * @author anyOne\n * @since 2021/4/30 12:19 PM\n */\npublic class DynamicProxy<T> implements MethodInterceptor {\n\n    private final T target;\n    private final Class<?> targetClass;\n    private final boolean ignoreObjectMethod;\n    private final Object[] arguments;\n    private CallBack<T> callBack;\n\n    public DynamicProxy(T proxyTarget, Object... arguments) {\n        this(proxyTarget, true, arguments);\n    }\n\n    public DynamicProxy(T proxyTarget, boolean ignoreObjectMethod, Object... arguments) {\n        this.target = proxyTarget;\n        this.ignoreObjectMethod = ignoreObjectMethod;\n        this.targetClass = proxyTarget.getClass();\n        this.arguments = arguments;\n    }\n\n\n    /**\n     * 忽略所有的set方法\n     */\n    public T getProxyWithWriteMethod(CallBack<T> callBack) {\n        Set<Method> ignoreMethodNames = Stream.of(BeanUtils.getPropertyDescriptors(targetClass))\n                .map(PropertyDescriptor::getWriteMethod)\n                .collect(Collectors.toSet());\n\n        this.callBack = (obj, proxyMethod, args, originMethod) -> {\n            if (ignoreMethodNames.contains(originMethod)) {\n                return callBack.call(target, proxyMethod, args, originMethod);\n            }\n            return proxyMethod.invoke(target, args);\n        };\n        return getT();\n\n    }\n\n    public T getProxy(CallBack<T> callBack) {\n        this.callBack = callBack;\n        return getT();\n    }\n\n    private T getT() {\n        // 创建代理对象\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(targetClass);\n        enhancer.setCallback(this);\n\n        try {\n            return create(enhancer);\n        } catch (Exception e) {\n            // 如果针对class创建失败，则只针对接口创建代理\n            enhancer = new Enhancer();\n            Class<?>[] allInterfacesForClass = ClassUtils.getAllInterfacesForClass(targetClass);\n            enhancer.setInterfaces(allInterfacesForClass);\n            enhancer.setCallback(this);\n            return create(enhancer);\n        }\n    }\n\n    private T create(Enhancer enhancer) {\n        if (arguments == null || arguments.length == 0) {\n            //noinspection unchecked\n            return (T) enhancer.create();\n        } else {\n            Class<?>[] classes = Stream.of(arguments)\n                    .map(Object::getClass)\n                    .toArray(Class[]::new);\n            //noinspection unchecked\n            return (T) enhancer.create(classes, arguments);\n        }\n    }\n\n\n    @Override\n    public Object intercept(Object obj, Method originMethod, Object[] args, MethodProxy proxyMethod) throws Throwable {\n        if (ignoreObjectMethod && ReflectionUtils.isObjectMethod(originMethod)) {\n            return proxyMethod.invoke(target, args);\n        }\n        return callBack.call(target, proxyMethod, args, originMethod);\n    }\n\n\n    public interface CallBack<T> {\n        /**\n         * 代理拦截的方法，需要用户自己实现\n         */\n        Object call(T target, MethodProxy proxyMethod, Object[] args, Method originMethod) throws Throwable;\n    }\n}\n```\n\n## <span id='本文的使用场景'>使用方式之一</span>\n分页查询只想查询一个，但是每次new对象在去赋值，非常浪费时间。并且还会出遗漏的问题    \n所以建一个全局的对象，但是这个全局的对象，他又是多线程共享，不能保证他的安全，比如我只想保证他的变量page=1,别的线程set就会影响其他线程。  \n所以如果我建立一个全局的变量，大家共享，也不怕被set而影响其他的线程，那么可以用到此动态代理\n\n```java\npublic class Pageable {\n    private static final int DEFAULT_SIZE = 10;\n    private static final int MAX_SIZE = 1000;\n\n    public static final Pageable ONLY_ONE = new DynamicProxy<>(newOnlyOne(), true)\n            .getProxyWithWriteMethod((target, proxyMethod, args, originMethod) -> {\n                // 此处抛出异常，也可以return null，但我建议还是把问题暴露出去，避免留坑\n                throw new Throwable(\"禁止修改全局的类\");\n            });\n\n    public static Pageable newOnlyOne() {\n        Pageable onlyOne = new Pageable();\n        onlyOne.setSearchCount(false);\n        onlyOne.setPage(1);\n        onlyOne.setPageSize(1);\n        return onlyOne;\n    }\n\n    private long page = 1;\n\n    private long pageSize = DEFAULT_SIZE;\n\n    private boolean isSearchCount = true;\n}\n```\n\n# 总结\n这个动态代理只是一个工具类，其他需要用到的地方用起来贼方便。基本上3两行代码即可搞定。  \n比如说这篇文章 [MybatisPlus查询软删除的数据](/posts/重新加装MybatisPlus#然后定义这些个方法的实现)  \n\n后续源码原理什么的，等我有时间了在分析😁","tags":["开发工具类","java"],"categories":["java","动态代理"]},{"title":"环境变量","url":"/posts/环境变量/","content":"## main方法参数  \n使用：java  类名   【参数1】 【参数2】 【参数3】 .。。。\n```java\n    public static void main(String[] args) {\n        System.out.println(args);\n    }\n```\n\n## System.getenv  \n获取系统环境变量  \n同 linux 下 `export`\n\n## System.getProperty    \n获取java程序变量  \n通过 java -Dk=v配置\n","tags":["java"],"categories":["java","基础"]},{"title":"dubbo-spi","url":"/posts/dubbo-spi/","content":"\n* java有spi机制为什么dubbo还要自创一套？\n  - javaSpi没有key value机制，全部都是实现类。没有顺序之分\n  - javaSpi 如果有多个实现类，只能依次加载，不能精准加载\n  - ...等\n\n# dubboSPI的特性  \n  - 可根据key获取指定的SPI实现  \n  - 可根据@Activate注解进行分类，获取指定的SPI实现  \n  - 多个实现可排序  \n    实现排序接口org.apache.dubbo.common.lang.Prioritized\n  - 可包装(静态代理)  \n    对原有的spi实现直接编码进行静态的代理，spi的实现类只留一个有参构造，参数为SPI接口的类型即可变为wrapper\n  - 可注入  \n    对spi的实现类中如果有set方法，且没有DisableInject注解，那么以此方法的第一个参数的类型+名称，再次从dubboSPI容器中寻找对应的实例。并set\n  - spi无实现者的情况下，可自适应实现(一般开发者用不到)   \n    方法：```getAdaptiveExtension()```  \n    如果spi配置文件中有配置实现类并且类上有Adaptive注解，则直接用此类。  \n    如果没有实现类，但是spi接口中个别方法上有Adaptive注解，并且参数有URL的类型（或者可从参数上获取到url），那么在调用的时候会根据adaptive注解的value,作为key从url中获取对应的value。然后在从SPI容器获取对应的实例，进行动态的调用\n  - ...等其他特性\n\n# 使用例子    \n```java\nExtensionLoader<ABC> LOADER = ExtensionLoader.getExtensionLoader(ABC.class);\n// 用法1：通过@SPI注解获取默认的实现（有可能为空）\nABC defaultImpl = LOADER.getDefaultExtension();\n\n// 用法2: spi其他的实现（可根据配置文件中的key精准获取）\nABC instance = LOADER.getExtension(\"key\");\n\n// 用法3：获取自适应实现。（这个一般开发人员用不到）\nABC adaptiveExtension = LOADER.getAdaptiveExtension();\n\n// 用法4：根据@Activate注解的配置，获取有效的spi实例\n// 比如注解@Active(value=\"key1:value1, key2:value2\", group=\"consumer\")\nList<T> activeExtension = LOADER.getActivateExtension(URL url, String[] values); //  从spi从起找对应的名称：values 为spi实现类的key。\nactiveExtension = LOADER.getActivateExtension(URL url, String key, String group); // 与上面类似。只不过value是以key从url中取。 group 参数：过滤掉和注解@activate中group不一样的\nactiveExtension = LOADER.getActivateExtension(URL url, String[] values, String group); // 结合上面两个\n```\n\n# Activate\n\ndubbo-spi中有3个方法，用来进行分类获取。\n\n```java\nList<T> getActivateExtension(URL url, String[] values);\nList<T> getActivateExtension(URL url, String key, String group);\nList<T> getActivateExtension(URL url, String[] values, String group);\n```\n\n注解  \n```java\npublic @interface Activate {\n    String[] group() default {};// 分组\n\n    String[] value() default {};// \"key1:value1, key2:value2\",会从url中匹配对应的\n    ...\n    int order() default 0;\n}\n```\n\n当dubbo-spi在加载实现类时，会判断实现类是否有该注解，如果有的话则会把这些实现类(带有注解的)缓存起来。\n这样调用getActivateExtension时就会过滤条件并获取到对应的实现\n\n## 使用\n![配置图](/img/posts/2021/07/dubbo-filter.png)\n\n\n# wrapper\n对原有对象的包装，类似于静态代理。可以拦截做很多事情。\n如果spi实现类没有空构造方法并且有一个有参的构造函数，且类型是当前实现的接口。\n那么在最终暴露的对象为此wrapper。\n\n## 使用\n使用图同Activate，不同点是，不需要加注解。并且需要一个有参的构造方法，参数类型是接口。同样配置在配置文件里面。即可完成配置\n\n\n# 简单分析dubbo-spi的初始化\n通过[java-spi](/posts/java-spi)来找到dubboSpi配置的目录\n```java\npublic interface LoadingStrategy extends Prioritized {\n    String directory();\n}\n```\n\n下图是dubbo的默认加载路径，*咱们也可以通过[javaSpi](/posts/java-spi)，扩展一个新的加载路径*\n![原理图](/img/posts/2021/07/dubbo-spi.png)\n\n> dubboSpi配置目录下的文件和javaSPI的规范一样，都是以spi全类名作为文件名，不同之处就是内容。  \ndubboSpi配置文件的内容为key=value,key是一个名称，value为实现的class全类名，可以为多行  \njavaSpi配置文件的内容为多行，每行代表一个实现类的全类名名称。  \ndubbo用```ExtensionLoader.getExtensionLoader(ABC.class).getExtension(\"key\")```即可获取到对应的实例\n\n\n## 加载并初始化的代码分析\n\n```java\npublic class ExtensionLoader<T> {\n  ...\n  // 加载路径，如上图的通过javaSPI寻找默认的实现\n  private static volatile LoadingStrategy[] strategies = stream(ServiceLoader.load(LoadingStrategy.class).spliterator(), false)\n          .sorted()\n          .toArray(LoadingStrategy[]::new);\n\n  // 解析spi所有的配置文件\n  private Map<String, Class<?>> getExtensionClasses() {\n    cacheDefaultExtensionName();// 根据@SPI注解获取到默认的实现名称，可以为空\n\n    Map<String, Class<?>> extensionClasses = new HashMap<>();\n\n    // 加载路径，如上图的默认实现\n    for (LoadingStrategy strategy : strategies) {\n      // 例如：ExtensionLoader.getExtensionLoader(ABC.class)\n      // type为当前的SPI接口,即ABC.class\n      loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());\n      // alibaba变为apache，兼容之前老的实现\n      loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(\"org.apache\", \"com.alibaba\"), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());\n      // loadDirectory 通过解析配置文件里面的内容，最终会调用loadClass，\n    }\n    return extensionClasses;\n  }\n\n  // 配置文件中的value字符转为class，并分类管理\n  private void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL resourceURL, Class<?> clazz, String name, boolean overridden) {\n    ... \n    if (clazz.isAnnotationPresent(Adaptive.class)) {\n      cacheAdaptiveClass(clazz, overridden);// 缓存自适应的实现，如果有多个overridden用来控制是否可覆盖，不能覆盖则直接报错\n    }\n    else if (isWrapperClass(clazz)) { // 如过有一个有参构造，参数类型是spi的接口，那么就是wrapper\n      cacheWrapperClass(clazz); // 缓存包装类，可以有多个。\n    } else {\n      String[] names = Pattern.compile(\"\\\\s*[,]+\\\\s*\").split(name);\n      cacheActivateClass(clazz, names[0]);// 进行分类如果有@Activate注解的话\n      for (String n : names) {\n        cacheName(clazz, n); // 缓存class与对应的名称,不能覆盖。\n        saveInExtensionClass(extensionClasses, clazz, n, overridden);// 保存到 extensionClasses 中，如果name已经存在，overridden用来控制是否可覆盖，否则抛异常\n      }\n    }\n  }\n  \n  // 根据name获取实例（初始化）\n  private T createExtension(String name, boolean wrap) {\n    Class<?> clazz = getExtensionClasses().get(name);\n    ...\n    // 实例化，忽略缓存的逻辑，只会初始化，一次\n    T instance = clazz.newInstance();\n    injectExtension(instance); // 注入操作，对当前实体中如果有set方法，且没有DisableInject注解，那么以此方法的第一个参数的类型+名称，再次从dubboSPI容器中寻找对应的实例。并set\n\n    // 如果wrap为true\n    if (wrap) {\n\n      List<Class<?>> wrapperClassesList = new ArrayList<>();\n      wrapperClassesList.addAll(cachedWrapperClasses);\n      wrapperClassesList.sort(WrapperComparator.COMPARATOR);\n      Collections.reverse(wrapperClassesList);\n\n      if (CollectionUtils.isNotEmpty(wrapperClassesList)) {\n        for (Class<?> wrapperClass : wrapperClassesList) {\n          Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);\n          // 如果有@Wrapper注解，则根据注解判断是否符合要求\n          if (wrapper == null || (ArrayUtils.contains(wrapper.matches(), name) && !ArrayUtils.contains(wrapper.mismatches(), name))) {\n            // 进行包装\n            instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n          }\n        }\n      }\n    }\n    ...\n    initExtension(instance); // 如果实现了Lifecycle接口，则调用其生命周期的方法\n    return instance;\n  }\n}\n```\n\n# 总结\ndubboSPI比javaSPI多处好几个功能，我们一般都用不到，但是如果想要了解dubbo工作的整体流程。dubboSPI的代码是必须要掌握的。  ","tags":["java","源码","dubbo-spi"],"categories":["java","dubbo"]},{"title":"java-spi","url":"/posts/java-spi/","content":"## javaSPI机制\nservice provider interface\n```java\n// 通过遍历即可获取到对应的class,那么原理是什么呢？\nIterator<ABC> iterator = ServiceLoader.load(ABC.class).iterator();\nwhile (iterator.hasNext()) {\n    ABC next = iterator.next();\n}\n```\n\n# 原理\n\njava规定spi的配置文件都在这个目录```META-INF/services/```  \n该目录下可以有多个文件，文件的名称必须以class全类名命名。通过ServiceLoader类，读取名字为spi类的全名称的文件  \n内容为多行，一行为一个class的全类名。该class为spi的实现类。\n\n## ServiceLoader入口\n```java\n\npublic final class ServiceLoader<S> implements Iterable<S> {\n\n    private static final String PREFIX = \"META-INF/services/\"; // 扫描的目录\n\n    private final Class<S> service; // spi 要加载的class\n\n    private final ClassLoader loader;// classLoader，默认为当前线程的classLoader\n    \n    private LinkedHashMap<String,S> providers = new LinkedHashMap<>(); // 已加载过的SPI都会缓存\n\n    private LazyIterator lookupIterator; // 真正加载的class\n    \n    private ServiceLoader(Class<S> svc, ClassLoader cl) {\n        loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;\n        lookupIterator = new LazyIterator(service, loader);\n    }\n    ...\n    // 入口\n    public static <S> ServiceLoader<S> load(Class<S> service, ClassLoader loader) {\n        return new ServiceLoader<>(service, loader);\n    }\n\n    public Iterator<S> iterator() {\n        return new Iterator<S>() {\n\n            Iterator<Map.Entry<String,S>> knownProviders = providers.entrySet().iterator(); // 缓存\n\n            public boolean hasNext() {\n                if (knownProviders.hasNext())// 先用缓存\n                    return true;\n                return lookupIterator.hasNext();\n            }\n\n            public S next() {\n                if (knownProviders.hasNext())\n                    return knownProviders.next().getValue(); // 先用缓存\n                return lookupIterator.next();\n            }\n            ...\n        };\n    }\n}\n```\n## LazyIterator 真正的加载类\n\n```java\nprivate class LazyIterator implements Iterator<S> {\n    ...\n    Class<S> service;\n    ClassLoader loader;\n    Enumeration<URL> configs = null;// 已扫描的url\n    Iterator<String> pending = null; // 当前扫描的url资源中的spi文本（className为多行）\n    String nextName = null; //下一个spi实现类的名称\n    private LazyIterator(Class<S> service, ClassLoader loader) {\n        this.service = service;\n        this.loader = loader;\n    }\n    \n    // 迭代器的实现\n    public boolean hasNext() {\n        ...\n        configs = configs != null ? configs : loader.getResources(\"META-INF/services/\" + service.getName());\n        while ((pending == null) || !pending.hasNext()) {\n            if (!configs.hasMoreElements()) {\n                return false;\n            }\n\n            pending = parse(service, configs.nextElement());\n        }\n        // 直接返回\n        nextName = pending.next();\n        return true;\n        ...\n    }\n\n    // 迭代器的实现\n    public S next() {\n        ...\n        String cn = nextName;\n        nextName = null;\n        Class<?> c = null;\n        try {\n            c = Class.forName(cn, false, loader);\n        } catch (ClassNotFoundException x) {\n            fail(service, \"Provider \" + cn + \" not found\");\n        }\n        // 该不是spi接口的实现，乱配置的就直接抛出异常\n        if (!service.isAssignableFrom(c)) {\n            fail(service, \"Provider \" + cn  + \" not a subtype\");\n        }\n        try {\n            S p = service.cast(c.newInstance());\n            providers.put(cn, p);// 缓存一下\n            return p;// 反射创建对象，直接返回\n        } catch (Throwable x) {\n            fail(service, \"Provider \" + cn + \" could not be instantiated\", x);\n        }\n        ...\n    }\n    ...\n}\n```\n# 总结\n本文以jdk1.8来分析，其他版本略有不同。总的来说就是获取资源```META-INF/services/```目录下的文件名与spi的class名称一致的文件。\n读取里面的实现类，然后通过反射按需实例化并缓存。  \n但是缓存有局限性哦，只能针对同一个ServiceLoader对象多次产生的迭代器有效哦。","tags":["java","源码"],"categories":["java","spi"]},{"title":"代码高亮","url":"/posts/代码高亮/","content":"测试代码高亮\n\n```java\n@Override\nprotected Object doGetInjectedBean(AnnotationAttributes attributes, Object bean, String beanName, Class<?> injectedType,\n                                   InjectionMetadata.InjectedElement injectedElement) throws Exception {\n    /**\n     * The name of bean that annotated Dubbo's {@link Service @Service} in local Spring {@link ApplicationContext}\n     */\n    String referencedBeanName = buildReferencedBeanName(attributes, injectedType);\n\n    /**\n     * The name of bean that is declared by {@link Reference @Reference} annotation injection\n     */\n    String referenceBeanName = getReferenceBeanName(attributes, injectedType);\n\n    ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referenceBeanName, attributes, injectedType);\n\n    boolean localServiceBean = isLocalServiceBean(referencedBeanName, referenceBean, attributes);\n\n    prepareReferenceBean(referencedBeanName, referenceBean, localServiceBean);\n\n    registerReferenceBean(referencedBeanName, referenceBean, attributes, localServiceBean, injectedType);\n\n    cacheInjectedReferenceBean(referenceBean, injectedElement);\n\n    return referenceBean.get();\n}\n```\n","tags":["琐碎","博客"],"categories":["生活"]},{"title":"博客","url":"/posts/博客/","content":"测试部署","tags":["琐碎","博客"],"categories":["生活"]}]