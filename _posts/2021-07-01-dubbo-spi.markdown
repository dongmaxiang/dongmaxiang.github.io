---
layout: post
title: 初识-dubbo-spi
date: 2021-07-1 11:29:53.000000000 +08:00
categories: [java,dubbo]
tags: [dubbo-spi,源码,java]
permalink: /dubbo-spi.html
---

* java有spi机制为什么dubbo还要自创一套？
  - javaSpi没有key value机制，全部都是实现类。没有顺序之分
  - javaSpi 如果有多个实现类，只能依次加载，不能精准加载
  - ...

* dubboSPI的特性  
  - 可根据key获取指定的SPI实现
  - 多个实现可排序
  - 可包装（对原有的spi实现直接编码进行静态的代理，spi的实现类只留一个有参构造，参数为SPI接口的类型即可变为wrapper）
  - 可注入(对spi的实现类中如果有set方法，且没有DisableInject注解，那么以此方法的第一个参数的类型+名称，再次从dubboSPI容器中寻找对应的实例。并注入)
  - 自适应spi实现，动态执行方法逻辑（spi配置文件中的实现类上有Adaptive注解，则直接用实现类。如果没有实现类，但是spi接口中个别方法上有Adaptive注解，也会根据URL进行动态的适配）
  - ...

用法    
```java
ExtensionLoader<ABC> LOADER = ExtensionLoader.getExtensionLoader(ABC.class);
ABC defaultImpl = LOADER.getDefaultExtension();// 通过@SPI注解获取默认的实现（有可能为空）
ABC instance = LOADER.getExtension("key");// spi其他的实现（可根据配置文件中的key精准获取）
ABC adaptiveExtension = LOADER.getAdaptiveExtension(); //获取自适应实现。（这个一般开发人员用不到） 
```

## 原理
dubboSpi的类必须要有注解 @SPI
```java
// SPI必须注解在接口上
public @interface SPI {
    String value() default ""; // SPI的默认实现名称
}
```

然后通过[java-spi]({{ "/java-spi.html" | relative_url }})来找到默认的加载路径（dubboSpi配置的目录）
```java
public interface LoadingStrategy extends Prioritized {
    String directory();
}
```

下图是dubbo的默认加载路径，*咱们也可以通过[javaSpi]({{ "/java-spi.html" | relative_url }})，扩展一个新的加载路径*
![原理图](/assets/images/posts/2021/07/dubbo-spi.png)

dubboSpi配置目录下的文件和javaSPI的规范一样，都是以spi全类名作为文件名，不同之处就是内容。  
dubboSpi配置文件的内容为key=value,key是一个名称，value为实现的class全类名，可以为多行  
javaSpi配置文件的内容为多行，每行代表一个实现类的全类名名称。  
dubbo用```ExtensionLoader.getExtensionLoader(ABC.class).getExtension("key")```即可获取到对应的实例


## 源码分析  
```java
public class ExtensionLoader<T> {
  ...
  // 加载路径，如上图的默认实现
  private static volatile LoadingStrategy[] strategies = stream(ServiceLoader.load(LoadingStrategy.class).spliterator(), false)
          .sorted()
          .toArray(LoadingStrategy[]::new);

  // 缓存dubboSPI配置文件中的key对应的实例，Holder为懒加载实例的包装
  private final ConcurrentMap<String, Holder<Object>> cachedInstances = new ConcurrentHashMap<>();
  
  private ExtensionLoader(Class<?> type) {
    this.type = type;
    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
  }

  // 使用入口
  public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {
    ...
    // 忽略缓存的逻辑。最终会调用new ExtensionLoader
    return new ExtensionLoader<T>(type);
  }

  // 获取默认的实现的实例
  public T getDefaultExtension() {
    ...
    // cachedDeafultName 为SPI注解中的value字段
    if (StringUtils.isBlank(cachedDefaultName) || "true".equals(cachedDefaultName)) {
      return null;
    }
    return getExtension(cachedDefaultName, true);
  }

  // 获取指定key的实例
  public T getExtension(String name) {
    return getExtension(name, true);
  }

  public T getExtension(String name, boolean wrap) {
    // key 为true则返回默认的
    if ("true".equals(name)) {
      return getDefaultExtension();
    }
    ...
    // 缓存代码忽略
    Object instance = createExtension(name, wrap);
    ...
    return (T) instance;
  }

}
```

## Activate介绍

<i id="dubbo-spi中有3个方法">dubbo-spi中有3个方法</i>
```java
List<T> getActivateExtension(URL url, String[] values);
List<T> getActivateExtension(URL url, String key, String group);
List<T> getActivateExtension(URL url, String[] values, String group);
```

为什么会有activate呢？
原来是有Activate注解在起作用  
```java
public @interface Activate {
    String[] group() default {};

    String[] value() default {};

    @Deprecated
    String[] before() default {};

    @Deprecated
    String[] after() default {};

    int order() default 0;
}
```

当dubbo-spi在加载实现类时，会判断实现类是否有该注解，如果有的话则会把这些实现类(带有注解的)缓存起来。
这样调用[getActivateExtension](#dubbo-spi中有3个方法)时就会获取到对应的实现

## 使用图
![配置图](/assets/images/posts/2021/07/dubbo-filter.png)


## wrapper介绍
何为wrapper ?
就是包装，对原有对象的包装。
如果spi实现类没有空构造方法并且有一个有参的构造函数，且类型是当前实现的接口。
那么在最终暴露的对象为此wrapper。

## 实例化代码如下  

- 先加载class，并判断是否为wrapper  

```java
public class ExtensionLoader<T> {
  private boolean isWrapperClass(Class<?> clazz) {
    try {
      clazz.getConstructor(type);
      return true;
    } catch (NoSuchMethodException e) {
      return false;
    }
  }

  private void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL resourceURL, Class<?> clazz, String name,
                         boolean overridden) throws NoSuchMethodException {
    ... 
    if (clazz.isAnnotationPresent(Adaptive.class)) {
      cacheAdaptiveClass(clazz, overridden);
    }
    // 判断是否为包装
    else if (isWrapperClass(clazz)) {
      cacheWrapperClass(clazz);
    } else {
      clazz.getConstructor();
      if (StringUtils.isEmpty(name)) {
        name = findAnnotationName(clazz);
        ...
      }

      String[] names = NAME_SEPARATOR.split(name);
      if (ArrayUtils.isNotEmpty(names)) {
        cacheActivateClass(clazz, names[0]);
        for (String n : names) {
          cacheName(clazz, n);
          saveInExtensionClass(extensionClasses, clazz, n, overridden);
        }
      }
    }
  }
}
```

- 初始化判断需要wrap，则进行包装并返回  
```java
public class ExtensionLoader<T> {
    
  private T createExtension(String name, boolean wrap) {
    Class<?> clazz = getExtensionClasses().get(name);
    if (clazz == null) {
      throw findException(name);
    }
    try {
      T instance = (T) EXTENSION_INSTANCES.get(clazz);
      if (instance == null) {
        EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
        instance = (T) EXTENSION_INSTANCES.get(clazz);
      }
      injectExtension(instance);


      // 如果wrap为true
      if (wrap) {

        List<Class<?>> wrapperClassesList = new ArrayList<>();
        if (cachedWrapperClasses != null) {
          wrapperClassesList.addAll(cachedWrapperClasses);
          // 先排序
          wrapperClassesList.sort(WrapperComparator.COMPARATOR);
          Collections.reverse(wrapperClassesList);
        }

        if (CollectionUtils.isNotEmpty(wrapperClassesList)) {
          for (Class<?> wrapperClass : wrapperClassesList) {
            Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);
            if (wrapper == null
                    || (ArrayUtils.contains(wrapper.matches(), name) && !ArrayUtils.contains(wrapper.mismatches(), name))) {
              // 进行包装
              instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
            }
          }
        }
      }

      initExtension(instance);
      return instance;
    } catch (Throwable t) {
      throw new IllegalStateException("Extension instance (name: " + name + ", class: " +
              type + ") couldn't be instantiated: " + t.getMessage(), t);
    }
  }
}
```