---
layout: post
title: JVM所有的参数配置详解
permalink: /JVM所有的参数配置详解
date: 2021-09-19 13:21:03.000000000 +08:00
categories: [java,jvm]
tags: [jvm]
---
# 启动时输出jvm所有的配置
1. -XX:+PrintFlagsFinal

# 启动时输出非默认的jvm参数(人为配置的)
1. -XX:+PrintCommandLineFlags

# [循环放置安全点](/java安全点safePoint以及JIT#安全点都有哪些呢)  
1. -XX:+UseCountedLoopSafepoints

# 内存
## 1. -Mxs1024m  
   最小堆内存大小

## 2. -Mmx2048m  
   最大堆内存大小
   
## 3. -XX:+UseCompressedOops  
   开启普通对象的指针压缩，此参数也会默认开启UseCompressedClassPointers  
   一个对象的指针默认为8字节(64bit)，压缩后变为4字节(32bit)，最大可表示4G(2^32)，经JVM处理之后最大可访问地址为32G(堆内存大于32G时会自动失效)  
   为什么压缩后用4字节就可以最大访问32G呢，因为根据jvm对象对齐空间来算(ObjectAlignmentInBytes默认是8)，也就是按照最小对象8字节来算有8个空挡(间隔)，所以2^32*8bit=32G  
   开启之后会在机器码中植入压缩与解压指令，会给JVM增加额外的开销  
   在jdk6以后不是clientVM且是64位的jvm中默认为开启状态  
   
## 4. -XX:+UseCompressedClassPointers  
   开启在对象头中[类指针的压缩](/java内存模型和GC#1-对象头)  
   如果UseCompressedOops是关闭的状态，则会报错  
   
## 5. -XX:ObjectAlignmentInBytes=8  
   对象对齐空间大小(bit)默认为8

# 锁
1. -XX:-UseBiasedLocking  
  关闭[偏向锁](/java内存模型和GC#synchronized)、jdk1.6之后默认为开启偏向锁。偏向锁竞争时会STW，如果竞争过于激烈，会导致性能极具下降  
   
1. -XX:BiasedLockingBulkRebiasThreshold=20(默认)  
  偏向锁批量重偏向阈值，因为默认只能锁升级，升级轻量级锁需要等待[全局安全点](/java安全点safePoint以及JIT#safepoint)  
  如果某个class的对象的偏向锁升级为轻量级锁且次数达到第20次时，则会把第20个(包含)之后的对象全部偏向新的线程，避免升级为轻量级锁  
  > 批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁升级为轻量级锁  
  
1. -XX:BiasedLockingBulkRevokeThreshold=40(默认)  
  偏向锁批量撤销阈值，撤销之后直接从轻量级锁开始。同上，如果锁升级过多，在25秒(如下参数设置)内，超过40次，则直接撤销当前class所有对象的偏向锁  
  > 批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的  
   
1. -XX:BiasedLockingDecayTime=25000(默认)  
  同上，一定时间内的阈值  