---
layout: post
title: java内存模型和GC以及锁
permalink: /java内存模型和GC
date: 2021-10-13 17:43:40.000000000 +08:00
categories: [java,jvm]
tags: [jvm]
---

让我们带着问题一探究竟
一个Object对象占用几个字节，里面内容都是什么(对象占用大小)？在哪里分布呢(内存模型)？什么时候会销毁(GC)？  

# 对象占用大小

`new Object();`会占用多少内存呢？答案是16字节=128比特位=128bits

## 为什么是16字节呢？而不是17或者15？  
  这是因为8个字节=1byte,所以只能是8的倍数，那么是8，要么是16、24、32  
  那为什么是16，而不是24、32？这取决于里面的内容是什么

## 里面内容是什么呢？  

对象头和数据体两大部分  
### 1. 对象头
1. 前面8个字节为markword，记录对象被上锁的各种状态或者垃圾回收和hashcode相关的信息  
  默认无锁的情况如下，有锁的情况参考[java锁](#java锁)  
  * 64位系统中(64bit)  
    未使用：25位  
    hashcode:  31位存储对象的System.identityHashCode()，采用延迟加载技术  
    未使用：1位  
    gc分带年龄: 4位  
    偏向锁的标记：1位  
    当前对象的锁的状态：2位  
    25+31+1+4+1+2=64  
  * 32位系统中(也是有64bit,只不过java只用32bit)  
    hashcode:  25位存储对象的System.identityHashCode()，采用延迟加载技术  
    gc分带年龄: 4位  
    偏向锁的标记：1位  
    当前对象的锁的状态：2位  
    25+4+1+2 = 32  


2. 接下来4个字节(也有可能是8个字节)是一个指向对象所属Class对象的指针  
 为什么有可能是4有可能是8呢，取决于是否开启了[classPointer指针压缩](/JVM所有的参数配置详解#4--xxusecompressedclasspointers)  
 JVM通过这个指针确定对象是哪个类的实例  
 一个对象里面的数据都是紧挨着的，因为是紧挨着，无法区分数据断点在哪里，所以必须有class对象的指针，通过对象起始地址和字段的偏移地址(从class获取)读取字段的数据  

3. 如果是数组类型的话对象头还得再加4个或8个字节([取决于是否开启压缩指针](/JVM所有的参数配置详解#3--xxusecompressedoops))表示数组的长度  
   只有当本对象是一个数组对象时才会有这个部分

### 2. 对象数据体
对象的里面的数据  
如果过基本类型则是对应的值占用的空间，如果是引用类型那么大小有可能是8bit或者4bit[取决于是否开启压缩指针](/JVM所有的参数配置详解#3--xxusecompressedoops)  
   
### 3. 对齐填充数据(可选)  
[根据对象对齐空间进行对齐，默认为8bit](/JVM所有的参数配置详解#5--xxobjectalignmentinbytes8)  
因为必须是8的倍数，不是8的倍数剩下的将要补齐  
   

所以一个1new Object()`为16字节，8字节为对象头，后面8字节为class对象的指针和数据填充  
1G内存大约可以存1024 * 1024 * 1024 / 16 = 67108864(约等于6千7百万多个对象)  

---


# java锁
* java都有哪些锁呢？  
   1. 是否阻塞
      悲观、乐观
      
   2. 是否公平
      非公平、公平
      
   3. 是否共享
      共享锁、排他锁
      
   4. 二次是否能获取
     不可重入锁、可重入锁

* java大部分锁都是通过对象头中的markword来实现的