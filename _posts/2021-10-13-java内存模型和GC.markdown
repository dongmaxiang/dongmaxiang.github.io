---
layout: post
title: java内存模型和GC以及锁
permalink: /java内存模型和GC
date: 2021-10-13 17:43:40.000000000 +08:00
categories: [java,jvm]
tags: [jvm]
---

让我们带着问题一探究竟
一个Object对象占用几个字节，里面内容都是什么(对象占用大小)？在哪里分布呢(内存模型)？什么时候会销毁(GC)？  

# 对象占用大小

`new Object();`会占用多少内存呢？答案是16字节=128比特位=128bits

## 为什么是16字节呢？而不是17或者15？  
  这是因为8个字节=1byte,所以只能是8的倍数，那么是8，要么是16、24、32  
  那为什么是16，而不是24、32？这取决于里面的内容是什么

## 里面内容是什么呢？  

对象头和数据体两大部分  
### 1. 对象头
1. 前面8个字节为markword，记录对象被上锁的各种状态或者垃圾回收和hashcode相关的信息  
  默认无锁的情况如下，有锁的情况参考[java锁](#synchronized)  
  * 64位系统中(64bit)  
    未使用：25位  
    hashcode:  31位存储对象的System.identityHashCode()，采用延迟加载技术  
    未使用：1位  
    gc分带年龄: 4位  
    偏向锁的标记：1位  
    当前对象的锁的状态：2位  
    25+31+1+4+1+2=64  
  * 32位系统中(也是有64bit,只不过java只用32bit)  
    hashcode:  25位存储对象的System.identityHashCode()，采用延迟加载技术  
    gc分带年龄: 4位  
    偏向锁的标记：1位  
    当前对象的锁的状态：2位  
    25+4+1+2 = 32  


2. 接下来4个字节(也有可能是8个字节)是一个指向对象所属Class对象的指针  
 为什么有可能是4有可能是8呢，取决于是否开启了[classPointer指针压缩](/JVM所有的参数配置详解#4--xxusecompressedclasspointers)  
 JVM通过这个指针确定对象是哪个类的实例  
 一个对象里面的数据都是紧挨着的，因为是紧挨着，无法区分数据断点在哪里，所以必须有class对象的指针，通过对象起始地址和字段的偏移地址(从class获取)读取字段的数据  

3. 如果是数组类型的话对象头还得再加4个或8个字节([取决于是否开启压缩指针](/JVM所有的参数配置详解#3--xxusecompressedoops))表示数组的长度  
   只有当本对象是一个数组对象时才会有这个部分

### 2. 对象数据体
对象的里面的数据  
如果是基本类型则是对应的值占用的空间，如果是引用类型那么大小有可能是8bit或者4bit[取决于是否开启压缩指针](/JVM所有的参数配置详解#3--xxusecompressedoops)  
   
### 3. 对齐填充数据(可选)  
[根据对象对齐空间进行对齐，默认为8bit](/JVM所有的参数配置详解#5--xxobjectalignmentinbytes8)  
因为必须是8的倍数，不是8的倍数剩下的将要补齐  
   

所以一个`new Object()`为16字节，8字节为对象头，后面8字节为class对象的指针和数据填充  
1G内存大约可以存1024 * 1024 * 1024 / 16 = 67108864(约等于6千7百万多个对象)  

---


# java锁
* java都有哪些锁呢？  
   1. 是否阻塞  
      悲观(阻塞其他线程-synchronized)、乐观(不阻塞其他线程-ReentrantLock和ReentrantReadWriteLock)
      
   2. 是否公平  
      非公平(synchronized)、公平(ReentrantLock和ReentrantReadWriteLock)

   3. 二次是否能获取  
     不可重入锁(jdk没有自带的)、可重入锁(jdk自带的锁都可以重入)  
      
   4. 是否共享  
      共享锁(ReentrantReadWriteLock)、排他锁

* 大体分为synchronized、ReentrantLock和ReentrantReadWriteLock3个阵营  

## synchronized
* 特性：阻塞、非公平、可重入、排他锁  
* 原理  
  jdk1.6引入了偏向锁和轻量级锁，1.6之前都是重量级锁，意思就是互斥等待都需要内核态完成（操作系统），开销非常的大  
  每一个Java对象就有一把看不见的锁，存放在对象头中叫markword，占用8个字节(动态的内容)，[无锁的情况下里面存放默认的数据](#1-对象头)  
  偏向锁、轻量级锁、重量级锁都是根据markword里面的数据来标识当前锁的状态  
  在32位jvm中占用空间如下所示  
  ![如图](/assets/images/posts/2021/markword.png)


## ReentrantLock
特性：非阻塞和阻塞、非公平和公平、可重入、排他锁

## ReentrantReadWriteLock
特性：非阻塞和阻塞、非公平和公平、可重入、共享锁